"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[822],{6436:(e,t,n)=>{n.d(t,{lj:()=>i});var a=n(2784);class o{static now(){return new Date}static consoleLogJson(e,t){void 0===t&&(t=!0);const n=JSON.stringify(e,(()=>{const e=new WeakSet;return(t,n)=>{if(!t.startsWith("__react")){if("object"==typeof n&&null!==n){if(e.has(n))return;e.add(n)}return n}}})(),2);return t&&console.log(n),n}static substringAfter(e,t,n){const a=n?e.lastIndexOf(t):e.indexOf(t);return a<0?e:e.substring(a+t.length)}static setTimeoutPromise(e,t){return new Promise((n=>setTimeout((()=>{const t=e?.();n(t)}),t)))}}n(8013);const i=e=>{return a.createElement(a.Fragment,null,a.createElement("a",{target:"_blank",href:(t=e.children,"https://gitlab.xops-online.com/foundation/foundation-jhipster-gwt/-/tree/master/"+t)},o.substringAfter(e.children,"/",!0)));var t}},2740:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>b,contentTitle:()=>w,default:()=>x,frontMatter:()=>T,metadata:()=>y,toc:()=>N});var a=n(8427),o=n(2784),i=n(876),s=n(6436),r=n(6277),l=n(9741),d=n(2244),p=n(8963),c=n(4126);const m="tabList_M0Dn",h="tabItem_ysIP";function u(e){const{lazy:t,block:n,defaultValue:i,values:s,groupId:l,className:u}=e,k=o.Children.map(e.children,(e=>{if((0,o.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),g=s??k.map((e=>{let{props:{value:t,label:n,attributes:a}}=e;return{value:t,label:n,attributes:a}})),f=(0,d.l)(g,((e,t)=>e.value===t.value));if(f.length>0)throw new Error(`Docusaurus error: Duplicate values "${f.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const T=null===i?i:i??k.find((e=>e.props.default))?.props.value??k[0].props.value;if(null!==T&&!g.some((e=>e.value===T)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${T}" but none of its children has the corresponding value. Available values are: ${g.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:w,setTabGroupChoices:y}=(0,p.U)(),[b,N]=(0,o.useState)(T),v=[],{blockElementScrollPositionUntilNextRender:x}=(0,c.o5)();if(null!=l){const e=w[l];null!=e&&e!==b&&g.some((t=>t.value===e))&&N(e)}const D=e=>{const t=e.currentTarget,n=v.indexOf(t),a=g[n].value;a!==b&&(x(t),N(a),null!=l&&y(l,String(a)))},C=e=>{let t=null;switch(e.key){case"ArrowRight":{const n=v.indexOf(e.currentTarget)+1;t=v[n]??v[0];break}case"ArrowLeft":{const n=v.indexOf(e.currentTarget)-1;t=v[n]??v[v.length-1];break}}t?.focus()};return o.createElement("div",{className:(0,r.Z)("tabs-container",m)},o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":n},u)},g.map((e=>{let{value:t,label:n,attributes:i}=e;return o.createElement("li",(0,a.Z)({role:"tab",tabIndex:b===t?0:-1,"aria-selected":b===t,key:t,ref:e=>v.push(e),onKeyDown:C,onFocus:D,onClick:D},i,{className:(0,r.Z)("tabs__item",h,i?.className,{"tabs__item--active":b===t})}),n??t)}))),t?(0,o.cloneElement)(k.filter((e=>e.props.value===b))[0],{className:"margin-top--md"}):o.createElement("div",{className:"margin-top--md"},k.map(((e,t)=>(0,o.cloneElement)(e,{key:t,hidden:e.props.value!==b})))))}function k(e){const t=(0,l.Z)();return o.createElement(u,(0,a.Z)({key:String(t)},e))}const g="tabItem_OMyP";function f(e){let{children:t,hidden:n,className:a}=e;return o.createElement("div",{role:"tabpanel",className:(0,r.Z)(g,a),hidden:n},t)}const T={description:"The recommended workflow for using Tests Are Demo",sidebar_position:20},w="Tutorial",y={unversionedId:"tests-are-demo/tutorial",id:"tests-are-demo/tutorial",title:"Tutorial",description:"The recommended workflow for using Tests Are Demo",source:"@site/docs/tests-are-demo/tutorial.md",sourceDirName:"tests-are-demo",slug:"/tests-are-demo/tutorial",permalink:"/site/docs/tests-are-demo/tutorial",draft:!1,editUrl:"https://gitlab.xops-online.com/foundation/foundation-jhipster-gwt/-/blob/master/foundation-react/packages/site/docs/tests-are-demo/tutorial.md",tags:[],version:"current",sidebarPosition:20,frontMatter:{description:"The recommended workflow for using Tests Are Demo",sidebar_position:20},sidebar:"tutorialSidebar",previous:{title:"Demo",permalink:"/site/docs/tests-are-demo/demo"},next:{title:'"Cheating", a reasonable compromise for hard to test cases',permalink:"/site/docs/tests-are-demo/cheat"}},b={},N=[{value:"Demo project",id:"demo-project",level:2},{value:"Create and run an empty scenario (test)",id:"create-and-run-an-empty-scenario-test",level:2},{value:"Create ...TestsAreDemo.tsx",id:"create-testsaredemotsx",level:3},{value:"Add (register) ...TestsAreDemo.tsx",id:"add-register-testsaredemotsx",level:3},{value:"Run",id:"run",level:3},{value:"Define the scenarios",id:"define-the-scenarios",level:2},{value:"Implement the first scenario",id:"implement-the-first-scenario",level:2},{value:"BDD style",id:"bdd-style",level:3},{value:"Flow: select, perform action, select, verify result",id:"flow-select-perform-action-select-verify-result",level:3},{value:"Add <code>data-testid</code> (if not existing)",id:"add-data-testid-if-not-existing",level:3},{value:"Select DOM element + perform action (copy/paste/adapt code snippet)",id:"select-dom-element--perform-action-copypasteadapt-code-snippet",level:3},{value:"Run. The &quot;demo&quot; mode works by intercepting function calls",id:"run-the-demo-mode-works-by-intercepting-function-calls",level:3},{value:"Select DOM element + verify (again, via snippet)",id:"select-dom-element--verify-again-via-snippet",level:3},{value:"Repeat until scenario is finished",id:"repeat-until-scenario-is-finished",level:3},{value:"Polish the demo for the end user",id:"polish-the-demo-for-the-end-user",level:3},{value:"Tips for implementing the remaining scenarios",id:"tips-for-implementing-the-remaining-scenarios",level:2},{value:"Linking scenarios",id:"linking-scenarios",level:3}],v={toc:N};function x(e){let{components:t,...o}=e;return(0,i.kt)("wrapper",(0,a.Z)({},v,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"tutorial"},"Tutorial"),(0,i.kt)("h2",{id:"demo-project"},"Demo project"),(0,i.kt)("p",null,"For this tutorial, we developed:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)(s.lj,{mdxType:"GitLink"},"foundation-react/packages/tests-are-demo/src/app/todos/Todos.tsx"),", a component that is managing things to do. Quite a classical pattern for demo apps \ud83d\ude42."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)(s.lj,{mdxType:"GitLink"},"foundation-react/packages/tests-are-demo/src/app/todos/TodosTestsAreDemo.tsx"),", which contains the corresponding tests, using the Tests Are Demo library.")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Todos.tsx")," looks like this:"),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(950).Z,width:"760",height:"611"})),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"TodosTestsAreDemo.tsx"),' (rather the "demo" part from TestsAre',(0,i.kt)("strong",{parentName:"p"},"Demo"),") looks like this:"),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(1460).Z,width:"804",height:"872"})),(0,i.kt)("h2",{id:"create-and-run-an-empty-scenario-test"},"Create and run an empty scenario (test)"),(0,i.kt)("h3",{id:"create-testsaredemotsx"},"Create ...TestsAreDemo.tsx"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="TodosTestsAreDemo.tsx"',title:'"TodosTestsAreDemo.tsx"'},'import { render } from "@famiprog-foundation/tests-are-demo";\nimport { tad } from "@famiprog-foundation/tests-are-demo";\n\nexport class TodosTestsAreDemo {\n\n    async before() {\n        render(<Todos />);\n        await tad.waitForCommunicationFinished();\n    }\n\n    @Scenario("Hello world")\n    async helloWorld() {\n        console.log("Hello world");\n    }\n}\n')),(0,i.kt)("admonition",{title:"Naming convention",type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"For file ",(0,i.kt)("inlineCode",{parentName:"p"},"MyComponent.tsx"),","),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"containing: ",(0,i.kt)("inlineCode",{parentName:"li"},"class MyComponent { ... }")),(0,i.kt)("li",{parentName:"ul"},"or: ",(0,i.kt)("inlineCode",{parentName:"li"},"export const MyComponent = (...) => { ... }")),(0,i.kt)("li",{parentName:"ul"},"and: maybe other secondary/internal components")),(0,i.kt)("p",{parentName:"admonition"},"=> ",(0,i.kt)("inlineCode",{parentName:"p"},"MyComponentTestsAreDemo.tsx"),".")),(0,i.kt)("admonition",{title:"temp",type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"We currently use the ",(0,i.kt)("inlineCode",{parentName:"p"},"render()")," exported by Tests Are Demo. We will find a way to let people use the original ",(0,i.kt)("inlineCode",{parentName:"p"},"render()"),", or one customized by themselves.")),(0,i.kt)("h3",{id:"add-register-testsaredemotsx"},"Add (register) ...TestsAreDemo.tsx"),(0,i.kt)("p",null,"Let the lib know about it, in ",(0,i.kt)(s.lj,{mdxType:"GitLink"},"foundation-react/packages/tests-are-demo/src/app/appTests.ts"),". E.g.:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="appTests.ts"',title:'"appTests.ts"'},"tad.addTests(\n    // EmployeeDashboardTestsAreDemo,\n    // EmployeeDashboardNoDecoratorsTestsAreDemo,\n    TodosTestsAreDemo\n);\n")),(0,i.kt)("admonition",{title:"Temp",type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"The UI doesn't allow yet selecting only one test. Comment the other tests, while working on ",(0,i.kt)("inlineCode",{parentName:"p"},"TodosTestsAreDemo"),". Don't forget to uncomment before commit.")),(0,i.kt)("h3",{id:"run"},"Run"),(0,i.kt)("p",null,"Go to your usual URL, e.g. ",(0,i.kt)("a",{parentName:"p",href:"http://localhost:3000?TestsAreDemo"},"http://localhost:3000?TestsAreDemo"),". Notice the ",(0,i.kt)("inlineCode",{parentName:"p"},"?TestsAreDemo"),". The ",(0,i.kt)("inlineCode",{parentName:"p"},"Todos")," component should render, and you should see in the console ",(0,i.kt)("em",{parentName:"p"},"Hello world")," printed."),(0,i.kt)("h2",{id:"define-the-scenarios"},"Define the scenarios"),(0,i.kt)("p",null,"A very good intellectual exercise is to define the scenarios that we want to implement, ",(0,i.kt)("strong",{parentName:"p"},"before")," doing the actual implementation. This adds structure to our thinking, and defines clearly our development road map."),(0,i.kt)("p",null,"At this stage, the scenarios are empty functions. A scenario == a test == a feature."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},'We noticed in practice that this technique: "think about the scenarios before writing the code" has as side effect the creation of a mental structure of the code. This may also include quite soon, the identification of the sub components to use. E.g. check / uncheck a Todo => checkboxes => we need a renderer for each Todo => let\'s name it ',(0,i.kt)("inlineCode",{parentName:"p"},"TodoItem"),".")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="TodosTestsAreDemo.tsx"',title:'"TodosTestsAreDemo.tsx"'},'export class TodosTestsAreDemo {\n    ...\n    @Comment("Todos (func comp)")\n    @Scenario("SCREEN Todos")\n    async screenTodos() {\n    }\n\n    @Scenario("WHEN click on Add, THEN the form opens")\n    async whenAddThenForm() {\n    }\n\n    ...\n    \n    // highlight-start\n    @Comment("TodoItem (func comp)")\n    @Scenario("WHEN click on checkbox or label, THEN toggle \'done\'")\n    async whenCheckbox() {\n    }\n    // highlight-end\n    \n    ...\n    \n    @Scenario("WHEN click on DELETE, THEN confirm, AND WHEN \'yes\', THEN the Todo is removed")\n    async whenDelete() {\n        // highlight-start\n        // DRAFT: click on del, verify alert open, click no, verify record still there, \n        // click again on del, click yes, verify the record is not there\n        // highlight-end\n    }\n}\n')),(0,i.kt)("p",null,"Explanation (",(0,i.kt)("em",{parentName:"p"},"click on tabs"),"):"),(0,i.kt)(k,{mdxType:"Tabs"},(0,i.kt)(f,{value:"scen",label:"@Scenario",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'export class TodosTestsAreDemo {\n    ...\n    @Comment("TodoItem (func comp)")\n    // highlight-start\n    @Scenario("WHEN click on checkbox or label, THEN toggle \'done\'")\n    async whenCheckbox() {\n    // highlight-end\n    }\n    ...\n}\n')),(0,i.kt)("p",null,"Adding the ",(0,i.kt)("inlineCode",{parentName:"p"},"@Scenario"),' annotation, makes the function being a "runnable test". It\'s the equivalent of:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'    it("WHEN click ...", () => { ... } )\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("em",{parentName:"p"},"title")," of the scenario (i.e. the ",(0,i.kt)("inlineCode",{parentName:"p"},"...")," from ",(0,i.kt)("inlineCode",{parentName:"p"},"@Scenario(...)"),") uses the ",(0,i.kt)("a",{parentName:"p",href:"scenarios-bdd-syntax"},'BDD "syntax"'),". The ",(0,i.kt)("em",{parentName:"p"},"function name")," is kind of abbreviation (but very short) of the scenario title.")),(0,i.kt)(f,{value:"draft",label:"Draft content (for some scenarios)",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"export class TodosTestsAreDemo {\n\n    ...\n\n    @Scenario(\"WHEN click on DELETE, THEN confirm, AND WHEN 'yes', THEN the Todo is removed\")\n    async whenDelete() {\n        // highlight-start\n        // DRAFT: click on del, verify alert open, click no, verify record still there, \n        // click again on del, click yes, verify the record is not there\n        // highlight-end\n    }\n\n    ...\n}\n")),(0,i.kt)("p",null,"For a lot of scenarios, the title (almost) fully describes the feature. But there are scenarios that contain\nsmall (and important) details. In this case, we write them down in a comment/draft, to avoid forgetting them. Once we do the\nimplementation + test, we'll delete this comment/draft, because the small (and important) details will be visible in the test."),(0,i.kt)("p",null,"Let's look at the example above. We have a confirmation/alert of type \"Do you really want to delete?\". It's obvious that if we click on no,\nnothing should happen, and the alert should close. So we ",(0,i.kt)("strong",{parentName:"p"},"don't want to pollute")," the scenario title with such a detail. But ",(0,i.kt)("strong",{parentName:"p"},"testing")," (and implementing)\nthe detail is important. "),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"One would be amazed how often we saw regressions related to (more or less) similar things. And believe us, an user will get really mad if e.g. he/she spends say 15 minutes\nin an editor, and then hits by mistake ",(0,i.kt)("inlineCode",{parentName:"p"},"F5")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"Back"),', and the dev forgot to implement a "leave page" handler + alert.'))),(0,i.kt)(f,{value:"comment",label:"@Comment",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'export class TodosTestsAreDemo {\n\n    ...\n    \n    // highlight-next-line\n    @Comment("Todos (func comp)")\n    @Scenario("SCREEN Todos")\n    async screenTodos() {\n    }\n\n    ...\n    \n    // highlight-next-line\n    @Comment("TodoItem (func comp)")\n    @Scenario("WHEN click on checkbox or label, THEN toggle \'done\'")\n    async whenCheckbox() {\n    }\n\n    ...\n}\n')),(0,i.kt)("p",null,"Use ",(0,i.kt)("inlineCode",{parentName:"p"},"@Comment(...)")," for comments that you want to ",(0,i.kt)("strong",{parentName:"p"},"see in the UI"),". For example we used them here to kind of group the scenarios per component. Don't forget that JS supports multi line comments w/ backticks: ",(0,i.kt)("inlineCode",{parentName:"p"},"`...`"),". "),(0,i.kt)("p",null,"One of the next pages ",(0,i.kt)("strong",{parentName:"p"},"[TODO: add the link when we add the page]"),' discusses the "strategic" importance of this annotation, especially during the transition (within an existing project) between the "old" mode and the "new" / Tests Are Demo mode.'))),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"implement-the-first-scenario"},"Implement the first scenario"),(0,i.kt)("h3",{id:"bdd-style"},"BDD style"),(0,i.kt)("p",null,"We like ",(0,i.kt)("strong",{parentName:"p"},"BDD")," (behavior driven development) which is a type of TDD (test driven development) or TFD (test first development). BDD and the ",(0,i.kt)("span",{style:{color:"red"}},"RED"),"/",(0,i.kt)("span",{style:{color:"green"}},"GREEN")," practice (cf.  Cucumber doc) is quite good for developing server code. E.g.: we write all the tests first (skeleton + implementation), we run test #1 => it fails (it's ",(0,i.kt)("span",{style:{color:"red"}},"RED"),"), we implement, we run => test passes (it's ",(0,i.kt)("span",{style:{color:"green"}},"GREEN"),"). And we iterate w/ test #2, #3 and so on. When all is ",(0,i.kt)("span",{style:{color:"green"}},"GREEN")," => the job is done. "),(0,i.kt)("p",null,"However we find that:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"This approach is not reasonable for UI development. "),(0,i.kt)("li",{parentName:"ul"},"A good compromise is: the fact that we define the scenarios (only skeleton; no impl) before the code, and then for each scenario => we implement + test.")),(0,i.kt)("p",null,"Back to our tutorial: so the scenarios were defined, and now we take them one by one and we implement + test them, cf. below."),(0,i.kt)("p",null,'We\'ll focus on the "delete" scenario. The implementation is straight forward: a "Delete" button on each line/todo. On click => an alert asking for confirmation. On confirm => the corresponding element is removed from the list.'),(0,i.kt)("h3",{id:"flow-select-perform-action-select-verify-result"},"Flow: select, perform action, select, verify result"),(0,i.kt)("p",null,"A test is basically a repetition of these operations:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Step 1, ",(0,i.kt)("strong",{parentName:"li"},"select a DOM element"),". We use ",(0,i.kt)("a",{parentName:"li",href:"https://testing-library.com/docs/react-testing-library/intro"},"React Testing Library"),"."),(0,i.kt)("li",{parentName:"ul"},"Step 2, ",(0,i.kt)("strong",{parentName:"li"},"perform an action")," (on it). We use  ",(0,i.kt)("a",{parentName:"li",href:"https://testing-library.com/docs/user-event/intro"},"user-event")," (related to React Testing Library)."),(0,i.kt)("li",{parentName:"ul"},"Step 3, ",(0,i.kt)("strong",{parentName:"li"},"select another DOM element"),"."),(0,i.kt)("li",{parentName:"ul"},"Step 4, ",(0,i.kt)("strong",{parentName:"li"},"verify something")," (on it). ")),(0,i.kt)("p",null,"We use ",(0,i.kt)("a",{parentName:"p",href:"https://mochajs.org/"},"Mocha")," as the underlying framework. At the time of writing it's the only runner that has an implementation for the browser, which we need for the ",(0,i.kt)("em",{parentName:"p"},"demo")," part."),(0,i.kt)("p",null,"For the ",(0,i.kt)("em",{parentName:"p"},"demo"),' part, Tests Are Demo intercepts/wraps the 3 categories of functions (select DOM element, perform action, verify). When selecting a DOM element, Tests Are Demo captures/remembers it. When performing an action or verification, Tests Are Demo will show a spotlight and a popup (focused around the captured element) and will wait for the user clicking on "Next" step.'),(0,i.kt)("h3",{id:"add-data-testid-if-not-existing"},"Add ",(0,i.kt)("inlineCode",{parentName:"h3"},"data-testid")," (if not existing)"),(0,i.kt)("p",null,"There are multiple ways to select a DOM element. We recommend adding ",(0,i.kt)("inlineCode",{parentName:"p"},"data-testid"),"s to components, and use them as selection criteria."),(0,i.kt)("p",null,"React Testing Library currently recommends avoiding to (over)use the ",(0,i.kt)("inlineCode",{parentName:"p"},"data-testid")," attribute for selecting DOM elements. Our experience has taught us the contrary. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx",metastring:'title="Todos.tsx"',title:'"Todos.tsx"'},'export const todosTestids = createTestids("Todos", {\n    ...\n    // highlight-next-line\n    todoItem: "", todoItemCheckbox: "", todoItemCheckboxLabel: "",\n    ...\n    // TodoItem\n    // highlight-start\n    up: "", down: "", edit: "", delete: "",\n    deleteYes: "", deleteNo: "",\n    // highlight-end\n    ...\n});\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx",metastring:'title="Todos.tsx"',title:'"Todos.tsx"'},'const TodoItem = ({ todo, ...props }: TodoItemProps) => {\n    ...\n    // highlight-next-line\n    return (<Segment data-testid={todosTestids.todoItem + "_" + props.index} onDoubleClick={props.onEdit} ...>\n        ...\n        <div>\n            ...\n            // highlight-next-line\n            <Button data-testid={todosTestids.delete} onClick={() => setModalOpen(true)} basic icon="delete" color="red" content="Delete" />\n}\n')),(0,i.kt)("p",null,"At runtime, ",(0,i.kt)("inlineCode",{parentName:"p"},"todosTestids.delete")," == ",(0,i.kt)("inlineCode",{parentName:"p"},'"Todos_delete"'),". We use ",(0,i.kt)("inlineCode",{parentName:"p"},"todosTestids.delete"),", to have type checking and autocomplete. This way:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"we cannot misspell (e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"Todos_delete")," vs ",(0,i.kt)("inlineCode",{parentName:"li"},"Todos_delte"),"); misspelling would be eventually discovered anyway (because the test wouldn't pass), but w/ additional cost;"),(0,i.kt)("li",{parentName:"ul"},"we have traceability from the implementation <-> test (via CTRL + click). This is a helpful feature \ud83d\ude09.")),(0,i.kt)("admonition",{title:"For uniformity",type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Always keep ",(0,i.kt)("inlineCode",{parentName:"p"},"data-testid")," as the first property of a component. And BTW, did you notice that, for ",(0,i.kt)("inlineCode",{parentName:"p"},"todosTestids"),", we grouped (+ commented) the testids by component? And arranged the fields in sort of a space saving manner?")),(0,i.kt)("h3",{id:"select-dom-element--perform-action-copypasteadapt-code-snippet"},"Select DOM element + perform action (copy/paste/adapt code snippet)"),(0,i.kt)("p",null,"Now that the ",(0,i.kt)("inlineCode",{parentName:"p"},"data-testid"),"s are there, we need to write code that uses them. Tests Are Demo UI has a handy helper feature: the ",(0,i.kt)("inlineCode",{parentName:"p"},"Inspect testid")," button:"),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(8398).Z,width:"1382",height:"260"}),"  "),(0,i.kt)("p",null,"And then:"),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(7476).Z,width:"1255",height:"219"}),"  "),(0,i.kt)("p",null,"The snippet is in the clipboard and we paste it within the test."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="TodosTestsAreDemo.tsx"',title:'"TodosTestsAreDemo.tsx"'},'@Scenario("WHEN click on DELETE, THEN confirm, AND WHEN \'yes\', THEN the Todo is removed")\nasync whenDelete() {\n    let item = tad.screenCapturing.getByTestId(testids.todoItem + "_0");\n    await tad.userEventWaitable.click(tad.withinCapturing(item).getByTestId(testids.delete));\n')),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},'In this case, we used the pasted the code snippet "as is". No modifications/adaptations were needed, which is rather rare. Normally a bit of adaptation is needed to the pasted snippet. So please consider this copy/paste workflow as an aid, not a bullet proof mechanism!')),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"1/ in ",(0,i.kt)("inlineCode",{parentName:"p"},"Todos.tsx")," we have ",(0,i.kt)("inlineCode",{parentName:"p"},"todosTestids"),". 2/ here, in ",(0,i.kt)("inlineCode",{parentName:"p"},"TodosTestsAreDemo.tsx")," we have ",(0,i.kt)("inlineCode",{parentName:"p"},"testids"),". Hence we rename the import:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="TestsAreDemo.tsx"',title:'"TestsAreDemo.tsx"'},'import { ..., todosTestids as testids } from "./Todos";\n')),(0,i.kt)("p",{parentName:"admonition"},'1/ is so, so that we don\'t pollute the content assist (e.g. type "testids" => tons of proposals). 2/ is so, for easier snippet genaration.')),(0,i.kt)("h3",{id:"run-the-demo-mode-works-by-intercepting-function-calls"},'Run. The "demo" mode works by intercepting function calls'),(0,i.kt)("p",null,"After running the test (w/ the option ",(0,i.kt)("strong",{parentName:"p"},'"Step by step" = ON')," ","[default]","), we have this result:"),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(5805).Z,width:"801",height:"210"}),"  "),(0,i.kt)("p",null,'Let\'s explain what is happening. We compare Tests Are Demo code with "plain" React Testing Library code. For the selection of the DOM element:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'// 1/ Tests Are Demo code\nlet item = tad.screenCapturing.getByTestId(testids.todoItem + "_0");\n// 2/ normal React Testing Library code\nlet item = screen.getByTestId(testids.todoItem + "_0");\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"tad.screenCapturing().getByTestId()")," (from 1/) is a wrapper around ",(0,i.kt)("inlineCode",{parentName:"p"},"screen.getByTestId()"),' (from 2/). 1/ calls 2/. All the wrapped functions behave identically, except that they capture and remember the DOM element that was selected. Hence the suffix "Capturing". We grouped all TAD functions into ',(0,i.kt)("inlineCode",{parentName:"p"},"tad"),', to make our lib "content assist" friendly. I.e. type ',(0,i.kt)("inlineCode",{parentName:"p"},"tad.")," and see what are the available functions, w/o needing to go to the doc."),(0,i.kt)("p",null,"To perform an action, ",(0,i.kt)("inlineCode",{parentName:"p"},"tad.userEventWaitable()")," (from 3/) is also a wrapper:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"// 3/ Tests Are Demo code\nawait tad.userEventWaitable.click(tad.withinCapturing(item).getByTestId(testids.delete));\n// 4/ normal React Testing Library code\nuserEvent.click(within(item).getByTestId(testids.delete));\n")),(0,i.kt)("p",null,"3/ captures the action that will be performed (the function name, e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"click"),'), it displays a "spotlight" around the last captured element (e.g. the "Delete" button), it shows a popup saying "Will perform click", and then waits. When the user does something, e.g. click on "Next", then 4/ is called, and the test continues. Hence the suffix "Waitable" and the function being async. We chose this suffix so that people can remember that they also need to use ',(0,i.kt)("inlineCode",{parentName:"p"},"await"),". "),(0,i.kt)("h3",{id:"select-dom-element--verify-again-via-snippet"},"Select DOM element + verify (again, via snippet)"),(0,i.kt)("p",null,"We apply the same process to obtain a snippet for verification:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="TodosTestsAreDemo.tsx"',title:'"TodosTestsAreDemo.tsx"'},'@Scenario("WHEN click on DELETE, THEN confirm, AND WHEN \'yes\', THEN the Todo is removed")\nasync whenDelete() {\n    let item = tad.screenCapturing.getByTestId(testids.todoItem + "_0");\n    await tad.userEventWaitable.click(tad.withinCapturing(item).getByTestId(testids.delete));\n\n    // highlight-start\n    await tad.userEventWaitable.click(tad.screenCapturing.getByTestId(testids.deleteNo));\n    tad.cc("The Todo wasn\'t deleted");\n    await tad.assertWaitable.equal(tad.withinCapturing(item).getByTestId(testids.todoItemCheckboxLabel).textContent, someTodos[0].text);\n    // highlight-end\n')),(0,i.kt)("p",null,"We have the result:"),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(7631).Z,width:"441",height:"275"}),"  "),(0,i.kt)("p",null,'We added a new "perform action" line, simulating clicking on "No" (in the alert that\'s opened after clicking on "Delete"). And then a ',(0,i.kt)("strong",{parentName:"p"},'"verification"')," line. Here we have the same interception mechanism, but applied this time to ",(0,i.kt)("inlineCode",{parentName:"p"},"assert")," from ",(0,i.kt)("a",{parentName:"p",href:"https://www.chaijs.com/"},"Chai Assertion Library"),". "),(0,i.kt)("p",null,"If the first lines were quite readable, this particular verification line is not straight forward. Meaning that just by reading it, it's not clear what we want to achieve actually. Hence the need for a ",(0,i.kt)("strong",{parentName:"p"},"comment"),", i.e. ",(0,i.kt)("inlineCode",{parentName:"p"},"tad.cc()")," which is an alias for ",(0,i.kt)("inlineCode",{parentName:"p"},"tad.currentComment()"),". We use comments this way (instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"// this way"),"), so that they can be displayed in the UI."),(0,i.kt)("h3",{id:"repeat-until-scenario-is-finished"},"Repeat until scenario is finished"),(0,i.kt)("p",null,"To finish the test/scenario, we repeat the steps above. Let's recap them:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"add ",(0,i.kt)("inlineCode",{parentName:"li"},"data-testid")," (if needed),"),(0,i.kt)("li",{parentName:"ul"},"copy/paste/adapt code for ",(0,i.kt)("strong",{parentName:"li"},"performing actions"),","),(0,i.kt)("li",{parentName:"ul"},"copy/paste/adapt code for ",(0,i.kt)("strong",{parentName:"li"},"verification"),".")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},'We recommend keeping "Auto run after page load" = true (default). Probably you are running Tests Are Demo inside a toolchain (such as ',(0,i.kt)("a",{parentName:"p",href:"https://vitejs.dev/"},"Vite")," or ",(0,i.kt)("a",{parentName:"p",href:"https://create-react-app.dev/"},"Create React App"),") that has auto-refresh or hot module reload (HMR) enabled. Hence when you save, the browser will refresh and the test will run again. This is convenient.")),(0,i.kt)("h3",{id:"polish-the-demo-for-the-end-user"},"Polish the demo for the end user"),(0,i.kt)("p",null,'The "slide show"/visual test steps are practically a demo of our component or app. They are meaningful for a dev that looks at the demo. And they are also (almost) meaningful for an end user. However, when presenting the demo to and user, a bit of additional polishing may be needed.'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="TodosTest.tsx"',title:'"TodosTest.tsx"'},'@Scenario("WHEN click on DELETE, THEN confirm, AND WHEN \'yes\', THEN the Todo is removed")\nasync whenDelete() {\n    // highlight-next-line\n    tad.cc("A Todo may be deleted");\n\n    // highlight-next-line\n    tad.demoForEndUserHide();\n    let item = tad.screenCapturing.getByTestId(testids.todoItem + "_0");\n    await tad.userEventWaitable.click(tad.withinCapturing(item).getByTestId(testids.delete));\n\n    await tad.userEventWaitable.click(tad.screenCapturing.getByTestId(testids.deleteNo));\n    tad.cc("The Todo wasn\'t deleted");\n    await tad.assertWaitable.equal(tad.withinCapturing(item).getByTestId(testids.todoItemCheckboxLabel).textContent, someTodos[0].text);\n    // highlight-next-line\n    tad.demoForEndUserShow();\n\n    await tad.userEventWaitable.click(tad.withinCapturing(item).getByTestId(testids.delete));\n    await tad.userEventWaitable.click(tad.screenCapturing.getByTestId(testids.deleteYes));\n    // highlight-next-line\n    tad.cc("The Todo was deleted. So the second element (index 1) became element the first element (index 0)");\n    item = tad.screenCapturing.getByTestId(testids.todoItem + "_0");\n    await tad.assertWaitable.include(tad.withinCapturing(item).getByTestId(testids.todoItemCheckboxLabel).textContent, someTodos[1].text); // include instead of equals, because we appended something in a step above\n}\n')),(0,i.kt)("p",null,"Some ways to polish:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"by adding additional comments. Such as providing some context or intro at the beginning of the scenario, or adding text to mark the transition from the previous scenario."),(0,i.kt)("li",{parentName:"ul"},'by hiding steps which would bore the end user. E.g. here we don\'t want to show that we test clicking on the "No" button of the "Do you want to delete?" dialog.'),(0,i.kt)("li",{parentName:"ul"},'by rephrasing a comment using a language suitable for the end user. E.g. here we used both "first element" (in "user language") and "index 0" (in dev language).')),(0,i.kt)("h2",{id:"tips-for-implementing-the-remaining-scenarios"},"Tips for implementing the remaining scenarios"),(0,i.kt)("admonition",{title:"temp",type:"caution"},(0,i.kt)("p",{parentName:"admonition"},'We already explained that the UI doesn\'t allow selecting a "current" file. Hence during dev, we need to comment the other files.'),(0,i.kt)("p",{parentName:"admonition"},"Regarding individual scenarios (tests), we have the ",(0,i.kt)("inlineCode",{parentName:"p"},"@Only")," annotation. If we annotate a certain function with it, in principle, only that scenario will run. This is inspired from Mocha's ",(0,i.kt)("inlineCode",{parentName:"p"},"it.only(...)"),".")),(0,i.kt)("h3",{id:"linking-scenarios"},"Linking scenarios"),(0,i.kt)("p",null,"Let's look at this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="TodosTestsAreDemo.tsx"',title:'"TodosTestsAreDemo.tsx"'},'@Scenario("WHEN click on Add, THEN the form opens")\n@ScenarioOptions({ linkWithNextScenario: true })\nasync whenAddThenForm() {\n    tad.cc("Let\'s add a new Todo");\n    await tad.userEventWaitable.click(tad.screenCapturing.getByTestId(testids.add));\n}\n\n@Scenario("FORM for a Todo; test #1")\nasync formTodo1() {\n    tad.cc("Please observe that this text field is already focused. So you can directly start typing, w/o needing to click here first");\n    const textbox = tad.withinCapturing(tad.screenCapturing.getByTestId(testids.inputText)).getByRole(\'textbox\');\n    ...\n')),(0,i.kt)("p",null,"Linking scenarios helps us write less code:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"whenAddThenForm()")," doesn't have a verification part. The verification is practically done in the next scenario. If the form wouldn't open, the next scenario would fail while finding ",(0,i.kt)("inlineCode",{parentName:"li"},"testids.inputText"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"formTodo1()")," doesn't have a part that opens the form. Because this is done by the previous scenario.")),(0,i.kt)("p",null,'The two scenarios are linked/dependent, and they "help" each other. And we wrote less code, compared to the case where the two scenarios are independent. Less code to achieve the same result is always good, but in particular in the "test business", where test clutter is a constant threat.'),(0,i.kt)("p",null,"When one scenario is ran individually (e.g. via ",(0,i.kt)("inlineCode",{parentName:"p"},"@Only")," or via UI), then the other is ran as well. Chaining more than 2 scenarios is also possible."))}x.isMDXComponent=!0},1460:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/anim-33b0f8dbbf4baf5127f85f483e40919f.gif"},5805:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/del-click-d682acfbbc970ba43142ad1f03679b41.png"},8398:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/inspect1-32edd4de97c7230dc4a1f62ae82abcbc.png"},7476:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/inspect2-cc522bf72c254864b6599424562ef35d.png"},950:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/todos-16317d6bf7316ff60eb768bc8f67ee0e.png"},7631:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/verify-not-deleted-8ed05663ea8ae42c3db53e158e5f3560.png"}}]);