[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "src/components/BackgroundLayer.js",
    "content": "import React, {Fragment} from 'react';\nimport PropTypes from 'prop-types';\nimport _ from 'lodash';\nimport {convertDateToMoment} from '../utils/timeUtils';\nimport {Marker} from './Marker';\nimport {HighlightedInterval} from './HighlightedInterval';\nimport moment from 'moment';\n\n/**\n * @extends React.Component<BackgroundLayer.propTypes>\n */\nexport class BackgroundLayer extends React.Component {\n  static propTypes = {\n    /**\n     * If `true`, it highlights the weekends.\n     *\n     * @type { boolean }\n     */\n    highlightWeekends: PropTypes.bool,\n\n    /**\n     * Custom class name for highlighting the weekends.\n     *\n     * NOTE: No need to provide this; because it has a default class. If a custom class is provided, `!important` should be used to override properties from the default class.\n     *\n     * @type { string }\n     */\n    highlightWeekendsClassName: PropTypes.string,\n\n    /**\n     * Custom style for highlighting the weekends.\n     *\n     * NOTE: No need to provide this; because it has a default class.\n     *\n     * @type { object }\n     */\n    highlightWeekendsStyle: PropTypes.object,\n\n    /**\n     * If `true`, it draws a marker (vertical line) that indicates the current time.\n     *\n     * @type { boolean }\n     */\n    nowMarker: PropTypes.bool,\n\n    /**\n     * Custom class name for now marker.\n     *\n     * NOTE: No need to provide this; because it has a default class. If a custom class is provided, `!important` should be used to override properties from the default class.\n     *\n     * @type { string }\n     */\n    nowMarkerClassName: PropTypes.string,\n\n    /**\n     * Custom style for now marker.\n     *\n     * NOTE: No need to provide this; because it has a default class.\n     *\n     * @type { object }\n     */\n    nowMarkerStyle: PropTypes.object,\n\n    /**\n     * If `true`, it draws vertical lines, according to the intervals defined by the bottom `Timebar`.\n     *\n     * @type { boolean }\n     */\n    verticalGrid: PropTypes.bool,\n\n    /**\n     * Custom class name for vertical grid.\n     *\n     * NOTE: No need to provide this; because it has a default class. If a custom class is provided, `!important` should be used to override properties from the default class.\n     *\n     * @type { string }\n     */\n    verticalGridClassName: PropTypes.string,\n\n    /**\n     * Custom style for vertical grid.\n     *\n     * NOTE: No need to provide this; because it has a default class.\n     *\n     * @type { object }\n     */\n    verticalGridStyle: PropTypes.object,\n\n    /**\n     * @type { Array.<JSX.Element> }\n     */\n    markers: PropTypes.arrayOf(PropTypes.object),\n\n    /**\n     * @type { Array.<JSX.Element> }\n     */\n    highlightedIntervals: PropTypes.arrayOf(PropTypes.object),\n\n    /**\n     * Internal (passed by parent). Start of the timeline display interval, as date (moment object).\n     *\n     * @type { object }\n     */\n    startDateTimeline: PropTypes.object,\n\n    /**\n     * Internal (passed by parent). End of the timeline display interval, as date (moment object).\n     *\n     * @type { object }\n     */\n    endDateTimeline: PropTypes.object,\n\n    /**\n     * Internal (passed by parent). The height of the background layer.\n     *\n     * @type { number }\n     */\n    height: PropTypes.number,\n\n    /**\n     * Internal (passed by parent). The position of the top edge of background layer.\n     *\n     * @type { number }\n     */\n    topOffset: PropTypes.number,\n\n    /**\n     * Internal (passed by parent). Total width of the timeline.\n     *\n     * @type { number }\n     */\n    width: PropTypes.number,\n\n    /**\n     * Internal (passed by parent). The position of the left edge of background layer.\n     *\n     * @type { number }\n     */\n    leftOffset: PropTypes.number,\n\n    /**\n     * Internal (passed by parent). The vertical lines of the grid are already calculated by `Timerbar`.\n     *\n     * @type { Array.<object>}\n     */\n    verticalGridLines: PropTypes.arrayOf(PropTypes.object)\n  };\n\n  static defaultProps = {\n    highlightWeekends: false,\n    highlightWeekendsClassName: undefined,\n    highlightWeekendsStyle: undefined,\n    nowMarker: false,\n    nowMarkerClassName: undefined,\n    nowMarkerStyle: undefined,\n    verticalGrid: false,\n    verticalGridClassName: undefined,\n    verticalGridStyle: undefined,\n    verticalGridLines: [],\n    markers: [],\n    highlightedIntervals: [],\n    height: undefined,\n    topOffset: undefined,\n    width: undefined,\n    leftOffset: undefined,\n    startDateTimeline: undefined,\n    endDateTimeline: undefined\n  };\n\n  constructor(props) {\n    super(props);\n    this.state = {verticalLines: [], shouldUpdate: false, weekends: []};\n    this.calculateHorizontalPosition = this.calculateHorizontalPosition.bind(this);\n  }\n\n  componentDidMount() {\n    this.calculateHighlightedWeekends();\n  }\n\n  componentDidUpdate(prevProps) {\n    if (\n      this.props.height !== prevProps.height ||\n      this.props.width !== prevProps.width ||\n      !this.props.startDateTimeline.isSame(prevProps.startDateTimeline) ||\n      !this.props.endDateTimeline.isSame(prevProps.endDateTimeline)\n    ) {\n      this.calculateHighlightedWeekends();\n      this.setState({shouldUpdate: true});\n      return;\n    }\n    if (this.state.shouldUpdate) {\n      this.setState({shouldUpdate: false});\n    }\n  }\n\n  /**\n   * It calculates the horizontal position (left and width in pixels) of an element from the time positions (start, end).\n   * @param { object | number } start\n   * @param { object | number } end\n   * @returns { object } left position and width in pixels\n   */\n  calculateHorizontalPosition(start, end) {\n    const intervalMillis = this.props.endDateTimeline.diff(this.props.startDateTimeline, 'milliseconds');\n    const pixelsPerMillis = (this.props.width - this.props.leftOffset) / intervalMillis;\n    const startAsMoment = convertDateToMoment(start);\n    const endAsMoment = convertDateToMoment(end);\n    if (endAsMoment.isBefore(this.props.startDateTimeline) || startAsMoment.isAfter(this.props.endDateTimeline)) {\n      return {};\n    }\n\n    let offset = startAsMoment.diff(this.props.startDateTimeline, 'milliseconds');\n    let duration = endAsMoment.diff(startAsMoment, 'milliseconds');\n    const left = this.props.leftOffset + offset * pixelsPerMillis;\n    let width = Math.round(duration * pixelsPerMillis);\n    return {left, width};\n  }\n\n  /**\n   * Calculates the weekend intervals for the timeline displayed interval (`startDateTimeline` - `endDateTimeline`).\n   */\n  calculateHighlightedWeekends() {\n    let weekends = [];\n    if (!this.props.highlightWeekends) {\n      return;\n    }\n\n    // get display interval start date; if it's sunday, substract a day\n    let startDate = this.props.startDateTimeline.clone();\n    if (startDate.weekday() == 0) {\n      startDate = startDate.subtract(1, 'days');\n    }\n\n    let weekendStartDate = startDate.startOf('isoWeek').day('saturday');\n    let weekendEndDate = null;\n    // compute all the weekends in the interval\n    while (weekendStartDate < this.props.endDateTimeline) {\n      weekendEndDate = weekendStartDate.clone().add(2, 'days');\n      weekends.push({\n        start: weekendStartDate,\n        end: weekendEndDate,\n        className: `rct9k-background-layer-highlight-weekends ${this.props.highlightWeekendsClassName}`\n      });\n\n      // go to the next weekend\n      weekendStartDate = weekendEndDate\n        .clone()\n        .startOf('isoWeek')\n        .day('saturday');\n    }\n    this.setState({weekends: weekends});\n  }\n\n  renderHighlightedWeekends() {\n    return (\n      <Fragment>\n        {this.props.highlightWeekends &&\n          this.state.weekends.map((weekend, index) => {\n            return (\n              <HighlightedInterval\n                key={index}\n                start={weekend.start}\n                end={weekend.end}\n                className={weekend.className}\n                style={this.props.highlightWeekendsStyle}\n                top={this.props.topOffset}\n                height={this.props.height}\n                shouldUpdate={this.state.shouldUpdate}\n                calculateHorizontalPosition={this.calculateHorizontalPosition}\n              />\n            );\n          })}\n      </Fragment>\n    );\n  }\n\n  renderCustomComponents(components) {\n    return (\n      <Fragment>\n        {components.map((component, index) => {\n          return React.cloneElement(component, {\n            key: index,\n            height: this.props.height,\n            top: this.props.topOffset,\n            shouldUpdate: this.state.shouldUpdate,\n            calculateHorizontalPosition: this.calculateHorizontalPosition\n          });\n        })}\n      </Fragment>\n    );\n  }\n\n  renderVerticalGrid() {\n    const {verticalGrid, topOffset, height, leftOffset, width, verticalGridLines, verticalGridClassName} = this.props;\n    return (\n      <Fragment>\n        {verticalGrid && verticalGridLines && (\n          <div\n            className=\"rct9k-background-layer-vertical-grid\"\n            style={{top: topOffset, height: height, left: leftOffset, width: width - leftOffset}}>\n            {verticalGridLines.map((verticalLine, index) => {\n              return (\n                <span\n                  key={index}\n                  className={`rct9k-background-layer-vertical-line ${verticalGridClassName}`}\n                  style={{...this.props.verticalGridStyle, width: verticalLine.size}}\n                />\n              );\n            })}\n          </div>\n        )}\n      </Fragment>\n    );\n  }\n\n  renderNowMarker() {\n    const {nowMarker, height, topOffset, nowMarkerClassName} = this.props;\n    const currentDate = moment();\n    const overlappsDisplayedInterval =\n      this.props.startDateTimeline.isSameOrBefore(currentDate) && this.props.endDateTimeline.isSameOrAfter(currentDate);\n    return (\n      <Fragment>\n        {nowMarker && overlappsDisplayedInterval && (\n          <Marker\n            date={currentDate}\n            top={0}\n            height={height + topOffset}\n            shouldUpdate={this.state.shouldUpdate}\n            calculateHorizontalPosition={this.calculateHorizontalPosition}\n            className={`rct9k-background-layer-now-marker ${nowMarkerClassName}`}\n            style={this.props.nowMarkerStyle}\n          />\n        )}\n      </Fragment>\n    );\n  }\n\n  render() {\n    return (\n      <Fragment>\n        {this.renderHighlightedWeekends()}\n        {this.renderCustomComponents(this.props.highlightedIntervals)}\n        {this.renderNowMarker()}\n        {this.renderCustomComponents(this.props.markers)}\n        {this.renderVerticalGrid()}\n      </Fragment>\n    );\n  }\n}\n",
    "static": true,
    "longname": "/home/poweruser/git/react-timeline-10000/src/components/BackgroundLayer.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "class",
    "name": "BackgroundLayer",
    "memberof": "src/components/BackgroundLayer.js",
    "static": true,
    "longname": "src/components/BackgroundLayer.js~BackgroundLayer",
    "access": "public",
    "export": true,
    "importPath": "@crispico/react-timeline-10000/src/components/BackgroundLayer.js",
    "importStyle": "{BackgroundLayer}",
    "description": "",
    "lineNumber": 12,
    "interface": false,
    "extends": [
      "*"
    ]
  },
  {
    "__docId__": 50,
    "kind": "member",
    "name": "propTypes",
    "memberof": "src/components/BackgroundLayer.js~BackgroundLayer",
    "static": true,
    "longname": "src/components/BackgroundLayer.js~BackgroundLayer.propTypes",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 51,
    "kind": "member",
    "name": "defaultProps",
    "memberof": "src/components/BackgroundLayer.js~BackgroundLayer",
    "static": true,
    "longname": "src/components/BackgroundLayer.js~BackgroundLayer.defaultProps",
    "access": "public",
    "description": null,
    "lineNumber": 149,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 52,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/components/BackgroundLayer.js~BackgroundLayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/BackgroundLayer.js~BackgroundLayer#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 170,
    "undocument": true
  },
  {
    "__docId__": 53,
    "kind": "member",
    "name": "state",
    "memberof": "src/components/BackgroundLayer.js~BackgroundLayer",
    "static": false,
    "longname": "src/components/BackgroundLayer.js~BackgroundLayer#state",
    "access": "public",
    "description": null,
    "lineNumber": 172,
    "undocument": true,
    "type": {
      "types": [
        "{\"verticalLines\": *, \"shouldUpdate\": *, \"weekends\": *}"
      ]
    }
  },
  {
    "__docId__": 55,
    "kind": "method",
    "name": "componentDidMount",
    "memberof": "src/components/BackgroundLayer.js~BackgroundLayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/BackgroundLayer.js~BackgroundLayer#componentDidMount",
    "access": "public",
    "description": null,
    "lineNumber": 176,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 56,
    "kind": "method",
    "name": "componentDidUpdate",
    "memberof": "src/components/BackgroundLayer.js~BackgroundLayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/BackgroundLayer.js~BackgroundLayer#componentDidUpdate",
    "access": "public",
    "description": null,
    "lineNumber": 180,
    "undocument": true,
    "params": [
      {
        "name": "prevProps",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 57,
    "kind": "method",
    "name": "calculateHorizontalPosition",
    "memberof": "src/components/BackgroundLayer.js~BackgroundLayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/BackgroundLayer.js~BackgroundLayer#calculateHorizontalPosition",
    "access": "public",
    "description": "It calculates the horizontal position (left and width in pixels) of an element from the time positions (start, end).",
    "lineNumber": 202,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ object } left position and width in pixels"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          " object ",
          " number "
        ],
        "spread": false,
        "optional": false,
        "name": "start",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          " object ",
          " number "
        ],
        "spread": false,
        "optional": false,
        "name": "end",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        " object "
      ],
      "spread": false,
      "description": "left position and width in pixels"
    }
  },
  {
    "__docId__": 58,
    "kind": "method",
    "name": "calculateHighlightedWeekends",
    "memberof": "src/components/BackgroundLayer.js~BackgroundLayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/BackgroundLayer.js~BackgroundLayer#calculateHighlightedWeekends",
    "access": "public",
    "description": "Calculates the weekend intervals for the timeline displayed interval (`startDateTimeline` - `endDateTimeline`).",
    "lineNumber": 221,
    "params": [],
    "return": null
  },
  {
    "__docId__": 59,
    "kind": "method",
    "name": "renderHighlightedWeekends",
    "memberof": "src/components/BackgroundLayer.js~BackgroundLayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/BackgroundLayer.js~BackgroundLayer#renderHighlightedWeekends",
    "access": "public",
    "description": null,
    "lineNumber": 253,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 60,
    "kind": "method",
    "name": "renderCustomComponents",
    "memberof": "src/components/BackgroundLayer.js~BackgroundLayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/BackgroundLayer.js~BackgroundLayer#renderCustomComponents",
    "access": "public",
    "description": null,
    "lineNumber": 276,
    "undocument": true,
    "params": [
      {
        "name": "components",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 61,
    "kind": "method",
    "name": "renderVerticalGrid",
    "memberof": "src/components/BackgroundLayer.js~BackgroundLayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/BackgroundLayer.js~BackgroundLayer#renderVerticalGrid",
    "access": "public",
    "description": null,
    "lineNumber": 292,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 62,
    "kind": "method",
    "name": "renderNowMarker",
    "memberof": "src/components/BackgroundLayer.js~BackgroundLayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/BackgroundLayer.js~BackgroundLayer#renderNowMarker",
    "access": "public",
    "description": null,
    "lineNumber": 315,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 63,
    "kind": "method",
    "name": "render",
    "memberof": "src/components/BackgroundLayer.js~BackgroundLayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/BackgroundLayer.js~BackgroundLayer#render",
    "access": "public",
    "description": null,
    "lineNumber": 337,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 64,
    "kind": "file",
    "name": "src/components/ColumnRenderer.js",
    "content": "import React from 'react';\nimport {Column} from '../index';\n\n/**\n * Renderer for column header.\n * @param { object } props - Component props\n * @param { Column } props.column - The properties of the column\n * @param { string } props.column.headerLabel - The header's label\n */\nexport class ColumnHeaderRenderer extends React.Component {\n  /**\n   * Returns the label of the header.\n   * @returns { string }\n   */\n  getLabel() {\n    return this.props.column ? this.props.column.headerLabel : '';\n  }\n\n  render() {\n    return <span>{this.getLabel()}</span>;\n  }\n}\n",
    "static": true,
    "longname": "/home/poweruser/git/react-timeline-10000/src/components/ColumnRenderer.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 65,
    "kind": "class",
    "name": "ColumnHeaderRenderer",
    "memberof": "src/components/ColumnRenderer.js",
    "static": true,
    "longname": "src/components/ColumnRenderer.js~ColumnHeaderRenderer",
    "access": "public",
    "export": true,
    "importPath": "@crispico/react-timeline-10000/src/components/ColumnRenderer.js",
    "importStyle": "{ColumnHeaderRenderer}",
    "description": "Renderer for column header.",
    "lineNumber": 10,
    "params": [
      {
        "nullable": null,
        "types": [
          " object "
        ],
        "spread": false,
        "optional": false,
        "name": "props",
        "description": "Component props"
      },
      {
        "nullable": null,
        "types": [
          " Column "
        ],
        "spread": false,
        "optional": false,
        "name": "props.column",
        "description": "The properties of the column"
      },
      {
        "nullable": null,
        "types": [
          " string "
        ],
        "spread": false,
        "optional": false,
        "name": "props.column.headerLabel",
        "description": "The header's label"
      }
    ],
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 66,
    "kind": "method",
    "name": "getLabel",
    "memberof": "src/components/ColumnRenderer.js~ColumnHeaderRenderer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/ColumnRenderer.js~ColumnHeaderRenderer#getLabel",
    "access": "public",
    "description": "Returns the label of the header.",
    "lineNumber": 15,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ string }"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        " string "
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 67,
    "kind": "method",
    "name": "render",
    "memberof": "src/components/ColumnRenderer.js~ColumnHeaderRenderer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/ColumnRenderer.js~ColumnHeaderRenderer#render",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 68,
    "kind": "file",
    "name": "src/components/GroupRenderer.js",
    "content": "import React from 'react';\nimport {Group} from '../index';\n\n/**\n * Group (row) renderer class\n * @param { object } props - Component props\n * @param { string } props.labelProperty - The key of the data from group that should be rendered\n * @param { Group } props.group - The group to be rendered\n * @param { string } props.group.id - The group's id\n */\nexport class GroupRenderer extends React.Component {\n  /**\n   * Returns the label of the cell.\n   * @returns { string }\n   */\n  getLabel() {\n    return this.props.group[this.props.labelProperty];\n  }\n\n  render() {\n    return (\n      <span data-group-index={this.props.group.id}>\n        <span>{this.getLabel()}</span>\n      </span>\n    );\n  }\n}\n",
    "static": true,
    "longname": "/home/poweruser/git/react-timeline-10000/src/components/GroupRenderer.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 69,
    "kind": "class",
    "name": "GroupRenderer",
    "memberof": "src/components/GroupRenderer.js",
    "static": true,
    "longname": "src/components/GroupRenderer.js~GroupRenderer",
    "access": "public",
    "export": true,
    "importPath": "@crispico/react-timeline-10000/src/components/GroupRenderer.js",
    "importStyle": "{GroupRenderer}",
    "description": "Group (row) renderer class",
    "lineNumber": 11,
    "params": [
      {
        "nullable": null,
        "types": [
          " object "
        ],
        "spread": false,
        "optional": false,
        "name": "props",
        "description": "Component props"
      },
      {
        "nullable": null,
        "types": [
          " string "
        ],
        "spread": false,
        "optional": false,
        "name": "props.labelProperty",
        "description": "The key of the data from group that should be rendered"
      },
      {
        "nullable": null,
        "types": [
          " Group "
        ],
        "spread": false,
        "optional": false,
        "name": "props.group",
        "description": "The group to be rendered"
      },
      {
        "nullable": null,
        "types": [
          " string "
        ],
        "spread": false,
        "optional": false,
        "name": "props.group.id",
        "description": "The group's id"
      }
    ],
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 70,
    "kind": "method",
    "name": "getLabel",
    "memberof": "src/components/GroupRenderer.js~GroupRenderer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/GroupRenderer.js~GroupRenderer#getLabel",
    "access": "public",
    "description": "Returns the label of the cell.",
    "lineNumber": 16,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ string }"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        " string "
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 71,
    "kind": "method",
    "name": "render",
    "memberof": "src/components/GroupRenderer.js~GroupRenderer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/GroupRenderer.js~GroupRenderer#render",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 72,
    "kind": "file",
    "name": "src/components/GroupRenderer.test.js",
    "content": "'use strict';\nimport React from 'react';\nimport {shallow} from 'enzyme';\nimport {expect} from 'chai';\nimport {GroupRenderer} from './GroupRenderer';\n\ndescribe('Group renderer', () => {\n  it('should render the group w/o label property', () => {\n    const group = {title: 'my_test'};\n    const component = shallow(<GroupRenderer group={group} />);\n    expect(component.text()).to.equals('');\n  });\n  it('should render the group w/ label property', () => {\n    const group = {title: 'my_test'};\n    const component = shallow(<GroupRenderer group={group} labelProperty={'title'} />);\n    expect(component.text()).to.equals('my_test');\n  });\n});\n",
    "static": true,
    "longname": "/home/poweruser/git/react-timeline-10000/src/components/GroupRenderer.test.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 73,
    "kind": "file",
    "name": "src/components/HighlightedInterval.js",
    "content": "import React from 'react';\nimport PropTypes from 'prop-types';\nimport {convertDateToMoment} from '../utils/timeUtils';\n\n/**\n * @extends React.Component<HighlightedInterval.propTypes>\n */\nexport class HighlightedInterval extends React.Component {\n  static propTypes = {\n    /**\n     * Start of the highlighted interval, as date (numeric/millis or moment object, cf. `Timeline.props.useMoment`).\n     *\n     * @type { object | number }\n     */\n    start: PropTypes.oneOfType([PropTypes.object, PropTypes.number]).isRequired,\n\n    /**\n     * End of the highlighted interval, as date (numeric/millis or moment object, cf. `Timeline.props.useMoment`).\n     *\n     * @type { object | number}\n     */\n    end: PropTypes.oneOfType([PropTypes.object, PropTypes.number]).isRequired,\n\n    /**\n     * Class name used to render the interval.\n     *\n     * @type { string }\n     */\n    className: PropTypes.string,\n\n    /**\n     * Style used to render the interval.\n     *\n     * @type { object }\n     */\n    style: PropTypes.object,\n\n    /**\n     * Internal (passed by parent). The height of the highlighted interval.\n     *\n     * @type { number }\n     */\n    height: PropTypes.number,\n\n    /**\n     * Internal (passed by parent). `HighlightedInterval` uses absolute positioning, thus it needs the `top` property\n     * to set the top edge if the element.\n     *\n     * @type { number }\n     */\n    top: PropTypes.number,\n\n    /**\n     * Internal (passed by parent). This function allows the conversion of `start`/`end` (time) properties to pixels.\n     *\n     * @type { Function }\n     */\n    calculateHorizontalPosition: PropTypes.func.isRequired,\n\n    /**\n     * Internal (passed by parent). If true timeline will try to minimize re-renders (e.g: the displayed timeline interval changes).\n     *\n     * @type { boolean }\n     */\n    shouldUpdate: PropTypes.bool\n  };\n\n  static defaultProps = {\n    className: '',\n    height: undefined,\n    top: undefined,\n    calculateHorizontalPosition: () => {},\n    shouldUpdate: false\n  };\n\n  shouldComponentUpdate(nextProps) {\n    if (\n      nextProps.shouldUpdate ||\n      this.props.height !== nextProps.height ||\n      this.props.top !== nextProps.top ||\n      !convertDateToMoment(this.props.start).isSame(convertDateToMoment(nextProps.start).valueOf()) ||\n      !convertDateToMoment(this.props.end).isSame(convertDateToMoment(nextProps.end))\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @returns { object } style\n   */\n  getStyle() {\n    const {left, width} = this.props.calculateHorizontalPosition(this.props.start, this.props.end);\n    return {\n      ...this.props.style,\n      left,\n      width,\n      top: this.props.top,\n      height: this.props.height,\n      display: left && width ? 'block' : 'none'\n    };\n  }\n\n  /**\n   * @returns { string } className\n   */\n  getClassName() {\n    return `rct9k-highlighted-interval ${this.props.className}`;\n  }\n\n  render() {\n    return <div className={this.getClassName()} style={this.getStyle()} />;\n  }\n}\n",
    "static": true,
    "longname": "/home/poweruser/git/react-timeline-10000/src/components/HighlightedInterval.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 74,
    "kind": "class",
    "name": "HighlightedInterval",
    "memberof": "src/components/HighlightedInterval.js",
    "static": true,
    "longname": "src/components/HighlightedInterval.js~HighlightedInterval",
    "access": "public",
    "export": true,
    "importPath": "@crispico/react-timeline-10000/src/components/HighlightedInterval.js",
    "importStyle": "{HighlightedInterval}",
    "description": "",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "*"
    ]
  },
  {
    "__docId__": 75,
    "kind": "member",
    "name": "propTypes",
    "memberof": "src/components/HighlightedInterval.js~HighlightedInterval",
    "static": true,
    "longname": "src/components/HighlightedInterval.js~HighlightedInterval.propTypes",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 76,
    "kind": "member",
    "name": "defaultProps",
    "memberof": "src/components/HighlightedInterval.js~HighlightedInterval",
    "static": true,
    "longname": "src/components/HighlightedInterval.js~HighlightedInterval.defaultProps",
    "access": "public",
    "description": null,
    "lineNumber": 68,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 77,
    "kind": "method",
    "name": "shouldComponentUpdate",
    "memberof": "src/components/HighlightedInterval.js~HighlightedInterval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/HighlightedInterval.js~HighlightedInterval#shouldComponentUpdate",
    "access": "public",
    "description": null,
    "lineNumber": 76,
    "undocument": true,
    "params": [
      {
        "name": "nextProps",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 78,
    "kind": "method",
    "name": "getStyle",
    "memberof": "src/components/HighlightedInterval.js~HighlightedInterval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/HighlightedInterval.js~HighlightedInterval#getStyle",
    "access": "public",
    "description": "",
    "lineNumber": 92,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ object } style"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        " object "
      ],
      "spread": false,
      "description": "style"
    },
    "params": []
  },
  {
    "__docId__": 79,
    "kind": "method",
    "name": "getClassName",
    "memberof": "src/components/HighlightedInterval.js~HighlightedInterval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/HighlightedInterval.js~HighlightedInterval#getClassName",
    "access": "public",
    "description": "",
    "lineNumber": 107,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ string } className"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        " string "
      ],
      "spread": false,
      "description": "className"
    },
    "params": []
  },
  {
    "__docId__": 80,
    "kind": "method",
    "name": "render",
    "memberof": "src/components/HighlightedInterval.js~HighlightedInterval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/HighlightedInterval.js~HighlightedInterval#render",
    "access": "public",
    "description": null,
    "lineNumber": 111,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 81,
    "kind": "file",
    "name": "src/components/ItemRenderer.js",
    "content": "import React from 'react';\nimport PropTypes from 'prop-types';\nimport Color from 'color';\nimport {Item} from '../index';\n\nconst ITEM_RENDERER_CLS = 'rct9k-item-renderer';\nconst ITEM_RENDERER_GLOW_CLS = 'rct9k-item-glow';\n\n/**\n * Item (segment) renderer. All the properties of an item are copied as properties of this component. Hence the component\n * doesn't use the property `item`.\n *\n * All the properties have corresponding getter methods. We \"OOP-ize\" them, for the case where a subclass wants to \"override\" a property.\n * Without this pattern, such an override is not doable in React.\n * @extends React.Component<ItemRenderer.propTypes>\n */\nexport default class ItemRenderer extends React.Component {\n  static propTypes = {\n    /**\n     * It's passed by the parent. Though not used by this component. It exists because maybe subclasses want to use it.\n     * @type { Item }\n     */\n    item: PropTypes.object,\n\n    /**\n     * The title (label) of the segment (item).\n     * @type { string }\n     */\n    title: PropTypes.string,\n\n    /**\n     * Tooltip displayed on mouse over the segment (item).\n     * @type { string }\n     */\n    tooltip: PropTypes.string,\n\n    /**\n     * The height of the segment (item).\n     *\n     * This property is received from the parent and its based on `itemHeight` from `Timeline`. The parent adds a padding\n     * (@see rct9k-items-inner class) which must be subtracted from `itemHeight` resulting in `height`.\n     *\n     * NOTE: If you override the getter, the maximum `height` can be `itemHeight` minus the padding.\n     * @type { string | number }\n     */\n    height: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n\n    /**\n     * Used to show a glow effect around the segment (item) when the mouse is moved over the segment (item).\n     * @type { boolean }\n     */\n    glowOnHover: PropTypes.bool,\n\n    /**\n     * The renderer uses a **linear gradient** (top to bottom) as a background. The gradient is configured\n     * using two colors: a base color (`color`) and the base color lightened by a percentage (`gradientBrightness`).\n     * @type { string }\n     */\n    color: PropTypes.string,\n\n    /**\n     * A number between 0 and 1; it represents the percentage by which `color` is lightened to obtain the second color used in the gradient.\n     * @type { number }\n     * /\n    gradientBrightness: PropTypes.number,\n\n    /**\n     * A number between 0 and 100 (percentage from the height of the item) and it represents the point where the first color stops in the gradient.\n     * @type { number }\n     */\n    gradientStop: PropTypes.number,\n\n    /**\n     * Default order of the colors in the gradient: lighter color, base color.\n     * If `true`, the order of the colors will be reversed.\n     * @type { boolean }\n     */\n    gradientReverseDirection: PropTypes.bool,\n\n    /**\n     * The style of the segment used to render the segment (item).\n     * @type { object }\n     */\n    style: PropTypes.object,\n\n    /**\n     * Class name used to render the segment (item).\n     * @type { string }\n     */\n    className: PropTypes.string\n  };\n\n  static defaultProps = {\n    color: '#3791D4',\n    glowOnHover: true,\n    gradientBrightness: 0.45,\n    gradientStop: 40,\n    gradientReverseDirection: false,\n    title: undefined,\n    tooltip: undefined,\n    className: undefined,\n    style: {},\n    item: {}\n  };\n\n  /**\n   * Getter for the corresponding prop, to allow override by subclass.\n   * @returns { string | JSX.Element }\n   */\n  getTitle() {\n    return this.props.title;\n  }\n\n  /**\n   * Getter for the corresponding prop, to allow override by subclass.\n   * @returns { string }\n   */\n  getTooltip() {\n    return this.props.tooltip;\n  }\n\n  /**\n   * Getter for the corresponding prop, to allow override by subclass.\n   * @returns { string | number }\n   */\n  getHeight() {\n    return this.props.height;\n  }\n\n  /**\n   * Getter for the corresponding prop, to allow override by subclass.\n   * @returns { string }\n   */\n  getColor() {\n    return this.props.color;\n  }\n\n  /**\n   * Getter for the corresponding prop, to allow override by subclass.\n   * @returns { number }\n   */\n  getGradientBrightness() {\n    return this.props.gradientBrightness;\n  }\n\n  /**\n   * Getter for the corresponding prop, to allow override by subclass.\n   * @returns { number }\n   */\n  getGradientStop() {\n    return this.props.gradientStop;\n  }\n\n  /**\n   * Getter for the corresponding prop, to allow override by subclass.\n   * @returns { boolean }\n   */\n  getGradientReverseDirection() {\n    return this.props.gradientReverseDirection;\n  }\n\n  /**\n   * Returns the color of the text. This method returns 'white' when the background is darker,\n   * otherwise returns black.\n   * @returns {string}\n   */\n  getTextColor() {\n    return Color(this.getColor()).isLight() ? 'black' : 'white';\n  }\n\n  /**\n   * Create a linear gradient using the base color (calls getColor()) and a color obtained adjusting\n   * the brightness of that color using getGradientBrightness(). The default order of the colors is\n   * [brighter gradient color, gradient color]; this order can be reversed if getGradientReverseDirection() is true.\n   *\n   * By default, the background of an item uses a linear gradient, this method should be overriden if this behaviour is not wanted.\n   * @returns {string} linear gradient\n   */\n  getBackgroundGradient() {\n    let colors = [\n      Color(this.getColor())\n        .lighten(this.getGradientBrightness())\n        .hex(),\n      this.getColor()\n    ];\n    if (this.getGradientReverseDirection()) {\n      colors.reverse();\n    }\n\n    return 'linear-gradient(' + colors[0] + ' ' + this.getGradientStop() + '%, ' + colors[1] + ')';\n  }\n\n  /**\n   * Returns the style of the item.\n   * @returns { object }\n   */\n  getStyle() {\n    return {\n      ...this.props.style,\n      color: this.getTextColor(),\n      height: this.getHeight(),\n      background: this.getBackgroundGradient()\n    };\n  }\n\n  /**\n   * Returns a css class used to apply glow on item hover.\n   * @returns { string }\n   */\n  getGlowOnHoverClassName() {\n    return this.props.glowOnHover ? ITEM_RENDERER_GLOW_CLS : '';\n  }\n\n  /**\n   * Returns the css classes applied on the item.\n   * @returns { string }\n   */\n  getClassName() {\n    return ITEM_RENDERER_CLS + ' ' + this.props.className + ' ' + this.getGlowOnHoverClassName();\n  }\n\n  render() {\n    return (\n      <span className={this.getClassName()} style={this.getStyle()} title={this.getTooltip()}>\n        <span className=\"rct9k-item-renderer-inner\">{this.getTitle()}</span>\n      </span>\n    );\n  }\n}\n",
    "static": true,
    "longname": "/home/poweruser/git/react-timeline-10000/src/components/ItemRenderer.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 82,
    "kind": "variable",
    "name": "ITEM_RENDERER_CLS",
    "memberof": "src/components/ItemRenderer.js",
    "static": true,
    "longname": "src/components/ItemRenderer.js~ITEM_RENDERER_CLS",
    "access": "public",
    "export": false,
    "importPath": "@crispico/react-timeline-10000/src/components/ItemRenderer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 83,
    "kind": "variable",
    "name": "ITEM_RENDERER_GLOW_CLS",
    "memberof": "src/components/ItemRenderer.js",
    "static": true,
    "longname": "src/components/ItemRenderer.js~ITEM_RENDERER_GLOW_CLS",
    "access": "public",
    "export": false,
    "importPath": "@crispico/react-timeline-10000/src/components/ItemRenderer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 84,
    "kind": "class",
    "name": "ItemRenderer",
    "memberof": "src/components/ItemRenderer.js",
    "static": true,
    "longname": "src/components/ItemRenderer.js~ItemRenderer",
    "access": "public",
    "export": true,
    "importPath": "@crispico/react-timeline-10000/src/components/ItemRenderer.js",
    "importStyle": "ItemRenderer",
    "description": "Item (segment) renderer. All the properties of an item are copied as properties of this component. Hence the component\ndoesn't use the property `item`.\n\nAll the properties have corresponding getter methods. We \"OOP-ize\" them, for the case where a subclass wants to \"override\" a property.\nWithout this pattern, such an override is not doable in React.",
    "lineNumber": 17,
    "interface": false,
    "extends": [
      "*"
    ]
  },
  {
    "__docId__": 85,
    "kind": "member",
    "name": "propTypes",
    "memberof": "src/components/ItemRenderer.js~ItemRenderer",
    "static": true,
    "longname": "src/components/ItemRenderer.js~ItemRenderer.propTypes",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 86,
    "kind": "member",
    "name": "defaultProps",
    "memberof": "src/components/ItemRenderer.js~ItemRenderer",
    "static": true,
    "longname": "src/components/ItemRenderer.js~ItemRenderer.defaultProps",
    "access": "public",
    "description": null,
    "lineNumber": 93,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 87,
    "kind": "method",
    "name": "getTitle",
    "memberof": "src/components/ItemRenderer.js~ItemRenderer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/ItemRenderer.js~ItemRenderer#getTitle",
    "access": "public",
    "description": "Getter for the corresponding prop, to allow override by subclass.",
    "lineNumber": 110,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ string | JSX.Element }"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        " string ",
        " JSX.Element "
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 88,
    "kind": "method",
    "name": "getTooltip",
    "memberof": "src/components/ItemRenderer.js~ItemRenderer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/ItemRenderer.js~ItemRenderer#getTooltip",
    "access": "public",
    "description": "Getter for the corresponding prop, to allow override by subclass.",
    "lineNumber": 118,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ string }"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        " string "
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 89,
    "kind": "method",
    "name": "getHeight",
    "memberof": "src/components/ItemRenderer.js~ItemRenderer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/ItemRenderer.js~ItemRenderer#getHeight",
    "access": "public",
    "description": "Getter for the corresponding prop, to allow override by subclass.",
    "lineNumber": 126,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ string | number }"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        " string ",
        " number "
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 90,
    "kind": "method",
    "name": "getColor",
    "memberof": "src/components/ItemRenderer.js~ItemRenderer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/ItemRenderer.js~ItemRenderer#getColor",
    "access": "public",
    "description": "Getter for the corresponding prop, to allow override by subclass.",
    "lineNumber": 134,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ string }"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        " string "
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 91,
    "kind": "method",
    "name": "getGradientBrightness",
    "memberof": "src/components/ItemRenderer.js~ItemRenderer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/ItemRenderer.js~ItemRenderer#getGradientBrightness",
    "access": "public",
    "description": "Getter for the corresponding prop, to allow override by subclass.",
    "lineNumber": 142,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ number }"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        " number "
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 92,
    "kind": "method",
    "name": "getGradientStop",
    "memberof": "src/components/ItemRenderer.js~ItemRenderer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/ItemRenderer.js~ItemRenderer#getGradientStop",
    "access": "public",
    "description": "Getter for the corresponding prop, to allow override by subclass.",
    "lineNumber": 150,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ number }"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        " number "
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 93,
    "kind": "method",
    "name": "getGradientReverseDirection",
    "memberof": "src/components/ItemRenderer.js~ItemRenderer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/ItemRenderer.js~ItemRenderer#getGradientReverseDirection",
    "access": "public",
    "description": "Getter for the corresponding prop, to allow override by subclass.",
    "lineNumber": 158,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ boolean }"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        " boolean "
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 94,
    "kind": "method",
    "name": "getTextColor",
    "memberof": "src/components/ItemRenderer.js~ItemRenderer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/ItemRenderer.js~ItemRenderer#getTextColor",
    "access": "public",
    "description": "Returns the color of the text. This method returns 'white' when the background is darker,\notherwise returns black.",
    "lineNumber": 167,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 95,
    "kind": "method",
    "name": "getBackgroundGradient",
    "memberof": "src/components/ItemRenderer.js~ItemRenderer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/ItemRenderer.js~ItemRenderer#getBackgroundGradient",
    "access": "public",
    "description": "Create a linear gradient using the base color (calls getColor()) and a color obtained adjusting\nthe brightness of that color using getGradientBrightness(). The default order of the colors is\n[brighter gradient color, gradient color]; this order can be reversed if getGradientReverseDirection() is true.\n\nBy default, the background of an item uses a linear gradient, this method should be overriden if this behaviour is not wanted.",
    "lineNumber": 179,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} linear gradient"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "linear gradient"
    },
    "params": []
  },
  {
    "__docId__": 96,
    "kind": "method",
    "name": "getStyle",
    "memberof": "src/components/ItemRenderer.js~ItemRenderer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/ItemRenderer.js~ItemRenderer#getStyle",
    "access": "public",
    "description": "Returns the style of the item.",
    "lineNumber": 197,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ object }"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        " object "
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 97,
    "kind": "method",
    "name": "getGlowOnHoverClassName",
    "memberof": "src/components/ItemRenderer.js~ItemRenderer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/ItemRenderer.js~ItemRenderer#getGlowOnHoverClassName",
    "access": "public",
    "description": "Returns a css class used to apply glow on item hover.",
    "lineNumber": 210,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ string }"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        " string "
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 98,
    "kind": "method",
    "name": "getClassName",
    "memberof": "src/components/ItemRenderer.js~ItemRenderer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/ItemRenderer.js~ItemRenderer#getClassName",
    "access": "public",
    "description": "Returns the css classes applied on the item.",
    "lineNumber": 218,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ string }"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        " string "
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 99,
    "kind": "method",
    "name": "render",
    "memberof": "src/components/ItemRenderer.js~ItemRenderer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/ItemRenderer.js~ItemRenderer#render",
    "access": "public",
    "description": null,
    "lineNumber": 222,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 100,
    "kind": "file",
    "name": "src/components/ItemRenderer.test.js",
    "content": "'use strict';\nimport React from 'react';\nimport {shallow} from 'enzyme';\nimport {expect} from 'chai';\n\nimport ItemRenderer from './ItemRenderer';\n\ndescribe('Item renderer', () => {\n  it('should render the item', () => {\n    const item = {title: 'my_test'};\n    const component = shallow(<ItemRenderer {...item} item={item} />);\n    expect(component.text()).to.contain('my_test');\n  });\n});\n",
    "static": true,
    "longname": "/home/poweruser/git/react-timeline-10000/src/components/ItemRenderer.test.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 101,
    "kind": "file",
    "name": "src/components/Marker.js",
    "content": "import React from 'react';\nimport PropTypes from 'prop-types';\nimport {convertDateToMoment} from '../utils/timeUtils';\n\n/**\n * A `Marker` is a component draws a vertical line.\n *\n * @extends React.Component<Marker.propTypes>\n */\nexport class Marker extends React.Component {\n  static propTypes = {\n    /**\n     * The position of the marker, as date (numeric/millis or moment object, cf. `Timeline.props.useMoment`).\n     *\n     * @type { object | number }\n     */\n    date: PropTypes.oneOfType([PropTypes.object, PropTypes.number]).isRequired,\n\n    /**\n     * Class name used to render the marker.\n     *\n     * @type { string }\n     */\n    className: PropTypes.string,\n\n    /**\n     * Style used to render the marker.\n     *\n     * @type { object }\n     */\n    style: PropTypes.object,\n\n    /**\n     * Internal (passed by parent). The height of the marker.\n     *\n     * @type { number }\n     */\n    height: PropTypes.number,\n\n    /**\n     * Internal (passed by parent). `Marker` uses absolute positioning, thus it needs the `top` property\n     * to set the top edge if the element.\n     *\n     * @type { number }\n     */\n    top: PropTypes.number,\n\n    /**\n     * Internal (passed by parent). This function allows the conversion of `date` (time) property to pixels.\n     *\n     * @type { Function }\n     */\n    calculateHorizontalPosition: PropTypes.func.isRequired,\n\n    /**\n     * Internal (passed by parent). If true timeline will try to minimize re-renders (e.g: the displayed timeline interval changes).\n     *\n     * @type { boolean }\n     */\n    shouldUpdate: PropTypes.bool\n  };\n\n  static defaultProps = {\n    className: '',\n    style: undefined,\n    height: undefined,\n    top: undefined,\n    calculateHorizontalPosition: () => {},\n    shouldUpdate: false\n  };\n\n  shouldComponentUpdate(nextProps) {\n    if (\n      nextProps.shouldUpdate ||\n      this.props.height !== nextProps.height ||\n      this.props.top !== nextProps.top ||\n      !convertDateToMoment(this.props.date).isSame(convertDateToMoment(nextProps.date).valueOf())\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @returns { object } style\n   */\n  getStyle() {\n    const {left} = this.props.calculateHorizontalPosition(this.props.date);\n    return {\n      ...this.props.style,\n      top: this.props.top,\n      height: this.props.height,\n      left,\n      display: left ? 'block' : 'none'\n    };\n  }\n\n  /**\n   * @returns { string } className\n   */\n  getClassName() {\n    return `rct9k-marker ${this.props.className}`;\n  }\n\n  render() {\n    return <hr className={this.getClassName()} style={this.getStyle()} />;\n  }\n}\n",
    "static": true,
    "longname": "/home/poweruser/git/react-timeline-10000/src/components/Marker.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 102,
    "kind": "class",
    "name": "Marker",
    "memberof": "src/components/Marker.js",
    "static": true,
    "longname": "src/components/Marker.js~Marker",
    "access": "public",
    "export": true,
    "importPath": "@crispico/react-timeline-10000/src/components/Marker.js",
    "importStyle": "{Marker}",
    "description": "A `Marker` is a component draws a vertical line.",
    "lineNumber": 10,
    "interface": false,
    "extends": [
      "*"
    ]
  },
  {
    "__docId__": 103,
    "kind": "member",
    "name": "propTypes",
    "memberof": "src/components/Marker.js~Marker",
    "static": true,
    "longname": "src/components/Marker.js~Marker.propTypes",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 104,
    "kind": "member",
    "name": "defaultProps",
    "memberof": "src/components/Marker.js~Marker",
    "static": true,
    "longname": "src/components/Marker.js~Marker.defaultProps",
    "access": "public",
    "description": null,
    "lineNumber": 63,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 105,
    "kind": "method",
    "name": "shouldComponentUpdate",
    "memberof": "src/components/Marker.js~Marker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/Marker.js~Marker#shouldComponentUpdate",
    "access": "public",
    "description": null,
    "lineNumber": 72,
    "undocument": true,
    "params": [
      {
        "name": "nextProps",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 106,
    "kind": "method",
    "name": "getStyle",
    "memberof": "src/components/Marker.js~Marker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/Marker.js~Marker#getStyle",
    "access": "public",
    "description": "",
    "lineNumber": 87,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ object } style"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        " object "
      ],
      "spread": false,
      "description": "style"
    },
    "params": []
  },
  {
    "__docId__": 107,
    "kind": "method",
    "name": "getClassName",
    "memberof": "src/components/Marker.js~Marker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/Marker.js~Marker#getClassName",
    "access": "public",
    "description": "",
    "lineNumber": 101,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ string } className"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        " string "
      ],
      "spread": false,
      "description": "className"
    },
    "params": []
  },
  {
    "__docId__": 108,
    "kind": "method",
    "name": "render",
    "memberof": "src/components/Marker.js~Marker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/Marker.js~Marker#render",
    "access": "public",
    "description": null,
    "lineNumber": 105,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 109,
    "kind": "file",
    "name": "src/components/body.js",
    "content": "/**\n * Timeline body/grid\n */\n\nimport React, {Component} from 'react';\nimport PropTypes from 'prop-types';\n\nimport {Grid} from 'react-virtualized';\n\n/**\n * @extends Component<TimelineBody.propTypes>\n */\nclass TimelineBody extends Component {\n  componentDidMount() {\n    this.forceUpdate();\n  }\n  shouldComponentUpdate(nextProps) {\n    const {props} = this;\n    if (!props.shallowUpdateCheck) {\n      return true;\n    }\n\n    if (props.columnCount !== nextProps.columnCount) {\n      return true;\n    }\n\n    // prettier-ignore\n    const shallowChange = props.height !== nextProps.height\n      || props.width !== nextProps.width\n      || props.rowCount !== nextProps.rowCount;\n\n    if (props.forceRedrawFunc) {\n      return shallowChange || props.forceRedrawFunc(props, nextProps);\n    }\n\n    return shallowChange;\n  }\n  render() {\n    const {width, columnWidth, height, rowHeight, rowCount, columnCount} = this.props;\n    const {grid_ref_callback, cellRenderer} = this.props;\n\n    return (\n      <Grid\n        ref={grid_ref_callback}\n        autoContainerWidth\n        cellRenderer={cellRenderer}\n        columnCount={columnCount}\n        columnWidth={columnWidth}\n        height={height}\n        rowCount={rowCount}\n        rowHeight={rowHeight}\n        width={width}\n      />\n    );\n  }\n}\n\nTimelineBody.propTypes = {\n  /**\n   * The total width of the body; mandatory field.\n   * @type { number }\n   */\n  width: PropTypes.number.isRequired,\n\n  /**\n   * Function that returns the width of each column, mandatory field.\n   * @type { Function }\n   */\n  columnWidth: PropTypes.func.isRequired,\n\n  /**\n   * The total number of columns, including the timeline (gantt).\n   * @type { number }\n   */\n  columnCount: PropTypes.number,\n\n  /**\n   * The total height of the body (without timebar), mandatory field.\n   * @type { number }\n   */\n  height: PropTypes.number.isRequired,\n\n  /**\n   * Function that returns the height for each row, mandatory field.\n   * @type { Function }\n   */\n  rowHeight: PropTypes.func.isRequired,\n\n  /**\n   * Number of rows in timeline, mandatory field.\n   * @type { number }\n   */\n  rowCount: PropTypes.number.isRequired,\n\n  /**\n   * @type { Function }\n   */\n  grid_ref_callback: PropTypes.func.isRequired,\n\n  /**\n   * Renderer for each cell of the grid.\n   * @type { Function }\n   */\n  cellRenderer: PropTypes.func.isRequired,\n\n  /**\n   * As e.g. @see Timeline.props.shallowUpdateCheck\n   * @type { boolean }\n   */\n  shallowUpdateCheck: PropTypes.bool,\n\n  /**\n   * As e.g. @see Timeline.props.forceRedrawFunc\n   * @type { Function }\n   */\n  forceRedrawFunc: PropTypes.func\n};\n\nTimelineBody.defaultProps = {\n  columnCount: 2,\n  shallowUpdateCheck: false,\n  forceRedrawFunc: null\n};\nexport default TimelineBody;\n",
    "static": true,
    "longname": "/home/poweruser/git/react-timeline-10000/src/components/body.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 110,
    "kind": "class",
    "name": "TimelineBody",
    "memberof": "src/components/body.js",
    "static": true,
    "longname": "src/components/body.js~TimelineBody",
    "access": "public",
    "export": true,
    "importPath": "@crispico/react-timeline-10000/src/components/body.js",
    "importStyle": "TimelineBody",
    "description": "",
    "lineNumber": 13,
    "interface": false,
    "extends": [
      "*"
    ]
  },
  {
    "__docId__": 111,
    "kind": "method",
    "name": "componentDidMount",
    "memberof": "src/components/body.js~TimelineBody",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/body.js~TimelineBody#componentDidMount",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 112,
    "kind": "method",
    "name": "shouldComponentUpdate",
    "memberof": "src/components/body.js~TimelineBody",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/body.js~TimelineBody#shouldComponentUpdate",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "params": [
      {
        "name": "nextProps",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 113,
    "kind": "method",
    "name": "render",
    "memberof": "src/components/body.js~TimelineBody",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/body.js~TimelineBody#render",
    "access": "public",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 114,
    "kind": "file",
    "name": "src/components/selector.js",
    "content": "'use strict';\nimport React from 'react';\n\n/**\n * Component to show a selection box (like on windows desktop)\n */\nexport default class SelectBox extends React.Component {\n  constructor(props) {\n    super(props);\n    this.curX = 0;\n    this.curY = 0;\n    this.startX = 0;\n    this.startY = 0;\n  }\n\n  /**\n   * Create the selection box\n   * @param {number} x Starting x coordinate for selection box\n   * @param {number} y Starting y coordinate for selection box\n   */\n  start(x, y) {\n    this.startX = x;\n    this.startY = y;\n    this.curX = 0;\n    this.curY = 0;\n  }\n\n  /**\n   * Update the selection box as the mouse moves\n   * @param {number} x The current X coordinate of the mouse\n   * @param {number} y The current Y coordinate of the mouse\n   */\n  move(x, y) {\n    this.curX = x;\n    this.curY = y;\n    this.forceUpdate();\n  }\n\n  /**\n   * Generally on mouse up.\n   * Finish the selection box and return the rectangle created\n   * @returns {Object} The selection rectangle\n   * @property {number} top The top y coordinate\n   * @property {number} left The left x coordinate\n   * @property {number} width The width of the box\n   * @property {number} height The height of the box\n   */\n  end() {\n    const {startX, startY, curX, curY} = this;\n    const left = Math.min(startX, curX);\n    const top = Math.min(startY, curY);\n    const width = Math.abs(startX - curX);\n    const height = Math.abs(startY - curY);\n    let toReturn = {left, top, width, height};\n\n    this.startX = 0;\n    this.startY = 0;\n    this.curX = 0;\n    this.curY = 0;\n    this.forceUpdate();\n    return toReturn;\n  }\n\n  /**\n   * @ignore\n   */\n  render() {\n    const {startX, startY, curX, curY} = this;\n    const left = Math.min(startX, curX);\n    const top = Math.min(startY, curY);\n    const width = Math.abs(startX - curX);\n    const height = Math.abs(startY - curY);\n    let style = {left, top, width, height};\n    return <div className=\"rct9k-selector-outer\" style={style} />;\n  }\n}\n",
    "static": true,
    "longname": "/home/poweruser/git/react-timeline-10000/src/components/selector.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 115,
    "kind": "class",
    "name": "SelectBox",
    "memberof": "src/components/selector.js",
    "static": true,
    "longname": "src/components/selector.js~SelectBox",
    "access": "public",
    "export": true,
    "importPath": "@crispico/react-timeline-10000/src/components/selector.js",
    "importStyle": "SelectBox",
    "description": "Component to show a selection box (like on windows desktop)",
    "lineNumber": 7,
    "interface": false,
    "extends": [
      "react~React.Component"
    ]
  },
  {
    "__docId__": 116,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/components/selector.js~SelectBox",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/selector.js~SelectBox#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 8,
    "undocument": true
  },
  {
    "__docId__": 117,
    "kind": "member",
    "name": "curX",
    "memberof": "src/components/selector.js~SelectBox",
    "static": false,
    "longname": "src/components/selector.js~SelectBox#curX",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 118,
    "kind": "member",
    "name": "curY",
    "memberof": "src/components/selector.js~SelectBox",
    "static": false,
    "longname": "src/components/selector.js~SelectBox#curY",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 119,
    "kind": "member",
    "name": "startX",
    "memberof": "src/components/selector.js~SelectBox",
    "static": false,
    "longname": "src/components/selector.js~SelectBox#startX",
    "access": "public",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 120,
    "kind": "member",
    "name": "startY",
    "memberof": "src/components/selector.js~SelectBox",
    "static": false,
    "longname": "src/components/selector.js~SelectBox#startY",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 121,
    "kind": "method",
    "name": "start",
    "memberof": "src/components/selector.js~SelectBox",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/selector.js~SelectBox#start",
    "access": "public",
    "description": "Create the selection box",
    "lineNumber": 21,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "x",
        "description": "Starting x coordinate for selection box"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "y",
        "description": "Starting y coordinate for selection box"
      }
    ],
    "return": null
  },
  {
    "__docId__": 126,
    "kind": "method",
    "name": "move",
    "memberof": "src/components/selector.js~SelectBox",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/selector.js~SelectBox#move",
    "access": "public",
    "description": "Update the selection box as the mouse moves",
    "lineNumber": 33,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "x",
        "description": "The current X coordinate of the mouse"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "y",
        "description": "The current Y coordinate of the mouse"
      }
    ],
    "return": null
  },
  {
    "__docId__": 129,
    "kind": "method",
    "name": "end",
    "memberof": "src/components/selector.js~SelectBox",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/selector.js~SelectBox#end",
    "access": "public",
    "description": "Generally on mouse up.\nFinish the selection box and return the rectangle created",
    "lineNumber": 48,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object} The selection rectangle"
      }
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "top",
        "description": "The top y coordinate"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "left",
        "description": "The left x coordinate"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "width",
        "description": "The width of the box"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "height",
        "description": "The height of the box"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "The selection rectangle"
    },
    "params": []
  },
  {
    "__docId__": 134,
    "kind": "method",
    "name": "render",
    "memberof": "src/components/selector.js~SelectBox",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/selector.js~SelectBox#render",
    "access": "public",
    "description": "",
    "lineNumber": 67,
    "ignore": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 135,
    "kind": "file",
    "name": "src/components/selector.test.js",
    "content": "'use strict';\nimport React from 'react';\nimport {shallow, mount} from 'enzyme';\nimport {expect} from 'chai';\n\nimport setup from 'setupTests';\nimport SelectBox from './selector';\n\ndescribe('Selector', () => {\n  it('should initialize to 0,0', () => {\n    const component = shallow(<SelectBox />);\n    const instance = component.instance();\n    expect(instance.startX).to.equal(0);\n    expect(instance.startY).to.equal(0);\n    expect(instance.curX).to.equal(0);\n    expect(instance.curY).to.equal(0);\n  });\n  it('should set start coordinates correctly', () => {\n    const component = shallow(<SelectBox />);\n    const instance = component.instance();\n    instance.start(33, 44);\n    expect(instance.startX).to.equal(33);\n    expect(instance.startY).to.equal(44);\n    expect(instance.curX).to.equal(0);\n    expect(instance.curY).to.equal(0);\n  });\n  it('should set move coordinates correctly', () => {\n    const component = shallow(<SelectBox />);\n    const instance = component.instance();\n    instance.start(33, 44);\n    instance.move(55, 66);\n    expect(instance.startX).to.equal(33);\n    expect(instance.startY).to.equal(44);\n    expect(instance.curX).to.equal(55);\n    expect(instance.curY).to.equal(66);\n  });\n  it('should return correct coordinates on end', () => {\n    const component = shallow(<SelectBox />);\n    const instance = component.instance();\n    instance.start(33, 44);\n    instance.move(55, 45);\n    const endReturn = instance.end();\n    expect(endReturn).to.deep.equal({left: 33, top: 44, width: 22, height: 1});\n  });\n  it('should reset coordinates on end', () => {\n    const component = shallow(<SelectBox />);\n    const instance = component.instance();\n    instance.start(33, 44);\n    instance.move(55, 45);\n    const endReturn = instance.end();\n    expect(instance.startX).to.equal(0);\n    expect(instance.startY).to.equal(0);\n    expect(instance.curX).to.equal(0);\n    expect(instance.curY).to.equal(0);\n  });\n});\n",
    "static": true,
    "longname": "/home/poweruser/git/react-timeline-10000/src/components/selector.test.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 136,
    "kind": "file",
    "name": "src/components/timebar.js",
    "content": "'use strict';\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport _ from 'lodash';\nimport moment from 'moment';\nimport {intToPix} from '../utils/commonUtils';\nimport {ColumnHeaderRenderer} from './ColumnRenderer';\nimport {timebarFormat as defaultTimebarFormat} from '../consts/timebarConsts';\nimport {Column} from '../index';\n\n/**\n * Timebar component - displays the current time on top of the timeline.\n * @extends React.Component<Timebar.propTypes>\n */\nexport default class Timebar extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {topBarComponent: [], bottomBarComponent: [], resolution: {}};\n\n    this.guessResolution = this.guessResolution.bind(this);\n    this.renderBar = this.renderBar.bind(this);\n  }\n\n  componentWillMount() {\n    this.guessResolution();\n    const bottomBarComponent = this.getBottomBar();\n    const topBarComponent = this.getTopBar();\n    this.setState({topBarComponent, bottomBarComponent});\n  }\n\n  /**\n   * On new props we check if a resolution is given, and if not we guess one\n   * @param {Object} nextProps Props coming in\n   */\n  componentWillReceiveProps(nextProps) {\n    if (nextProps.top_resolution && nextProps.bottom_resolution) {\n      this.setState({resolution: {top: nextProps.top_resolution, bottom: nextProps.bottom_resolution}});\n    } else {\n      this.guessResolution(nextProps.start, nextProps.end);\n    }\n  }\n\n  componentDidUpdate(prevProps) {\n    if (\n      !this.props.start.isSame(prevProps.start) ||\n      !this.props.end.isSame(prevProps.end) ||\n      this.props.timeFormats !== prevProps.timeFormats ||\n      this.props.top_resolution !== prevProps.top_resolution ||\n      this.props.bottom_resolution !== prevProps.bottom_resolution ||\n      this.props.width !== prevProps.width ||\n      this.props.leftOffset !== prevProps.leftOffset\n    ) {\n      const bottomBarComponent = this.getBottomBar();\n      const topBarComponent = this.getTopBar();\n      this.setState({topBarComponent, bottomBarComponent});\n    }\n  }\n\n  /**\n   * Attempts to guess the resolution of the top and bottom halves of the timebar based on the viewable date range.\n   * Sets resolution to state.\n   * @param {moment} start Start date for the timebar\n   * @param {moment} end End date for the timebar\n   */\n  guessResolution(start, end) {\n    if (!start || !end) {\n      start = this.props.start;\n      end = this.props.end;\n    }\n    const durationMilliSecs = end.diff(start);\n    /// 1ms -> 1s\n    if (durationMilliSecs <= 1000) this.setState({resolution: {top: 'second', bottom: 'millisecond'}});\n    // 1s  -> 2m\n    else if (durationMilliSecs <= 60 * 2 * 1000) this.setState({resolution: {top: 'minute', bottom: 'second'}});\n    // 2m -> 2h\n    else if (durationMilliSecs <= 60 * 60 * 2 * 1000) this.setState({resolution: {top: 'hour', bottom: 'minute'}});\n    // 2h -> 3d\n    else if (durationMilliSecs <= 24 * 60 * 60 * 3 * 1000) this.setState({resolution: {top: 'day', bottom: 'hour'}});\n    // 1d -> 30d\n    else if (durationMilliSecs <= 30 * 24 * 60 * 60 * 1000) this.setState({resolution: {top: 'month', bottom: 'day'}});\n    //30d -> 1y\n    else if (durationMilliSecs <= 365 * 24 * 60 * 60 * 1000)\n      this.setState({resolution: {top: 'year', bottom: 'month'}});\n    // 1y ->\n    else this.setState({resolution: {top: 'year', bottom: 'year'}});\n  }\n\n  /**\n   * Calculates the top bar.\n   * @returns {Object} JSX for top menu bar - based of time format & resolution\n   */\n  getTopBar() {\n    let res = this.state.resolution.top;\n    return this.renderBar({format: this.props.timeFormats.majorLabels[res], type: res});\n  }\n\n  /**\n   * Calculates the bottom bar.\n   * @returns {Object} JSX for bottom menu bar - based of time format & resolution\n   */\n  getBottomBar() {\n    let res = this.state.resolution.bottom;\n    const bottomBar = this.renderBar({format: this.props.timeFormats.minorLabels[res], type: res});\n    this.props.setVerticalGridLines(bottomBar);\n    return bottomBar;\n  }\n\n  /**\n   * Gets the number of pixels per segment of the timebar section (using the resolution)\n   * @param {moment} date The date being rendered. This is used to figure out how many days are in the month\n   * @param {string} resolutionType Timebar section resolution [Year; Month...]\n   * @returns {number} The number of pixels per segment\n   */\n  getPixelIncrement(date, resolutionType, offset = 0) {\n    const {start, end} = this.props;\n    const width = this.props.width - this.props.leftOffset;\n\n    const start_end_ms = end.diff(start, 'milliseconds');\n    const pixels_per_ms = width / start_end_ms;\n    function isLeapYear(year) {\n      return year % 400 === 0 || (year % 100 !== 0 && year % 4 === 0);\n    }\n    const daysInYear = isLeapYear(date.year()) ? 366 : 365;\n    let inc = width;\n    switch (resolutionType) {\n      case 'year':\n        inc = pixels_per_ms * 1000 * 60 * 60 * 24 * (daysInYear - offset);\n        break;\n      case 'month':\n        inc = pixels_per_ms * 1000 * 60 * 60 * 24 * (date.daysInMonth() - offset);\n        break;\n      case 'day':\n        inc = pixels_per_ms * 1000 * 60 * 60 * (24 - offset);\n        break;\n      case 'hour':\n        inc = pixels_per_ms * 1000 * 60 * (60 - offset);\n        break;\n      case 'minute':\n        inc = pixels_per_ms * 1000 * 60 - offset;\n        break;\n      case 'second':\n        inc = pixels_per_ms * 1000 - offset;\n        break;\n      case 'millisecond':\n        inc = pixels_per_ms - offset;\n        break;\n      default:\n        break;\n    }\n    return Math.min(inc, width);\n  }\n\n  /**\n   * Renders an entire segment of the timebar (top or bottom)\n   * @param {string} resolution The resolution to render at [Year; Month...]\n   * @returns {Object[]} A list of sections (making up a segment) to be rendered\n   * @property {string} label The text displayed in the section (usually the date/time)\n   * @property {boolean} isSelected Whether the section is being 'touched' when dragging/resizing\n   * @property {number} size The number of pixels the segment will take up\n   * @property {number|string} key Key for react\n   */\n  renderBar(resolution) {\n    const {start, end, selectedRanges} = this.props;\n    const width = this.props.width - this.props.leftOffset;\n\n    let currentDate = start.clone();\n    let timeIncrements = [];\n    let pixelsLeft = width;\n    let labelSizeLimit = 60;\n\n    function _addTimeIncrement(initialOffset, offsetType, stepFunc) {\n      let offset = null;\n      while (currentDate.isBefore(end) && pixelsLeft > 0) {\n        // if this is the first 'block' it may be cut off at the start\n        if (pixelsLeft === width) {\n          offset = initialOffset;\n        } else {\n          offset = moment.duration(0);\n        }\n        let pixelIncrements = Math.min(\n          this.getPixelIncrement(currentDate, resolution.type, offset.as(offsetType)),\n          pixelsLeft\n        );\n        const labelSize = pixelIncrements < labelSizeLimit ? 'short' : 'long';\n        let label = currentDate.format(resolution.format[labelSize]);\n        let isSelected = _.some(selectedRanges, s => {\n          return (\n            currentDate.isSameOrAfter(s.start.clone().startOf(resolution.type)) &&\n            currentDate.isSameOrBefore(s.end.clone().startOf(resolution.type))\n          );\n        });\n        timeIncrements.push({label, isSelected, size: pixelIncrements, key: pixelsLeft});\n        stepFunc(currentDate, offset);\n        pixelsLeft -= pixelIncrements;\n      }\n    }\n\n    const addTimeIncrement = _addTimeIncrement.bind(this);\n\n    if (resolution.type === 'year') {\n      const offset = moment.duration(currentDate.diff(currentDate.clone().startOf('year')));\n      addTimeIncrement(offset, 'months', (currentDt, offst) => currentDt.subtract(offst).add(1, 'year'));\n    } else if (resolution.type === 'month') {\n      const offset = moment.duration(currentDate.diff(currentDate.clone().startOf('month')));\n      addTimeIncrement(offset, 'days', (currentDt, offst) => currentDt.subtract(offst).add(1, 'month'));\n    } else if (resolution.type === 'day') {\n      const offset = moment.duration(currentDate.diff(currentDate.clone().startOf('day')));\n      addTimeIncrement(offset, 'hours', (currentDt, offst) => currentDt.subtract(offst).add(1, 'days'));\n    } else if (resolution.type === 'hour') {\n      const offset = moment.duration(currentDate.diff(currentDate.clone().startOf('hour')));\n      addTimeIncrement(offset, 'minutes', (currentDt, offst) => currentDt.subtract(offst).add(1, 'hours'));\n    } else if (resolution.type === 'minute') {\n      const offset = moment.duration(currentDate.diff(currentDate.clone().startOf('minute')));\n      addTimeIncrement(offset, 'minutes', (currentDt, offst) => currentDt.subtract(offst).add(1, 'minutes'));\n    } else if (resolution.type === 'second') {\n      const offset = moment.duration(currentDate.diff(currentDate.clone().startOf('second')));\n      addTimeIncrement(offset, 'second', (currentDt, offst) => currentDt.subtract(offst).add(1, 'seconds'));\n    } else if (resolution.type === 'millisecond') {\n      addTimeIncrement(moment.duration(0), 'millisecond', (currentDt, offst) => currentDt.add(1, 'milliseconds'));\n    }\n    return timeIncrements;\n  }\n\n  /**\n   * It renders the header of a column in multi columns mode. Default renderer: props.groupTitleRenderer;\n   * which may be overriden per column: column.headerRender (react element or function).\n   * @param {object} column\n   */\n  renderColumnHeader(column, index) {\n    const columnWidth = column.width ? column.width : this.props.groupOffset;\n    return (\n      <div className=\"rct9k-timebar-group-title\" key={index} style={{width: columnWidth}}>\n        {column.headerRenderer ? (\n          React.isValidElement(column.headerRenderer) ? (\n            column.headerRenderer\n          ) : (\n            <column.headerRenderer />\n          )\n        ) : (\n          <this.props.groupTitleRenderer column={column} />\n        )}\n      </div>\n    );\n  }\n\n  /**\n   * Renders the timebar\n   * @returns {Object} Timebar component\n   */\n  render() {\n    const {cursorTime, tableColumns} = this.props;\n    const {topBarComponent, bottomBarComponent} = this.state;\n    const GroupTitleRenderer = this.props.groupTitleRenderer;\n\n    // Only show the cursor on 1 of the top bar segments\n    // Pick the segment that has the biggest size\n    let topBarCursorKey = null;\n    if (topBarComponent.length > 1 && topBarComponent[1].size > topBarComponent[0].size)\n      topBarCursorKey = topBarComponent[1].key;\n    else if (topBarComponent.length > 0) topBarCursorKey = topBarComponent[0].key;\n\n    return (\n      <div className=\"rct9k-timebar\" style={{width: this.props.width}}>\n        {/* Single column mode */}\n        {(!tableColumns || tableColumns.length == 0) && (\n          <div className=\"rct9k-timebar-group-title\" style={{width: this.props.leftOffset}}>\n            <GroupTitleRenderer />\n          </div>\n        )}\n        {/* Multiple columns mode */}\n        {tableColumns &&\n          tableColumns.length > 0 &&\n          tableColumns.map((column, index) => {\n            return this.renderColumnHeader(column, index);\n          })}\n        <div className=\"rct9k-timebar-outer\" style={{width: this.props.width - this.props.leftOffset}}>\n          <div className=\"rct9k-timebar-inner rct9k-timebar-inner-top\">\n            {_.map(topBarComponent, i => {\n              let topLabel = i.label;\n              if (cursorTime && i.key === topBarCursorKey) {\n                topLabel += ` [${cursorTime}]`;\n              }\n              let className = 'rct9k-timebar-item';\n              if (i.isSelected) className += ' rct9k-timebar-item-selected';\n              return (\n                <span className={className} key={i.key} style={{width: intToPix(i.size)}}>\n                  {topLabel}\n                </span>\n              );\n            })}\n          </div>\n          <div className=\"rct9k-timebar-inner rct9k-timebar-inner-bottom\">\n            {_.map(bottomBarComponent, i => {\n              let className = 'rct9k-timebar-item';\n              if (i.isSelected) className += ' rct9k-timebar-item-selected';\n              return (\n                <span className={className} key={i.key} style={{width: intToPix(i.size)}}>\n                  {i.label}\n                </span>\n              );\n            })}\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nTimebar.propTypes = {\n  /**\n   * @type { any }\n   */\n  cursorTime: PropTypes.any,\n\n  /**\n   * As e.g. @see Timeline.props.groupTitleRenderer\n   * @type { Function }\n   */\n  groupTitleRenderer: PropTypes.func,\n\n  /**\n   * Start of the displayed interval, as moment object.\n   * @type { object }\n   */\n  start: PropTypes.object.isRequired,\n\n  /**\n   * End of the displayed interval, as moment object.\n   * @type { object }\n   */\n  end: PropTypes.object.isRequired,\n\n  /**\n   * Total width of the timeline (gantt), mandatory field.\n   * @type { number }\n   */\n  width: PropTypes.number.isRequired,\n\n  /**\n   * The left side offset, this offset is subtracted from the total width of the timeline\n   * to obtain the width of the timebar.\n   * @type { number }\n   */\n  leftOffset: PropTypes.number,\n\n  /**\n   * The time unit for the top timebar.\n   * @type { string }\n   */\n  top_resolution: PropTypes.string,\n\n  /**\n   * The time unit for the bottom timebar.\n   * @type { string }\n   */\n  bottom_resolution: PropTypes.string,\n\n  /**\n   * @type { Array.<object> }\n   */\n  selectedRanges: PropTypes.arrayOf(PropTypes.object), // [start: moment ,end: moment (end)]\n\n  /**\n   * Formats for each time unit (@see defaultTimebarFormat)\n   * @type { object }\n   */\n  timeFormats: PropTypes.object,\n\n  /**\n   * @type { Array.<Column> }\n   */\n  tableColumns: PropTypes.arrayOf(PropTypes.object),\n\n  /**\n   * It's passed by parent. The `vertical grid` uses the same intervals as the bottom timebar, it is redundant to calculated them again.\n   * This callback passes these intervals to parent.\n   * @type { Function }\n   */\n  setVerticalGridLines: PropTypes.func\n};\n\nTimebar.defaultProps = {\n  selectedRanges: [],\n  groupTitleRenderer: ColumnHeaderRenderer,\n  leftOffset: 0,\n  timeFormats: defaultTimebarFormat,\n  tableColumns: [],\n  top_resolution: undefined,\n  bottom_resolution: undefined,\n  leftOffset: undefined,\n  cursorTime: undefined\n};\n",
    "static": true,
    "longname": "/home/poweruser/git/react-timeline-10000/src/components/timebar.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 137,
    "kind": "class",
    "name": "Timebar",
    "memberof": "src/components/timebar.js",
    "static": true,
    "longname": "src/components/timebar.js~Timebar",
    "access": "public",
    "export": true,
    "importPath": "@crispico/react-timeline-10000/src/components/timebar.js",
    "importStyle": "Timebar",
    "description": "Timebar component - displays the current time on top of the timeline.",
    "lineNumber": 16,
    "interface": false,
    "extends": [
      "*"
    ]
  },
  {
    "__docId__": 138,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/components/timebar.js~Timebar",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/timebar.js~Timebar#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true
  },
  {
    "__docId__": 139,
    "kind": "member",
    "name": "state",
    "memberof": "src/components/timebar.js~Timebar",
    "static": false,
    "longname": "src/components/timebar.js~Timebar#state",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "{\"topBarComponent\": *, \"bottomBarComponent\": *, \"resolution\": *}"
      ]
    }
  },
  {
    "__docId__": 142,
    "kind": "method",
    "name": "componentWillMount",
    "memberof": "src/components/timebar.js~Timebar",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/timebar.js~Timebar#componentWillMount",
    "access": "public",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 143,
    "kind": "method",
    "name": "componentWillReceiveProps",
    "memberof": "src/components/timebar.js~Timebar",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/timebar.js~Timebar#componentWillReceiveProps",
    "access": "public",
    "description": "On new props we check if a resolution is given, and if not we guess one",
    "lineNumber": 36,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "nextProps",
        "description": "Props coming in"
      }
    ],
    "return": null
  },
  {
    "__docId__": 144,
    "kind": "method",
    "name": "componentDidUpdate",
    "memberof": "src/components/timebar.js~Timebar",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/timebar.js~Timebar#componentDidUpdate",
    "access": "public",
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "params": [
      {
        "name": "prevProps",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 145,
    "kind": "method",
    "name": "guessResolution",
    "memberof": "src/components/timebar.js~Timebar",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/timebar.js~Timebar#guessResolution",
    "access": "public",
    "description": "Attempts to guess the resolution of the top and bottom halves of the timebar based on the viewable date range.\nSets resolution to state.",
    "lineNumber": 66,
    "params": [
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "start",
        "description": "Start date for the timebar"
      },
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "end",
        "description": "End date for the timebar"
      }
    ],
    "return": null
  },
  {
    "__docId__": 146,
    "kind": "method",
    "name": "getTopBar",
    "memberof": "src/components/timebar.js~Timebar",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/timebar.js~Timebar#getTopBar",
    "access": "public",
    "description": "Calculates the top bar.",
    "lineNumber": 93,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object} JSX for top menu bar - based of time format & resolution"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "JSX for top menu bar - based of time format & resolution"
    },
    "params": []
  },
  {
    "__docId__": 147,
    "kind": "method",
    "name": "getBottomBar",
    "memberof": "src/components/timebar.js~Timebar",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/timebar.js~Timebar#getBottomBar",
    "access": "public",
    "description": "Calculates the bottom bar.",
    "lineNumber": 102,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object} JSX for bottom menu bar - based of time format & resolution"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "JSX for bottom menu bar - based of time format & resolution"
    },
    "params": []
  },
  {
    "__docId__": 148,
    "kind": "method",
    "name": "getPixelIncrement",
    "memberof": "src/components/timebar.js~Timebar",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/timebar.js~Timebar#getPixelIncrement",
    "access": "public",
    "description": "Gets the number of pixels per segment of the timebar section (using the resolution)",
    "lineNumber": 115,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} The number of pixels per segment"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": "The date being rendered. This is used to figure out how many days are in the month"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "resolutionType",
        "description": "Timebar section resolution [Year; Month...]"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The number of pixels per segment"
    }
  },
  {
    "__docId__": 149,
    "kind": "method",
    "name": "renderBar",
    "memberof": "src/components/timebar.js~Timebar",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/timebar.js~Timebar#renderBar",
    "access": "public",
    "description": "Renders an entire segment of the timebar (top or bottom)",
    "lineNumber": 163,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object[]} A list of sections (making up a segment) to be rendered"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "resolution",
        "description": "The resolution to render at [Year; Month...]"
      }
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "label",
        "description": "The text displayed in the section (usually the date/time)"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "isSelected",
        "description": "Whether the section is being 'touched' when dragging/resizing"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "size",
        "description": "The number of pixels the segment will take up"
      },
      {
        "nullable": null,
        "types": [
          "number",
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Key for react"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object[]"
      ],
      "spread": false,
      "description": "A list of sections (making up a segment) to be rendered"
    }
  },
  {
    "__docId__": 150,
    "kind": "method",
    "name": "renderColumnHeader",
    "memberof": "src/components/timebar.js~Timebar",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/timebar.js~Timebar#renderColumnHeader",
    "access": "public",
    "description": "It renders the header of a column in multi columns mode. Default renderer: props.groupTitleRenderer;\nwhich may be overriden per column: column.headerRender (react element or function).",
    "lineNumber": 230,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "column",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 151,
    "kind": "method",
    "name": "render",
    "memberof": "src/components/timebar.js~Timebar",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/components/timebar.js~Timebar#render",
    "access": "public",
    "description": "Renders the timebar",
    "lineNumber": 251,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object} Timebar component"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Timebar component"
    },
    "params": []
  },
  {
    "__docId__": 152,
    "kind": "file",
    "name": "src/consts/timebarConsts.js",
    "content": "/**\n * Default timebar format\n */\nexport const timebarFormat = {\n  majorLabels: {\n    millisecond: {\n      short: 'SSS', //001\n      long: 'mm:ss.SSS' //01:10.001\n    },\n    second: {\n      short: 'ss', //10\n      long: 'HH:mm:ss' //01:10\n    },\n    minute: {\n      short: 'mm', //01\n      long: 'HH:mm' //12:01\n    },\n    hour: {\n      short: 'HH', //13\n      long: 'HH:mm' //13:00\n    },\n    day: {\n      short: 'Do', //1st\n      long: 'ddd, LL' //Sun, July 3, 2018\n    },\n    month: {\n      short: 'MMM', //Jan\n      long: 'MMMM YYYY' //January 2018\n    },\n    year: {\n      short: 'YYYY', //2018\n      long: 'YYYY' //2018\n    }\n  },\n  minorLabels: {\n    millisecond: {\n      short: 'SSS', //001\n      long: 'mm:ss.SSS' //01:10.001\n    },\n    second: {\n      short: 'ss', //10\n      long: 'HH:mm:ss' //01:10\n    },\n    minute: {\n      short: 'mm', //01\n      long: 'HH:mm' //12:01\n    },\n    hour: {\n      short: 'HH', //13\n      long: 'HH:mm' //13:00\n    },\n    day: {\n      short: 'D', //1\n      long: 'ddd Do' //Sun 1st\n    },\n    month: {\n      short: 'MM', //02\n      long: 'MMMM' //January\n    },\n    year: {\n      short: 'YYYY', //2018\n      long: 'YYYY' //2018\n    }\n  }\n};\n",
    "static": true,
    "longname": "/home/poweruser/git/react-timeline-10000/src/consts/timebarConsts.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 153,
    "kind": "variable",
    "name": "timebarFormat",
    "memberof": "src/consts/timebarConsts.js",
    "static": true,
    "longname": "src/consts/timebarConsts.js~timebarFormat",
    "access": "public",
    "export": true,
    "importPath": "@crispico/react-timeline-10000/src/consts/timebarConsts.js",
    "importStyle": "{timebarFormat}",
    "description": "Default timebar format",
    "lineNumber": 4,
    "type": {
      "types": [
        "{\"majorLabels\": *, \"minorLabels\": *}"
      ]
    }
  },
  {
    "__docId__": 154,
    "kind": "file",
    "name": "src/index.js",
    "content": "'use strict';\n\nexport {default as Timeline} from './timeline';\nexport * from './types';\n\n// components\nexport {default as Timebar} from './components/timebar';\nexport {default as TimelineBody} from './components/body';\nexport {default as ItemRenderer} from './components/ItemRenderer';\nexport {GroupRenderer} from './components/GroupRenderer';\nexport {ColumnHeaderRenderer} from './components/ColumnRenderer';\nexport {Marker} from './components/Marker';\nexport {default as Selectbox} from './components/selector';\nexport {BackgroundLayer} from './components/BackgroundLayer';\nexport {HighlightedInterval} from './components/HighlightedInterval';\n\n// consts\nexport {timebarFormat} from './consts/timebarConsts';\n\n// utils\nexport * from './utils/commonUtils';\nexport * from './utils/itemUtils';\nexport * from './utils/timeUtils';\n",
    "static": true,
    "longname": "/home/poweruser/git/react-timeline-10000/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 155,
    "kind": "file",
    "name": "src/setupTests.js",
    "content": "import Enzyme from 'enzyme';\nimport Adapter from 'enzyme-adapter-react-16';\nimport {expect} from 'chai';\n\nimport jsdom from 'jsdom';\n\nlet consoleEr = '';\nlet consoleWa = '';\n\nfunction setUpDomEnvironment() {\n  const {JSDOM} = jsdom;\n  const dom = new JSDOM('<!doctype html><html><body></body></html>', {url: 'http://localhost/'});\n  const {window} = dom;\n\n  global.window = window;\n  global.document = window.document;\n  global.navigator = {\n    userAgent: 'node.js'\n  };\n  global.console.error = e => (consoleEr += e);\n  global.console.warn = e => (consoleWa += e);\n  global.console.warning = e => (consoleWa += e);\n  copyProps(window, global);\n}\n\nfunction copyProps(src, target) {\n  const props = Object.getOwnPropertyNames(src)\n    .filter(prop => typeof target[prop] === 'undefined')\n    .map(prop => Object.getOwnPropertyDescriptor(src, prop));\n  Object.defineProperties(target, props);\n}\n\nbeforeEach(function() {\n  consoleEr = '';\n  consoleWa = '';\n});\nafterEach(function() {\n  expect(consoleEr).to.equal('');\n  expect(consoleWa).to.equal('');\n});\nsetUpDomEnvironment();\nEnzyme.configure({adapter: new Adapter()});\n",
    "static": true,
    "longname": "/home/poweruser/git/react-timeline-10000/src/setupTests.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 156,
    "kind": "variable",
    "name": "consoleEr",
    "memberof": "src/setupTests.js",
    "static": true,
    "longname": "src/setupTests.js~consoleEr",
    "access": "public",
    "export": false,
    "importPath": "@crispico/react-timeline-10000/src/setupTests.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 157,
    "kind": "variable",
    "name": "consoleWa",
    "memberof": "src/setupTests.js",
    "static": true,
    "longname": "src/setupTests.js~consoleWa",
    "access": "public",
    "export": false,
    "importPath": "@crispico/react-timeline-10000/src/setupTests.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 158,
    "kind": "function",
    "name": "setUpDomEnvironment",
    "memberof": "src/setupTests.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setupTests.js~setUpDomEnvironment",
    "access": "public",
    "export": false,
    "importPath": "@crispico/react-timeline-10000/src/setupTests.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "params": [],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 159,
    "kind": "function",
    "name": "copyProps",
    "memberof": "src/setupTests.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setupTests.js~copyProps",
    "access": "public",
    "export": false,
    "importPath": "@crispico/react-timeline-10000/src/setupTests.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "params": [
      {
        "name": "src",
        "types": [
          "*"
        ]
      },
      {
        "name": "target",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 160,
    "kind": "file",
    "name": "src/stories/StorybookUtils.js",
    "content": "/**\n * It returns an URI to API Doc story.\n * Furthermore, it receives a subpath to reference a component/method from\n * API documentation.\n *\n * @param {string} subpath\n */\nexport const encodeApiDocURIForSubpath = subpath => {\n  return '?path=/docs/api-doc--page&subpath=' + encodeURIComponent(subpath);\n};\n\nexport const parametersDocPage = {\n  viewMode: 'docs',\n  previewTabs: {\n    'storybook/docs/panel': {\n      hidden: false\n    },\n    canvas: {\n      hidden: true\n    }\n  }\n};\n",
    "static": true,
    "longname": "/home/poweruser/git/react-timeline-10000/src/stories/StorybookUtils.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 161,
    "kind": "function",
    "name": "encodeApiDocURIForSubpath",
    "memberof": "src/stories/StorybookUtils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/stories/StorybookUtils.js~encodeApiDocURIForSubpath",
    "access": "public",
    "export": true,
    "importPath": "@crispico/react-timeline-10000/src/stories/StorybookUtils.js",
    "importStyle": "{encodeApiDocURIForSubpath}",
    "description": "It returns an URI to API Doc story.\nFurthermore, it receives a subpath to reference a component/method from\nAPI documentation.",
    "lineNumber": 8,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "subpath",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 162,
    "kind": "variable",
    "name": "parametersDocPage",
    "memberof": "src/stories/StorybookUtils.js",
    "static": true,
    "longname": "src/stories/StorybookUtils.js~parametersDocPage",
    "access": "public",
    "export": true,
    "importPath": "@crispico/react-timeline-10000/src/stories/StorybookUtils.js",
    "importStyle": "{parametersDocPage}",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "{\"viewMode\": string, \"previewTabs\": *}"
      ]
    }
  },
  {
    "__docId__": 163,
    "kind": "file",
    "name": "src/stories/backgroundLayer/BackgroundLayerScenarios.js",
    "content": "export const backgroundLayerScenarios = {\n  // BackgroundLayer\n  highlightWeekends: 'PROPERTY highlightWeekends',\n  highlightWeekendsClassName: 'PROPERTY highlightWeekendsClassName',\n  nowMarker: 'PROPERTY nowMarker',\n  nowMarkerClassName: 'PROPERTY nowMarkerClassName',\n  verticalGrid: 'PROPERTY verticalGrid',\n  verticalGridClassName: 'PROPERTY verticalGridClassName',\n  markers: 'PROPERTY markers',\n  highlightedIntervals: 'PROPERTY highlightedIntervals',\n\n  // HighlightedInterval\n  highlightedIntervalClassName: 'PROPERTY className FOR HighlightedInterval',\n\n  // Marker\n  classNameForMarker: 'PROPERTY className FOR Marker'\n};\n",
    "static": true,
    "longname": "/home/poweruser/git/react-timeline-10000/src/stories/backgroundLayer/BackgroundLayerScenarios.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 164,
    "kind": "variable",
    "name": "backgroundLayerScenarios",
    "memberof": "src/stories/backgroundLayer/BackgroundLayerScenarios.js",
    "static": true,
    "longname": "src/stories/backgroundLayer/BackgroundLayerScenarios.js~backgroundLayerScenarios",
    "access": "public",
    "export": true,
    "importPath": "@crispico/react-timeline-10000/src/stories/backgroundLayer/BackgroundLayerScenarios.js",
    "importStyle": "{backgroundLayerScenarios}",
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "type": {
      "types": [
        "{\"highlightWeekends\": string, \"highlightWeekendsClassName\": string, \"nowMarker\": string, \"nowMarkerClassName\": string, \"verticalGrid\": string, \"verticalGridClassName\": string, \"markers\": string, \"highlightedIntervals\": string, \"highlightedIntervalClassName\": string, \"classNameForMarker\": string}"
      ]
    }
  },
  {
    "__docId__": 165,
    "kind": "file",
    "name": "src/timeline.js",
    "content": "'use strict';\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport ReactDOM from 'react-dom';\nimport {Grid, AutoSizer} from 'react-virtualized';\n\nimport moment from 'moment';\nimport interact from 'interactjs';\nimport _ from 'lodash';\nimport {Column, Group, InteractOption, Item, RowLayer} from './index';\n\nimport {pixToInt, intToPix} from './utils/commonUtils';\nimport {\n  adjustRowTopPositionToViewport,\n  rowItemsRenderer,\n  rowLayerRenderer,\n  getNearestRowNumber,\n  getNearestRowObject,\n  getMaxOverlappingItems,\n  getTrueBottom,\n  getVerticalMarginBorder,\n  getRowObjectRowNumber\n} from './utils/itemUtils';\nimport {\n  timeSnap,\n  getTimeAtPixel,\n  getPixelAtTime,\n  getSnapPixelFromDelta,\n  pixelsPerMillisecond,\n  convertDateToMoment,\n  convertMomentToDateType\n} from './utils/timeUtils';\nimport Timebar from './components/timebar';\nimport SelectBox from './components/selector';\nimport ItemRenderer from './components/ItemRenderer';\nimport {GroupRenderer} from './components/GroupRenderer';\nimport TimelineBody from './components/body';\nimport {Marker} from './components/Marker';\n\n// startsWith polyfill for IE11 support\nimport 'core-js/fn/string/starts-with';\n\nconst SINGLE_COLUMN_LABEL_PROPERTY = 'title';\nconst EMPTY_GROUP_KEY = 'empty-group';\nconst GRID_CLASS = componentId => `.rct9k-id-${componentId} .ReactVirtualized__Grid`;\n\n/**\n * Timeline class\n * @extends React.Component<Timeline.propTypes>\n * @extends React.Component<Timeline.propTypes>\n */\nexport default class Timeline extends React.Component {\n  /**\n   * @type {object}\n   */\n  static TIMELINE_MODES = Object.freeze({\n    SELECT: 1,\n    DRAG: 2,\n    RESIZE: 4\n  });\n\n  static propTypes = {\n    /**\n     * The rows (aka groups) of the Timeline.\n     *\n     * `id` is mandatory, it should: be numeric, start with 0 and have consecutive values.\n     *\n     * `title` is used displayed by the default renderer. This is optional, i.e. you may use this and/or other fields, provided\n     * you have a custom renderer.\n     * @type { Array.<Group> }\n     */\n    groups: PropTypes.arrayOf(\n      PropTypes.shape({\n        id: PropTypes.number.isRequired,\n        title: PropTypes.string\n      })\n    ).isRequired,\n\n    /**\n     * The segments (aka items). An item is associated with a row. Hence `row` is mandatory, pointing to an `id` of a row (group).\n     *\n     * `key` is also needed and has the React standard meaning.\n     *\n     * `start` and `stop` are dates (numeric/millis or moment objects, cf. `useMoment`).\n     *\n     * All the props of an item are copied to the props of the item renderer. E.g. `<ItemRenderer {...props.itemRendererDefaultProps } {...item}` ... />. See its\n     * doc, to see what props are known/rendered by `ItemRenderer` (such as `title`, `color`, etc.). The item renderer can be\n     * customized using the `itemRenderer` prop.\n     * @type { Array.<Item> }\n     */\n    items: PropTypes.arrayOf(\n      PropTypes.shape({\n        key: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,\n        row: PropTypes.number.isRequired,\n        // start and end are not required because getStartFromItem() and getEndFromItem() functions\n        // are being used and they can be overriden to use other fields\n        start: PropTypes.oneOfType([PropTypes.number, PropTypes.object]),\n        end: PropTypes.oneOfType([PropTypes.number, PropTypes.object])\n      })\n    ).isRequired,\n\n    /**\n     * @type { Array.<number> }\n     */\n    selectedItems: PropTypes.arrayOf(PropTypes.number),\n\n    /**\n     * The component that is the item (segment) renderer. You can change the default component (i.e. `ItemRenderer`). We\n     * recommend to create a subclass of it, rather than creating one from scratch.\n     * @type { Function }\n     */\n    itemRenderer: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),\n\n    /**\n     * This is used more or less like this:\n     *\n     * ```jsx\n     * <ItemRenderer {...props.itemRendererDefaultProps } {...item} ... />\n     * ```\n     *\n     * This is the way to go if you want to set a property for all segments (items). E.g. `color`. Take a look at the props\n     * of `ItemRenderer` to see what are the possible options. If you override the item renderer, and it will accept additional\n     * props, you can of course specify them here.\n     * @type { object }\n     */\n    itemRendererDefaultProps: PropTypes.object,\n\n    /**\n     * The height of the items (segments) in pixels, it is used to calculate the height of the row.\n     *\n     * Items (segments) that are overlapping are displayed one below the other. In this case, the height of the row will\n     * be the maximum number of overlapping items (segments) multiplied by `itemHeight`.\n     * @type { number }\n     */\n    itemHeight: PropTypes.number,\n\n    /**\n     * List of layers that will be rendered for a row.\n     * @type { Array.<RowLayer> }\n     */\n    rowLayers: PropTypes.arrayOf(\n      PropTypes.shape({\n        // start and end are not required because getStartFromItem() and getEndFromItem() functions\n        // are being used and they can be overriden to use other fields\n        start: PropTypes.oneOfType([PropTypes.object, PropTypes.number]),\n        end: PropTypes.oneOfType([PropTypes.object, PropTypes.number]),\n        rowNumber: PropTypes.number.isRequired,\n        style: PropTypes.object.isRequired\n      })\n    ),\n\n    /**\n     * Start of the displayed interval, as date (numeric/millis or moment object, cf. `useMoment`).\n     * @type {number | object}\n     */\n    startDate: PropTypes.oneOfType([PropTypes.number, PropTypes.object]).isRequired,\n\n    /**\n     * End of the displayed interval, as date (numeric/millis or moment object, cf. `useMoment`).\n     * @type { number | object }\n     */\n    endDate: PropTypes.oneOfType([PropTypes.number, PropTypes.object]).isRequired,\n\n    /** If `false`, then when you \"talk\" dates/times to the Timeline, then you use\n     * plain timestamps (i.e. number of millis, e.g. `new Date().valueOf()`). And this everywhere where\n     * a date/time is needed (e.g. for an item, for global start/end, etc.). This is the **recommended** (and the default) way to go, especially if you use Redux.\n     *\n     * NOTE 1: the Timeline still uses \"moment\" internally. And this because it was quicker to refactor this way.\n     * This may change in the future, if we find reasons and time to refactor more.\n     *\n     * NOTE 2: The upstream repo, had this `true` by default, in order to maintain backward compatibility. But we discovered that w/ `false`, the component\n     * actually works both w/ timestamps AND moment objects. And this is because we convert using `moment(date)`, which works in the 2 cases. Obviously it's\n     * not a good idea to mix the date types, one of the reasons being that maybe in the future moment won't be used internally any more.\n     *\n     * @type { boolean }\n     */\n    useMoment: PropTypes.bool,\n\n    /**\n     * Single column mode: the width of the column.\n     * Multiple columns mode: the default width of the columns (if column.width is not configured), which may be overridden on a per column basis.\n     * @type { number }\n     */\n    groupOffset: PropTypes.number.isRequired,\n\n    /**\n     * The columns that will be rendered using data from groups.\n     * @type { Array.<Column> }\n     */\n    tableColumns: PropTypes.arrayOf(\n      PropTypes.shape({\n        /**\n         * The default renderer for a cell is props.groupRenderer that renders labelProperty from group.\n         * The renderer for a column can be overriden using cellRenderer. cellRenderer can be a React element\n         * or a function or a class component that generates a React element.\n         */\n        labelProperty: PropTypes.string,\n        cellRenderer: PropTypes.oneOfType([PropTypes.func, PropTypes.element]),\n        // The default renderer for a header is props.groupTitleRenderer that renders headerLabel.\n        // The renderer for a header column can be overriden using headerRenderer. headerRenderer can be a React element\n        // or a function or a class component that generates a React element.\n        headerLabel: PropTypes.string,\n        headerRenderer: PropTypes.oneOfType([PropTypes.func, PropTypes.element]),\n\n        /**\n         * Width of the column in px.\n         */\n        width: PropTypes.number\n      })\n    ),\n\n    /**\n     * Single column mode: the renderer of a cell.\n     * Multiple columns mode: the default renderer of a cell, which may be overridden on a per column basis.\n     * @type { Function }\n     */\n    groupRenderer: PropTypes.func,\n\n    /**\n     * Single column mode: the renderer of the header cell.\n     * Multiple columns mode: the default renderer of a header cell, which may be overridden on a per column basis.\n     * @type { Function }\n     */\n    groupTitleRenderer: PropTypes.func,\n\n    /**\n     * @type { number }\n     */\n    snap: PropTypes.number, //like snapMinutes, but for seconds; couldn't get it any lower because the pixels are not calculated correctly\n\n    /**\n     * @type { number }\n     */\n    snapMinutes: PropTypes.number,\n\n    /**\n     * Shows the cursor time in the timebar and a red marker in the grid indicating the cursor time.\n     * @type { boolean }\n     */\n    showCursorTime: PropTypes.bool,\n\n    /**\n     * The format of the cursor time displayed in the timebar.\n     * @type { string }\n     */\n    cursorTimeFormat: PropTypes.string,\n\n    /**\n     * A unique key to identify the component. Only needed when 2 grids are mounted.\n     * @type { string }\n     */\n    componentId: PropTypes.string,\n\n    /**\n     * @type { number }\n     */\n    timelineMode: PropTypes.number,\n\n    /**\n     * @type { object }\n     */\n    timebarFormat: PropTypes.object,\n\n    /**\n     * @type { string }\n     */\n    bottomResolution: PropTypes.string,\n\n    /**\n     * @type { string }\n     */\n    topResolution: PropTypes.string,\n\n    /**\n     * If true timeline will try to minimize re-renders . Set to false if items don't show up/update on prop change.\n     * @type { boolean }\n     */\n    shallowUpdateCheck: PropTypes.bool,\n\n    /**\n     * Function called when shallowUpdateCheck==true. If returns true the timeline will be redrawn.\n     * If false the library will decide if redrawing is required.\n     * @type { Function }\n     */\n    forceRedrawFunc: PropTypes.func,\n\n    /**\n     * @type { InteractOption }\n     */\n    interactOptions: PropTypes.shape({\n      draggable: PropTypes.object,\n      pointerEvents: PropTypes.object,\n      // TODO: this doesn't seem used; originally it was w/ \"required\"; I removed this to avoid warnings in console\n      resizable: PropTypes.object\n    }),\n\n    /**\n     * @type { Function }\n     */\n    onItemClick: PropTypes.func,\n\n    /**\n     * @type { Function }\n     */\n    onItemDoubleClick: PropTypes.func,\n\n    /**\n     * @type { Function }\n     */\n    onItemContext: PropTypes.func,\n\n    /**\n     * @type { Function }\n     */\n    onInteraction: PropTypes.func,\n\n    /**\n     * @type { Function }\n     */\n    onRowClick: PropTypes.func,\n\n    /**\n     * @type { Function }\n     */\n    onRowContext: PropTypes.func,\n\n    /**\n     * @type { Function }\n     */\n    onRowDoubleClick: PropTypes.func,\n\n    /**\n     * @type { Function }\n     */\n    onItemHover: PropTypes.func,\n\n    /**\n     * @type { Function }\n     */\n    onItemLeave: PropTypes.func,\n\n    /**\n     * This property should be used like this:\n     *\n     * ```jsx\n     * <Timeline backgroundLayer={<BackgroundLayer ... /> ... />\n     * ```\n     * @type { JSX.Element }\n     */\n    backgroundLayer: PropTypes.object\n  };\n\n  static defaultProps = {\n    rowLayers: [],\n    groupOffset: 150,\n    itemHeight: 40,\n    snapMinutes: 15,\n    cursorTimeFormat: 'D MMM YYYY HH:mm',\n    componentId: 'r9k1',\n    showCursorTime: true,\n    groupRenderer: GroupRenderer,\n    itemRenderer: ItemRenderer,\n    timelineMode: Timeline.TIMELINE_MODES.SELECT | Timeline.TIMELINE_MODES.DRAG | Timeline.TIMELINE_MODES.RESIZE,\n    // in rtl9k\n    // shallowUpdateCheck: false,\n    shallowUpdateCheck: true,\n    forceRedrawFunc: null,\n    onItemHover() {},\n    onItemLeave() {},\n    interactOptions: {},\n    itemStyle: {},\n    // in rtl9k:\n    // useMoment: true,\n    useMoment: false,\n    tableColumns: [],\n    selectedItems: [],\n    snap: undefined,\n    groupTitleRenderer: undefined,\n    timebarFormat: undefined,\n    bottomResolution: undefined,\n    topResolution: undefined,\n    onItemClick() {},\n    onItemDoubleClick() {},\n    onItemContext() {},\n    onRowClick() {},\n    onRowContext() {},\n    onRowDoubleClick() {},\n    onInteraction() {},\n    itemRendererDefaultProps: {},\n    backgroundLayer: null\n  };\n\n  /**\n   * The types of interactions - see {@link onInteraction}\n   */\n  static changeTypes = {\n    resizeStart: 'resizeStart',\n    resizeEnd: 'resizeEnd',\n    dragEnd: 'dragEnd',\n    dragStart: 'dragStart',\n    itemsSelected: 'itemsSelected',\n    snappedMouseMove: 'snappedMouseMove'\n  };\n\n  /**\n   * Checks if the given bit is set in the given mask\n   * @param {number} bit Bit to check\n   * @param {number} mask Mask to check against\n   * @returns {boolean} True if bit is set; else false\n   */\n  static isBitSet(bit, mask) {\n    return (bit & mask) === bit;\n  }\n\n  /**\n   * Alias for no op function\n   */\n  static no_op = () => {};\n\n  constructor(props) {\n    super(props);\n    this.selecting = false;\n    this.state = {selection: [], cursorTime: null, groups: this.props.groups, verticalGridLines: []};\n\n    // These functions need to be bound because they are passed as parameters.\n    // getStartFromItem and getEndFromItem are used in rowItemsRenderer function\n    // to obtain the start and end of the rendered items.\n    this.getStartFromItem = this.getStartFromItem.bind(this);\n    this.getEndFromItem = this.getEndFromItem.bind(this);\n    // getStartFromRowLayer and getEndFromRowLayer are used in rowLayerRenderer\n    // to obtain the start and end of the rendered row layers.\n    this.getStartFromRowLayer = this.getStartFromRowLayer.bind(this);\n    this.getEndFromRowLayer = this.getEndFromRowLayer.bind(this);\n\n    this.setTimeMap(this.props.items);\n\n    this.cellRenderer = this.cellRenderer.bind(this);\n    this.rowHeight = this.rowHeight.bind(this);\n    this.setTimeMap = this.setTimeMap.bind(this);\n    this.getItem = this.getItem.bind(this);\n    this.changeGroup = this.changeGroup.bind(this);\n    this.setSelection = this.setSelection.bind(this);\n    this.clearSelection = this.clearSelection.bind(this);\n    this.getTimelineWidth = this.getTimelineWidth.bind(this);\n    this.itemFromElement = this.itemFromElement.bind(this);\n    this.updateDimensions = this.updateDimensions.bind(this);\n    this.grid_ref_callback = this.grid_ref_callback.bind(this);\n    this.select_ref_callback = this.select_ref_callback.bind(this);\n    this.throttledMouseMoveFunc = _.throttle(this.throttledMouseMoveFunc.bind(this), 20);\n    this.mouseMoveFunc = this.mouseMoveFunc.bind(this);\n    this.getCursor = this.getCursor.bind(this);\n    this.setVerticalGridLines = this.setVerticalGridLines.bind(this);\n\n    const canSelect = Timeline.isBitSet(Timeline.TIMELINE_MODES.SELECT, this.props.timelineMode);\n    const canDrag = Timeline.isBitSet(Timeline.TIMELINE_MODES.DRAG, this.props.timelineMode);\n    const canResize = Timeline.isBitSet(Timeline.TIMELINE_MODES.RESIZE, this.props.timelineMode);\n    this.setUpDragging(canSelect, canDrag, canResize);\n  }\n\n  componentDidMount() {\n    window.addEventListener('resize', this.updateDimensions);\n  }\n\n  componentWillReceiveProps(nextProps) {\n    this.setTimeMap(\n      nextProps.items,\n      convertDateToMoment(nextProps.startDate, nextProps.useMoment),\n      convertDateToMoment(nextProps.endDate, nextProps.useMoment),\n      nextProps.useMoment\n    );\n    this.fillInTimelineWithEmptyRows(nextProps.groups);\n    // @TODO\n    // investigate if we need this, only added to refresh the grid\n    // when double click -> add an item\n    this.refreshGrid();\n  }\n\n  componentWillUnmount() {\n    if (this._itemInteractable) this._itemInteractable.unset();\n    if (this._selectRectangleInteractable) this._selectRectangleInteractable.unset();\n\n    window.removeEventListener('resize', this.updateDimensions);\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    const {timelineMode, selectedItems} = this.props;\n    const selectionChange = !_.isEqual(prevProps.selectedItems, selectedItems);\n    const timelineModeChange = !_.isEqual(prevProps.timelineMode, timelineMode);\n\n    if (timelineModeChange || selectionChange) {\n      const canSelect = Timeline.isBitSet(Timeline.TIMELINE_MODES.SELECT, timelineMode);\n      const canDrag = Timeline.isBitSet(Timeline.TIMELINE_MODES.DRAG, timelineMode);\n      const canResize = Timeline.isBitSet(Timeline.TIMELINE_MODES.RESIZE, timelineMode);\n      this.setUpDragging(canSelect, canDrag, canResize);\n    }\n  }\n\n  /**\n   * Start of the displayed interval (as moment object).\n   *\n   * @return {moment}\n   */\n  getStartDate() {\n    return convertDateToMoment(this.props.startDate, this.props.useMoment);\n  }\n\n  /**\n   * End of the displayed interval (as moment object).\n   *\n   * @return {moment}\n   */\n  getEndDate() {\n    return convertDateToMoment(this.props.endDate, this.props.useMoment);\n  }\n\n  /**\n   * Start of the segment (item).\n   *\n   * @param {Item} item The segment (item).\n   * @param {boolean} useMoment This parameter is necessary because this method is also called when\n   * the component receives new props. Default value: `this.props.useMoment`.\n   * @return {moment}\n   */\n  getStartFromItem(item, useMoment = this.props.useMoment) {\n    return convertDateToMoment(item.start, useMoment);\n  }\n\n  /**\n   * It assigns `newDateAsMoment` to the start of the segment (item), but first it converts it\n   * to moment or number/milliseconds according to `useMoment`.\n   *\n   * @param {Item} item The segment (item).\n   * @param {moment} newDateAsMoment\n   * @return {void}\n   */\n  setStartToItem(item, newDateAsMoment) {\n    item.start = convertMomentToDateType(newDateAsMoment, this.props.useMoment);\n  }\n\n  /**\n   * End of the segment (item).\n   *\n   * @param {Item} item The segment (item).\n   * @param {boolean} useMoment This parameter is necessary because this method is also called when\n   * the component receives new props. Default value: `this.props.useMoment`.\n   * @return {moment}\n   */\n  getEndFromItem(item, useMoment = this.props.useMoment) {\n    return convertDateToMoment(item.end, useMoment);\n  }\n\n  /**\n   * It assigns `newDateAsMoment` to the end of the segment (item), but first it converts it\n   * to moment or number/milliseconds according to `useMoment`.\n   *\n   * @param {Item} item The segment (item).\n   * @param {moment} newDateAsMoment\n   * @return {void}\n   */\n  setEndToItem(item, newDateAsMoment) {\n    item.end = convertMomentToDateType(newDateAsMoment, this.props.useMoment);\n  }\n\n  /**\n   * Start of the layer as a moment object.\n   *\n   * @param {RowLayer} layer\n   * @return {moment}\n   */\n  getStartFromRowLayer(layer) {\n    return convertDateToMoment(layer.start, this.props.useMoment);\n  }\n\n  /**\n   * It assigns `newDateAsMoment` to the start of the segment (item), but first it converts it\n   * to moment or number/milliseconds according to `useMoment`.\n   *\n   * @param {RowLayer} layer\n   * @param {moment} newDateAsMoment\n   */\n  setStartToRowLayer(layer, newDateAsMoment) {\n    layer.start = convertMomentToDateType(newDateAsMoment, this.props.useMoment);\n  }\n\n  /**\n   * End of the layer as a moment object.\n   *\n   * @param {RowLayer} layer\n   * @return {moment}\n   */\n  getEndFromRowLayer(layer) {\n    return convertDateToMoment(layer.end, this.props.useMoment);\n  }\n\n  /**\n   * It assigns `newDateAsMoment` to the end of the segment (item), but first it converts it\n   * to moment or number/milliseconds according to `useMoment`.\n   *\n   * @param {RowLayer} layer\n   * @param {moment} newDateAsMoment\n   */\n  setEndToRowLayer(layer, newDateAsMoment) {\n    layer.end = convertMomentToDateType(newDateAsMoment, this.props.useMoment);\n  }\n\n  /**\n   * Re-renders the grid when the window or container is resized\n   */\n  updateDimensions() {\n    clearTimeout(this.resizeTimeout);\n    this.resizeTimeout = setTimeout(() => {\n      this.forceUpdate();\n      this._grid.recomputeGridSize();\n    }, 100);\n  }\n\n  /**\n   * Sets the internal maps used by the component for looking up item & row data\n   * @param {Item[]} items The items to be displayed in the grid\n   * @param {moment} startDate The visible start date of the timeline\n   * @param {moment} endDate The visible end date of the timeline\n   * @param {boolean} useMoment This parameter is necessary because this method is also called when\n   * the component receives new props.\n   */\n  setTimeMap(items, startDate, endDate, useMoment) {\n    if (!startDate || !endDate) {\n      startDate = this.getStartDate();\n      endDate = this.getEndDate();\n    }\n    this.itemRowMap = {}; // timeline elements (key) => (rowNo).\n    this.rowItemMap = {}; // (rowNo) => timeline elements\n    this.rowHeightCache = {}; // (rowNo) => max number of stacked items\n    let visibleItems = _.filter(items, i => {\n      return this.getEndFromItem(i, useMoment) > startDate && this.getStartFromItem(i, useMoment) < endDate;\n    });\n    let itemRows = _.groupBy(visibleItems, 'row');\n    _.forEach(itemRows, (visibleItems, row) => {\n      const rowInt = parseInt(row);\n      if (this.rowItemMap[rowInt] === undefined) this.rowItemMap[rowInt] = [];\n      _.forEach(visibleItems, item => {\n        this.itemRowMap[item.key] = rowInt;\n        this.rowItemMap[rowInt].push(item);\n      });\n      this.rowHeightCache[rowInt] = getMaxOverlappingItems(\n        visibleItems,\n        this.getStartFromItem,\n        this.getEndFromItem,\n        useMoment\n      );\n    });\n  }\n\n  /**\n   * Compute the number of rows that fit inside the timeline. If there can fit\n   * more rows than the model, fill in with empty groups.\n   * @param {Group[]} groups\n   */\n  fillInTimelineWithEmptyRows(groups) {\n    // remove empty groups\n    groups = groups.filter(group => !group.key || !group.key.startsWith(EMPTY_GROUP_KEY));\n\n    // get height of the grid (without timebar);\n    // used to compute the number of rows we need to fill in\n    if (!this._grid || this._grid.props.height <= 0) {\n      this.setState({groups: groups});\n      return;\n    }\n    const height = this._grid.props.height;\n\n    // compute the total height of the actual rows\n    let totalItemsHeight = 0;\n    _.forEach(this.rowHeightCache, row => {\n      totalItemsHeight += row * this.props.itemHeight;\n    });\n    let rowsToFillIn = (height - totalItemsHeight) / this.props.itemHeight;\n\n    let overflowStyle = 'auto';\n    let fillInGroups = [];\n    if (rowsToFillIn > 0) {\n      let groupId = groups.length;\n      while (rowsToFillIn > 0) {\n        // create new empty group\n        fillInGroups.push({\n          id: groupId,\n          key: EMPTY_GROUP_KEY + groupId\n        });\n        rowsToFillIn--;\n        groupId++;\n      }\n      overflowStyle = 'hidden';\n    }\n\n    const parentElement = document.querySelector(GRID_CLASS(this.props.componentId));\n    if (parentElement !== null) {\n      parentElement.style.overflow = overflowStyle;\n    }\n\n    this.setState({groups: [...groups, ...fillInGroups]});\n  }\n\n  /**\n   * Returns an item given its DOM element\n   * @param {Object} e the DOM element of the item\n   * @return {Object} Item details\n   * @prop {number|string} index The item's index\n   * @prop {number} rowNo The row number the item is in\n   * @prop {number} itemIndex Not really used - gets the index of the item in the row map\n   * @prop {Item} item The provided item object\n   */\n  itemFromElement(e) {\n    const index = e.getAttribute('data-item-index');\n    const rowNo = this.itemRowMap[index];\n    const itemIndex = _.findIndex(this.rowItemMap[rowNo], i => i.key == index);\n    const item = this.rowItemMap[rowNo][itemIndex];\n\n    return {index, rowNo, itemIndex, item};\n  }\n\n  /**\n   * Gets an item given its ID\n   * @param {number} id item id\n   * @return {Item} Item object\n   */\n  getItem(id) {\n    // This is quite stupid and shouldn't really be needed\n    const rowNo = this.itemRowMap[id];\n    const itemIndex = _.findIndex(this.rowItemMap[rowNo], i => i.key == id);\n    return this.rowItemMap[rowNo][itemIndex];\n  }\n\n  /**\n   * Move an item from one row to another\n   * @param {Item} item The item object whose groups is to be changed\n   * @param {number} curRow The item's current row index\n   * @param {number} newRow The item's new row index\n   */\n  changeGroup(item, curRow, newRow) {\n    item.row = newRow;\n    this.itemRowMap[item.key] = newRow;\n    this.rowItemMap[curRow] = this.rowItemMap[curRow].filter(i => i.key !== item.key);\n    this.rowItemMap[newRow].push(item);\n  }\n\n  /**\n   * Set the currently selected time ranges (for the timebar to display)\n   * @param {Object[]} selections Of the form `[[start, end], [start, end], ...]`\n   */\n  setSelection(selections) {\n    let newSelection = _.map(selections, s => {\n      return {start: s[0].clone(), end: s[1].clone()};\n    });\n    this.setState({selection: newSelection});\n  }\n\n  /**\n   * Clears the currently selected time range state\n   */\n  clearSelection() {\n    this.setState({selection: []});\n  }\n\n  /**\n   * Get the width of the timeline NOT including the left group list\n   * @param {?number} totalWidth Total timeline width. If not supplied we use the timeline ref\n   * @returns {number} The width in pixels\n   */\n  getTimelineWidth(totalWidth) {\n    if (totalWidth !== undefined) return totalWidth - this.calculateLeftOffset();\n    return this._grid.props.width - this.calculateLeftOffset();\n  }\n\n  /**\n   * Get the snap in milliseconds from snapMinutes or snap\n   * @returns { number }\n   */\n  getTimelineSnap() {\n    if (this.props.snap) {\n      return this.props.snap * 1000;\n    } else if (this.props.snapMinutes) {\n      return this.props.snapMinutes * 60 * 1000;\n    }\n    return 1;\n  }\n\n  /**\n   * re-computes the grid's row sizes\n   * @param {Object?} config Config to pass wo react-virtualized's compute func\n   */\n  refreshGrid = (config = {}) => {\n    this._grid.recomputeGridSize(config);\n    // fill in timeline with empty rows only on resize\n    if (!_.isEmpty(config)) {\n      this.fillInTimelineWithEmptyRows(this.state.groups);\n    }\n  };\n\n  /**\n   * @param { boolean } canSelect\n   * @param { boolean } canDrag\n   * @param { boolean } canResize\n   */\n  setUpDragging(canSelect, canDrag, canResize) {\n    // No need to setUpDragging during SSR\n    if (typeof window === 'undefined') {\n      return;\n    }\n\n    const topDivClassId = `rct9k-id-${this.props.componentId}`;\n    const selectedItemSelector = '.rct9k-items-outer-selected';\n    if (this._itemInteractable) this._itemInteractable.unset();\n    if (this._selectRectangleInteractable) this._selectRectangleInteractable.unset();\n\n    this._itemInteractable = interact(`.${topDivClassId} .item_draggable`);\n    this._selectRectangleInteractable = interact(`.${topDivClassId} .parent-div`);\n\n    this._itemInteractable.pointerEvents(this.props.interactOptions.pointerEvents).on('tap', e => {\n      this._handleItemRowEvent(e, this.props.onItemClick, this.props.onRowClick);\n    });\n\n    if (canDrag) {\n      this._itemInteractable\n        .draggable({\n          enabled: true,\n          allowFrom: selectedItemSelector,\n          restrict: {\n            restriction: `.${topDivClassId}`,\n            elementRect: {left: 0, right: 1, top: 0, bottom: 1}\n          },\n          ...this.props.interactOptions.draggable\n        })\n        .on('dragstart', e => {\n          let selections = [];\n          const animatedItems =\n            this.props.onInteraction &&\n            this.props.onInteraction(Timeline.changeTypes.dragStart, null, this.props.selectedItems);\n\n          _.forEach(animatedItems, id => {\n            let domItem = this._gridDomNode.querySelector(\"span[data-item-index='\" + id + \"'\");\n            if (domItem) {\n              selections.push([this.getStartFromItem(this.getItem(id)), this.getEndFromItem(this.getItem(id))]);\n              domItem.setAttribute('isDragging', 'True');\n              domItem.setAttribute('drag-x', 0);\n              domItem.setAttribute('drag-y', 0);\n              domItem.style['z-index'] = 4;\n            }\n          });\n          this.setSelection(selections);\n        })\n        .on('dragmove', e => {\n          const target = e.target;\n          let animatedItems = this._gridDomNode.querySelectorAll(\"span[isDragging='True'\") || [];\n\n          let dx = (parseFloat(target.getAttribute('drag-x')) || 0) + e.dx;\n          let dy = (parseFloat(target.getAttribute('drag-y')) || 0) + e.dy;\n          let selections = [];\n\n          // Snap the movement to the current snap interval\n          const snapDx = getSnapPixelFromDelta(\n            dx,\n            this.getStartDate(),\n            this.getEndDate(),\n            this.getTimelineWidth(),\n            this.getTimelineSnap()\n          );\n\n          _.forEach(animatedItems, domItem => {\n            const {item} = this.itemFromElement(domItem);\n            let itemDuration = this.getEndFromItem(item).diff(this.getStartFromItem(item));\n            let newPixelOffset = pixToInt(domItem.style.left) + snapDx;\n            let newStart = getTimeAtPixel(\n              newPixelOffset,\n              this.getStartDate(),\n              this.getEndDate(),\n              this.getTimelineWidth(),\n              this.getTimelineSnap()\n            );\n\n            let newEnd = newStart.clone().add(itemDuration);\n            selections.push([newStart, newEnd]);\n\n            // Translate the new start time back to pixels, so we can animate the snap\n            domItem.style.webkitTransform = domItem.style.transform = 'translate(' + snapDx + 'px, ' + dy + 'px)';\n          });\n\n          target.setAttribute('drag-x', dx);\n          target.setAttribute('drag-y', dy);\n\n          this.setSelection(selections);\n        })\n        .on('dragend', e => {\n          const {item, rowNo} = this.itemFromElement(e.target);\n          let animatedItems = this._gridDomNode.querySelectorAll(\"span[isDragging='True'\") || [];\n\n          this.setSelection([[this.getStartFromItem(item), this.getEndFromItem(item)]]);\n          this.clearSelection();\n\n          // Change row\n          let newRow = getNearestRowNumber(e.clientX, e.clientY);\n\n          let rowChangeDelta = newRow - rowNo;\n          // Update time\n          let newPixelOffset = pixToInt(e.target.style.left) + (parseFloat(e.target.getAttribute('drag-x')) || 0);\n          let newStart = getTimeAtPixel(\n            newPixelOffset,\n            this.getStartDate(),\n            this.getEndDate(),\n            this.getTimelineWidth(),\n            this.getTimelineSnap()\n          );\n\n          const timeDelta = newStart.clone().diff(this.getStartFromItem(item), 'minutes');\n          const changes = {rowChangeDelta, timeDelta};\n          let items = [];\n\n          // Default, all items move by the same offset during a drag\n          _.forEach(animatedItems, domItem => {\n            const {item, rowNo} = this.itemFromElement(domItem);\n\n            let itemDuration = this.getEndFromItem(item).diff(this.getStartFromItem(item));\n            let newStart = this.getStartFromItem(item)\n              .clone()\n              .add(timeDelta, 'minutes');\n            let newEnd = newStart.clone().add(itemDuration);\n            this.setStartToItem(item, newStart);\n            this.setEndToItem(item, newEnd);\n            if (rowChangeDelta < 0) {\n              item.row = Math.max(0, item.row + rowChangeDelta);\n            } else if (rowChangeDelta > 0) {\n              item.row = Math.min(this.props.groups.length - 1, item.row + rowChangeDelta);\n            }\n\n            items.push(item);\n          });\n\n          this.props.onInteraction && this.props.onInteraction(Timeline.changeTypes.dragEnd, changes, items);\n\n          // Reset the styles\n          animatedItems.forEach(domItem => {\n            domItem.style.webkitTransform = domItem.style.transform = 'translate(0px, 0px)';\n            domItem.setAttribute('drag-x', 0);\n            domItem.setAttribute('drag-y', 0);\n            domItem.style['z-index'] = 3;\n            domItem.style['top'] = intToPix(\n              this.props.itemHeight * Math.round(pixToInt(domItem.style['top']) / this.props.itemHeight)\n            );\n            domItem.removeAttribute('isDragging');\n          });\n\n          this._grid.recomputeGridSize({rowIndex: 0});\n        });\n    }\n    if (canResize) {\n      this._itemInteractable\n        .resizable({\n          allowFrom: selectedItemSelector,\n          edges: {left: true, right: true, bottom: false, top: false},\n          ...this.props.interactOptions.draggable\n        })\n        .on('resizestart', e => {\n          const selected =\n            this.props.onInteraction &&\n            this.props.onInteraction(Timeline.changeTypes.resizeStart, null, this.props.selectedItems);\n          _.forEach(selected, id => {\n            let domItem = this._gridDomNode.querySelector(\"span[data-item-index='\" + id + \"'\");\n            if (domItem) {\n              domItem.setAttribute('isResizing', 'True');\n              domItem.setAttribute('initialWidth', pixToInt(domItem.style.width));\n              domItem.style['z-index'] = 4;\n            }\n          });\n        })\n        .on('resizemove', e => {\n          let animatedItems = this._gridDomNode.querySelectorAll(\"span[isResizing='True'\") || [];\n\n          let dx = parseFloat(e.target.getAttribute('delta-x')) || 0;\n          dx += e.deltaRect.left;\n\n          let dw = e.rect.width - Number(e.target.getAttribute('initialWidth'));\n\n          const minimumWidth =\n            pixelsPerMillisecond(this.getStartDate(), this.getEndDate(), this.getTimelineWidth()) *\n            this.getTimelineSnap();\n\n          const snappedDx = getSnapPixelFromDelta(\n            dx,\n            this.getStartDate(),\n            this.getEndDate(),\n            this.getTimelineWidth(),\n            this.getTimelineSnap()\n          );\n\n          const snappedDw = getSnapPixelFromDelta(\n            dw,\n            this.getStartDate(),\n            this.getEndDate(),\n            this.getTimelineWidth(),\n            this.getTimelineSnap()\n          );\n\n          _.forEach(animatedItems, item => {\n            item.style.width = intToPix(Number(item.getAttribute('initialWidth')) + snappedDw + minimumWidth);\n            item.style.webkitTransform = item.style.transform = 'translate(' + snappedDx + 'px, 0px)';\n          });\n          e.target.setAttribute('delta-x', dx);\n        })\n        .on('resizeend', e => {\n          let animatedItems = this._gridDomNode.querySelectorAll(\"span[isResizing='True'\") || [];\n          // Update time\n          const dx = parseFloat(e.target.getAttribute('delta-x')) || 0;\n          const isStartTimeChange = dx != 0;\n\n          let items = [];\n          let minRowNo = Infinity;\n\n          let durationChange = null;\n          // Calculate the default item positions\n          _.forEach(animatedItems, domItem => {\n            let startPixelOffset = pixToInt(domItem.style.left) + dx;\n            const {item, rowNo} = this.itemFromElement(domItem);\n\n            minRowNo = Math.min(minRowNo, rowNo);\n\n            if (isStartTimeChange) {\n              let newStart = getTimeAtPixel(\n                startPixelOffset,\n                this.getStartDate(),\n                this.getEndDate(),\n                this.getTimelineWidth(),\n                this.getTimelineSnap()\n              );\n              if (durationChange === null) durationChange = this.getStartFromItem(item).diff(newStart, 'minutes');\n              this.setStartToItem(item, newStart);\n            } else {\n              let endPixelOffset = startPixelOffset + pixToInt(domItem.style.width);\n              let newEnd = getTimeAtPixel(\n                endPixelOffset,\n                this.getStartDate(),\n                this.getEndDate(),\n                this.getTimelineWidth(),\n                this.getTimelineSnap()\n              );\n              if (durationChange === null) durationChange = this.getEndFromItem(item).diff(newEnd, 'minutes');\n\n              this.setEndToItem(item, newEnd);\n            }\n\n            // Check row height doesn't need changing\n            let new_row_height = getMaxOverlappingItems(\n              this.rowItemMap[rowNo],\n              this.getStartFromItem,\n              this.getEndFromItem\n            );\n            if (new_row_height !== this.rowHeightCache[rowNo]) {\n              this.rowHeightCache[rowNo] = new_row_height;\n            }\n\n            //Reset styles\n            domItem.removeAttribute('isResizing');\n            domItem.removeAttribute('initialWidth');\n            domItem.style['z-index'] = 3;\n            domItem.style.webkitTransform = domItem.style.transform = 'translate(0px, 0px)';\n\n            items.push(item);\n          });\n          if (durationChange === null) durationChange = 0;\n          const changes = {isStartTimeChange, timeDelta: -durationChange};\n\n          this.props.onInteraction && this.props.onInteraction(Timeline.changeTypes.resizeEnd, changes, items);\n\n          e.target.setAttribute('delta-x', 0);\n          this._grid.recomputeGridSize({rowIndex: minRowNo});\n        });\n    }\n\n    if (canSelect) {\n      this._selectRectangleInteractable\n        .draggable({\n          enabled: true,\n          ignoreFrom: '.item_draggable, .rct9k-group'\n        })\n        .styleCursor(false)\n        .on('dragstart', e => {\n          const nearestRowObject = getNearestRowObject(e.clientX, e.clientY);\n\n          // this._selectBox.start(e.clientX, e.clientY);\n          // this._selectBox.start(e.clientX, topRowObj.style.top);\n          const startY = adjustRowTopPositionToViewport(nearestRowObject, nearestRowObject.getBoundingClientRect().y);\n          this._selectBox.start(e.clientX, startY);\n          // const bottomRow = Number(getNearestRowNumber(left + width, top + height));\n        })\n        .on('dragmove', e => {\n          const magicalConstant = 2;\n          // @bendog: I added this magical constant to solve the issue of selection bleed,\n          // I don't understand why it works, but if frequentist statisticians can use imaginary numbers, so can i.\n          const {startX, startY} = this._selectBox;\n          const startRowObject = getNearestRowObject(startX, startY);\n          const {clientX, clientY} = e;\n          const currentRowObject = getNearestRowObject(clientX, clientY);\n          if (currentRowObject !== undefined && startRowObject !== undefined) {\n            // only run if you can detect the top row\n            const startRowNumber = getRowObjectRowNumber(startRowObject);\n            const currentRowNumber = getRowObjectRowNumber(currentRowObject);\n            // const numRows = 1 + Math.abs(startRowNumber - currentRowNumber);\n            const rowMarginBorder = getVerticalMarginBorder(currentRowObject);\n            if (startRowNumber <= currentRowNumber) {\n              // select box for selection going down\n              // get the first selected rows top\n              let startTop = Math.ceil(startRowObject.getBoundingClientRect().top + rowMarginBorder);\n              startTop = adjustRowTopPositionToViewport(startRowObject, startTop);\n              // get the currently selected rows bottom\n              const currentBottom = Math.floor(getTrueBottom(currentRowObject) - magicalConstant - rowMarginBorder);\n              this._selectBox.start(startX, startTop);\n              this._selectBox.move(clientX, currentBottom);\n            } else {\n              // select box for selection going up\n              // get the currently selected rows top\n              const currentTop = Math.ceil(currentRowObject.getBoundingClientRect().top + rowMarginBorder);\n              // get the first selected rows bottom\n              const startBottom = Math.floor(getTrueBottom(startRowObject) - magicalConstant - rowMarginBorder * 2);\n              // the bottom will bleed south unless you counter the margins and boreders from the above rows\n              this._selectBox.start(startX, startBottom);\n              this._selectBox.move(clientX, currentTop);\n            }\n          }\n        })\n        .on('dragend', e => {\n          let {top, left, width, height} = this._selectBox.end();\n          //Get the start and end row of the selection rectangle\n          const topRowObject = getNearestRowObject(left, top);\n          if (topRowObject !== undefined) {\n            // only confirm the end of a drag if the selection box is valid\n            const topRowNumber = Number(getNearestRowNumber(left, top));\n            const topRowLoc = topRowObject.getBoundingClientRect();\n            const rowMarginBorder = getVerticalMarginBorder(topRowObject);\n            const y = Math.floor(topRowLoc.top - rowMarginBorder) + Math.floor(height - rowMarginBorder);\n            const bottomRow = Number(\n              getNearestRowNumber(left + width, adjustRowTopPositionToViewport(topRowObject, y))\n            );\n            //Get the start and end time of the selection rectangle\n            left = left - topRowLoc.left;\n            let startOffset = width > 0 ? left : left + width;\n            let endOffset = width > 0 ? left + width : left;\n            const startTime = getTimeAtPixel(\n              startOffset,\n              this.getStartDate(),\n              this.getEndDate(),\n              this.getTimelineWidth(),\n              this.getTimelineSnap()\n            );\n            const endTime = getTimeAtPixel(\n              endOffset,\n              this.getStartDate(),\n              this.getEndDate(),\n              this.getTimelineWidth(),\n              this.getTimelineSnap()\n            );\n            //Get items in these ranges\n            let selectedItems = [];\n            for (let r = Math.min(topRowNumber, bottomRow); r <= Math.max(topRowNumber, bottomRow); r++) {\n              selectedItems.push(\n                ..._.filter(this.rowItemMap[r], i => {\n                  return this.getStartFromItem(i).isBefore(endTime) && this.getEndFromItem(i).isAfter(startTime);\n                })\n              );\n            }\n            this.props.onInteraction && this.props.onInteraction(Timeline.changeTypes.itemsSelected, selectedItems);\n          }\n        });\n    }\n  }\n\n  _handleItemRowEvent = (e, itemCallback, rowCallback) => {\n    e.preventDefault();\n    // Skip click handler if selecting with selection box\n    if (this.selecting) {\n      return;\n    }\n    if (e.target.hasAttribute('data-item-index') || e.target.parentElement.hasAttribute('data-item-index')) {\n      let itemKey = e.target.getAttribute('data-item-index') || e.target.parentElement.getAttribute('data-item-index');\n      itemCallback && itemCallback(e, Number(itemKey));\n    } else {\n      let row = e.target.getAttribute('data-row-index');\n      let clickedTime = getTimeAtPixel(\n        e.clientX - this.calculateLeftOffset(),\n        this.getStartDate(),\n        this.getEndDate(),\n        this.getTimelineWidth()\n      );\n\n      //const roundedStartMinutes = Math.round(clickedTime.minute() / this.props.snap) * this.props.snap; // I dont know what this does\n      let snappedClickedTime = timeSnap(clickedTime, this.getTimelineSnap() * 60);\n      rowCallback && rowCallback(e, row, clickedTime, snappedClickedTime);\n    }\n  };\n\n  /**\n   * @param {number} width container width (in px)\n   */\n  cellRenderer(width) {\n    /**\n     * @param  {} columnIndex Always 1\n     * @param  {} key Unique key within array of cells\n     * @param  {} parent Reference to the parent Grid (instance)\n     * @param  {} rowIndex Vertical (row) index of cell\n     * @param  {} style Style object to be applied to cell (to position it);\n     */\n    const {timelineMode, onItemHover, onItemLeave, rowLayers} = this.props;\n    const canSelect = Timeline.isBitSet(Timeline.TIMELINE_MODES.SELECT, timelineMode);\n    return ({columnIndex, key, parent, rowIndex, style}) => {\n      // the items column is the last column in the grid; itemCol is the index of this column\n      let itemCol = this.props.tableColumns && this.props.tableColumns.length > 0 ? this.props.tableColumns.length : 1;\n      if (itemCol == columnIndex) {\n        let itemsInRow = this.rowItemMap[rowIndex];\n        const layersInRow = rowLayers.filter(r => r.rowNumber === rowIndex);\n        let rowHeight = this.props.itemHeight;\n        if (this.rowHeightCache[rowIndex]) {\n          rowHeight = rowHeight * this.rowHeightCache[rowIndex];\n        }\n        return (\n          <div\n            key={key}\n            style={style}\n            data-row-index={rowIndex}\n            className=\"rct9k-row\"\n            onClick={e => this._handleItemRowEvent(e, Timeline.no_op, this.props.onRowClick)}\n            onMouseDown={e => (this.selecting = false)}\n            onMouseMove={e => (this.selecting = true)}\n            onMouseOver={e => {\n              this.selecting = false;\n              return this._handleItemRowEvent(e, onItemHover, null);\n            }}\n            onMouseLeave={e => {\n              this.selecting = false;\n              return this._handleItemRowEvent(e, onItemLeave, null);\n            }}\n            onContextMenu={e =>\n              this._handleItemRowEvent(e, this.props.onItemContextClick, this.props.onRowContextClick)\n            }\n            onDoubleClick={e => this._handleItemRowEvent(e, this.props.onItemDoubleClick, this.props.onRowDoubleClick)}>\n            {rowItemsRenderer(\n              itemsInRow,\n              this.getStartDate(),\n              this.getEndDate(),\n              width,\n              this.props.itemHeight,\n              this.props.itemRenderer,\n              canSelect ? this.props.selectedItems : [],\n              this.props.itemRendererDefaultProps,\n              this.getStartFromItem,\n              this.getEndFromItem\n            )}\n            {rowLayerRenderer(\n              layersInRow,\n              this.getStartDate(),\n              this.getEndDate(),\n              width,\n              rowHeight,\n              this.getStartFromRowLayer,\n              this.getEndFromRowLayer\n            )}\n          </div>\n        );\n      } else {\n        // Single column mode: the renderer of the cell is props.groupRenderer\n        // with default labelProperty: SINGLE_COLUMN_LABEL_PROPERTY(title).\n        //\n        // Multiple columns mode: default renderer - props.groupRenderer with column.labelProperty;\n        // custom renderer: column.cellRenderer.\n        let labelProperty = '';\n        let ColumnRenderer = this.props.groupRenderer;\n        if (this.props.tableColumns && this.props.tableColumns.length > 0) {\n          const column = this.props.tableColumns[columnIndex];\n          if (column.cellRenderer) {\n            ColumnRenderer = column.cellRenderer;\n          } else {\n            labelProperty = column.labelProperty;\n          }\n        } else {\n          labelProperty = SINGLE_COLUMN_LABEL_PROPERTY;\n        }\n        let group = _.find(this.state.groups, g => g.id == rowIndex);\n        return (\n          <div data-row-index={rowIndex} key={key} style={style} className=\"rct9k-group\">\n            {React.isValidElement(ColumnRenderer) && ColumnRenderer}\n            {!React.isValidElement(ColumnRenderer) && (\n              <ColumnRenderer group={group} labelProperty={labelProperty} rowIndex={rowIndex} />\n            )}\n          </div>\n        );\n      }\n    };\n  }\n\n  getCursor() {\n    const {showCursorTime, cursorTimeFormat} = this.props;\n    const {cursorTime} = this.state;\n    return showCursorTime && cursorTime ? cursorTime.clone().format(cursorTimeFormat) : null;\n  }\n\n  /**\n   * Helper for react virtuaized to get the row height given a row index\n   */\n  rowHeight({index}) {\n    let rh = this.rowHeightCache[index] ? this.rowHeightCache[index] : 1;\n    return rh * this.props.itemHeight;\n  }\n\n  /**\n   * Set the grid ref.\n   * @param {Object} reactComponent Grid react element\n   */\n  grid_ref_callback(reactComponent) {\n    this._grid = reactComponent;\n    this._gridDomNode = ReactDOM.findDOMNode(this._grid);\n  }\n\n  /**\n   * Set the select box ref.\n   * @param {Object} reactComponent Selectbox react element\n   */\n  select_ref_callback(reactComponent) {\n    this._selectBox = reactComponent;\n  }\n\n  /**\n   * Event handler for onMouseMove.\n   * Only calls back if a new snap time is reached\n   */\n  throttledMouseMoveFunc(e) {\n    const {componentId} = this.props;\n    const leftOffset = document.querySelector(`.rct9k-id-${componentId} .parent-div`).getBoundingClientRect().left;\n    const cursorSnappedTime = getTimeAtPixel(\n      e.clientX - this.calculateLeftOffset() - leftOffset,\n      this.getStartDate(),\n      this.getEndDate(),\n      this.getTimelineWidth(),\n      this.getTimelineSnap()\n    );\n    if (!this.mouse_snapped_time || this.mouse_snapped_time.unix() !== cursorSnappedTime.unix()) {\n      if (cursorSnappedTime.isSameOrAfter(this.getStartDate())) {\n        this.mouse_snapped_time = cursorSnappedTime;\n        this.setState({cursorTime: this.mouse_snapped_time});\n        this.props.onInteraction &&\n          this.props.onInteraction(\n            Timeline.changeTypes.snappedMouseMove,\n            {snappedTime: this.mouse_snapped_time.clone()},\n            null\n          );\n      }\n    }\n  }\n\n  mouseMoveFunc(e) {\n    e.persist();\n    this.throttledMouseMoveFunc(e);\n  }\n\n  /**\n   * Calculates left offset of the timeline (group lists). If props.tableColumns is defined,\n   * the left offset is the sum of the widths of all tableColumns; otherwise returns groupOffset.\n   * @returns {number} left offset\n   */\n  calculateLeftOffset() {\n    const {tableColumns, groupOffset} = this.props;\n    if (!tableColumns || tableColumns.length == 0) {\n      return groupOffset;\n    }\n\n    let totalOffset = 0;\n    tableColumns.forEach(column => {\n      totalOffset += column.width ? column.width : groupOffset;\n    });\n    return totalOffset;\n  }\n\n  /**\n   * Setter for verticalGridLines (that will be passed to `BackgroundLayer`).\n   * @param { object } verticalGridLines\n   */\n  setVerticalGridLines(verticalGridLines) {\n    this.setState({verticalGridLines});\n  }\n\n  render() {\n    const {\n      onInteraction,\n      groupOffset,\n      showCursorTime,\n      timebarFormat,\n      componentId,\n      groupTitleRenderer,\n      shallowUpdateCheck,\n      forceRedrawFunc,\n      bottomResolution,\n      topResolution,\n      tableColumns,\n      backgroundLayer\n    } = this.props;\n    let that = this;\n\n    const divCssClass = `rct9k-timeline-div rct9k-id-${componentId}`;\n    let varTimebarProps = {};\n    if (timebarFormat) varTimebarProps['timeFormats'] = timebarFormat;\n    if (bottomResolution) varTimebarProps['bottom_resolution'] = bottomResolution;\n    if (topResolution) varTimebarProps['top_resolution'] = topResolution;\n\n    /**\n     * @param { Column } column\n     * @returns { number } width of a column\n     */\n    function getColumnWidth(column) {\n      return column.width ? column.width : groupOffset;\n    }\n\n    /**\n     * @param { number } width\n     * @returns { Function }\n     */\n    function columnWidth(width) {\n      return ({index}) => {\n        // The width of the first column when tableColumns is not defined is groupOffset.\n        if (index == 0 && (!that.props.tableColumns || that.props.tableColumns.length == 0)) return groupOffset;\n\n        // The width of the last column is width minus the left offset.\n        // The left offset is groupOffset when tableColumns is not defined or\n        // the sum of the widths of all tableColumns.\n        let leftOffset = groupOffset;\n        if (that.props.tableColumns && that.props.tableColumns.length > 0) {\n          if (index < that.props.tableColumns.length) {\n            return getColumnWidth(that.props.tableColumns[index]);\n          } else {\n            leftOffset = 0;\n            that.props.tableColumns.forEach(column => {\n              leftOffset += getColumnWidth(column);\n            });\n          }\n        }\n        return width - leftOffset;\n      };\n    }\n\n    /**\n     * @returns { number } height of the timebar\n     */\n    function getTimebarHeight() {\n      if (typeof window === 'undefined') {\n        return 0;\n      }\n      // when this function is called for the first time, the timebar is not yet rendered\n      let timebar = document.querySelector(`.rct9k-id-${componentId} .rct9k-timebar`);\n      if (!timebar) {\n        return 0;\n      }\n      // substract timebar height from total height\n      return timebar.getBoundingClientRect().height;\n    }\n\n    /**\n     * @param { number } height (total height of the timeline)\n     * @returns { number } height of the timeline w/o timebar\n     */\n    function calculateHeight(height) {\n      if (typeof window === 'undefined' || height === undefined) {\n        return 0;\n      }\n\n      return Math.max(height - getTimebarHeight(), 0);\n    }\n\n    // Markers (only current time marker atm)\n    const markers = [];\n    if (showCursorTime && this.mouse_snapped_time) {\n      const cursorPix = getPixelAtTime(\n        this.mouse_snapped_time,\n        this.getStartDate(),\n        this.getEndDate(),\n        this.getTimelineWidth()\n      );\n      markers.push({\n        left: cursorPix + this.calculateLeftOffset(),\n        key: 1\n      });\n    }\n    return (\n      <div className={divCssClass}>\n        <AutoSizer className=\"rct9k-autosizer\" onResize={this.refreshGrid}>\n          {({height, width}) => {\n            const leftOffset = this.calculateLeftOffset();\n            const bodyHeight = calculateHeight(height);\n            const timebarHeight = getTimebarHeight();\n            return (\n              <div className=\"parent-div\" onMouseMove={this.mouseMoveFunc}>\n                <SelectBox ref={this.select_ref_callback} />\n                <Timebar\n                  cursorTime={this.getCursor()}\n                  start={this.getStartDate()}\n                  end={this.getEndDate()}\n                  width={width}\n                  leftOffset={leftOffset}\n                  selectedRanges={this.state.selection}\n                  groupTitleRenderer={groupTitleRenderer}\n                  tableColumns={tableColumns}\n                  groupOffset={groupOffset}\n                  setVerticalGridLines={this.setVerticalGridLines}\n                  {...varTimebarProps}\n                />\n                {markers.map(m => (\n                  <Marker\n                    key={m.key}\n                    height={height}\n                    top={0}\n                    date={0}\n                    shouldUpdate={true}\n                    calculateHorizontalPosition={() => {\n                      return {left: m.left};\n                    }}\n                    className=\"rct9k-marker-overlay\"\n                  />\n                ))}\n                <TimelineBody\n                  width={width}\n                  columnWidth={columnWidth(width)}\n                  height={bodyHeight}\n                  rowHeight={this.rowHeight}\n                  rowCount={this.state.groups.length}\n                  columnCount={(tableColumns && tableColumns.length > 0 ? tableColumns.length : 1) + 1}\n                  cellRenderer={this.cellRenderer(this.getTimelineWidth(width))}\n                  grid_ref_callback={this.grid_ref_callback}\n                  shallowUpdateCheck={shallowUpdateCheck}\n                  forceRedrawFunc={forceRedrawFunc}\n                />\n                {backgroundLayer &&\n                  React.cloneElement(backgroundLayer, {\n                    startDateTimeline: this.getStartDate(),\n                    endDateTimeline: this.getEndDate(),\n                    width: width,\n                    leftOffset: leftOffset,\n                    height: bodyHeight,\n                    topOffset: timebarHeight,\n                    verticalGridLines: this.state.verticalGridLines\n                  })}\n              </div>\n            );\n          }}\n        </AutoSizer>\n      </div>\n    );\n  }\n}\n",
    "static": true,
    "longname": "/home/poweruser/git/react-timeline-10000/src/timeline.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 166,
    "kind": "variable",
    "name": "SINGLE_COLUMN_LABEL_PROPERTY",
    "memberof": "src/timeline.js",
    "static": true,
    "longname": "src/timeline.js~SINGLE_COLUMN_LABEL_PROPERTY",
    "access": "public",
    "export": false,
    "importPath": "@crispico/react-timeline-10000/src/timeline.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 167,
    "kind": "variable",
    "name": "EMPTY_GROUP_KEY",
    "memberof": "src/timeline.js",
    "static": true,
    "longname": "src/timeline.js~EMPTY_GROUP_KEY",
    "access": "public",
    "export": false,
    "importPath": "@crispico/react-timeline-10000/src/timeline.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 168,
    "kind": "function",
    "name": "GRID_CLASS",
    "memberof": "src/timeline.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/timeline.js~GRID_CLASS",
    "access": "public",
    "export": false,
    "importPath": "@crispico/react-timeline-10000/src/timeline.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "params": [
      {
        "name": "componentId",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 169,
    "kind": "class",
    "name": "Timeline",
    "memberof": "src/timeline.js",
    "static": true,
    "longname": "src/timeline.js~Timeline",
    "access": "public",
    "export": true,
    "importPath": "@crispico/react-timeline-10000/src/timeline.js",
    "importStyle": "Timeline",
    "description": "Timeline class",
    "lineNumber": 53,
    "interface": false,
    "extends": [
      "*",
      "*"
    ]
  },
  {
    "__docId__": 170,
    "kind": "member",
    "name": "TIMELINE_MODES",
    "memberof": "src/timeline.js~Timeline",
    "static": true,
    "longname": "src/timeline.js~Timeline.TIMELINE_MODES",
    "access": "public",
    "description": "",
    "lineNumber": 57,
    "type": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 171,
    "kind": "member",
    "name": "propTypes",
    "memberof": "src/timeline.js~Timeline",
    "static": true,
    "longname": "src/timeline.js~Timeline.propTypes",
    "access": "public",
    "description": null,
    "lineNumber": 63,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 172,
    "kind": "member",
    "name": "defaultProps",
    "memberof": "src/timeline.js~Timeline",
    "static": true,
    "longname": "src/timeline.js~Timeline.defaultProps",
    "access": "public",
    "description": null,
    "lineNumber": 354,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 173,
    "kind": "member",
    "name": "changeTypes",
    "memberof": "src/timeline.js~Timeline",
    "static": true,
    "longname": "src/timeline.js~Timeline.changeTypes",
    "access": "public",
    "description": "The types of interactions - see {@link onInteraction}",
    "lineNumber": 397,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 174,
    "kind": "method",
    "name": "isBitSet",
    "memberof": "src/timeline.js~Timeline",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/timeline.js~Timeline.isBitSet",
    "access": "public",
    "description": "Checks if the given bit is set in the given mask",
    "lineNumber": 412,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} True if bit is set; else false"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "bit",
        "description": "Bit to check"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "mask",
        "description": "Mask to check against"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True if bit is set; else false"
    }
  },
  {
    "__docId__": 175,
    "kind": "member",
    "name": "no_op",
    "memberof": "src/timeline.js~Timeline",
    "static": true,
    "longname": "src/timeline.js~Timeline.no_op",
    "access": "public",
    "description": "Alias for no op function",
    "lineNumber": 419,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 176,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/timeline.js~Timeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/timeline.js~Timeline#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 421,
    "undocument": true
  },
  {
    "__docId__": 177,
    "kind": "member",
    "name": "selecting",
    "memberof": "src/timeline.js~Timeline",
    "static": false,
    "longname": "src/timeline.js~Timeline#selecting",
    "access": "public",
    "description": null,
    "lineNumber": 423,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 178,
    "kind": "member",
    "name": "state",
    "memberof": "src/timeline.js~Timeline",
    "static": false,
    "longname": "src/timeline.js~Timeline#state",
    "access": "public",
    "description": null,
    "lineNumber": 424,
    "undocument": true,
    "type": {
      "types": [
        "{\"selection\": *, \"cursorTime\": *, \"groups\": *, \"verticalGridLines\": *}"
      ]
    }
  },
  {
    "__docId__": 199,
    "kind": "method",
    "name": "componentDidMount",
    "memberof": "src/timeline.js~Timeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/timeline.js~Timeline#componentDidMount",
    "access": "public",
    "description": null,
    "lineNumber": 461,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 200,
    "kind": "method",
    "name": "componentWillReceiveProps",
    "memberof": "src/timeline.js~Timeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/timeline.js~Timeline#componentWillReceiveProps",
    "access": "public",
    "description": null,
    "lineNumber": 465,
    "undocument": true,
    "params": [
      {
        "name": "nextProps",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 201,
    "kind": "method",
    "name": "componentWillUnmount",
    "memberof": "src/timeline.js~Timeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/timeline.js~Timeline#componentWillUnmount",
    "access": "public",
    "description": null,
    "lineNumber": 479,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 202,
    "kind": "method",
    "name": "componentDidUpdate",
    "memberof": "src/timeline.js~Timeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/timeline.js~Timeline#componentDidUpdate",
    "access": "public",
    "description": null,
    "lineNumber": 486,
    "undocument": true,
    "params": [
      {
        "name": "prevProps",
        "types": [
          "*"
        ]
      },
      {
        "name": "prevState",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 203,
    "kind": "method",
    "name": "getStartDate",
    "memberof": "src/timeline.js~Timeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/timeline.js~Timeline#getStartDate",
    "access": "public",
    "description": "Start of the displayed interval (as moment object).",
    "lineNumber": 504,
    "return": {
      "nullable": null,
      "types": [
        "moment"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 204,
    "kind": "method",
    "name": "getEndDate",
    "memberof": "src/timeline.js~Timeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/timeline.js~Timeline#getEndDate",
    "access": "public",
    "description": "End of the displayed interval (as moment object).",
    "lineNumber": 513,
    "return": {
      "nullable": null,
      "types": [
        "moment"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 205,
    "kind": "method",
    "name": "getStartFromItem",
    "memberof": "src/timeline.js~Timeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/timeline.js~Timeline#getStartFromItem",
    "access": "public",
    "description": "Start of the segment (item).",
    "lineNumber": 525,
    "params": [
      {
        "nullable": null,
        "types": [
          "Item"
        ],
        "spread": false,
        "optional": false,
        "name": "item",
        "description": "The segment (item)."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "useMoment",
        "description": "This parameter is necessary because this method is also called when\nthe component receives new props. Default value: `this.props.useMoment`."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "moment"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 206,
    "kind": "method",
    "name": "setStartToItem",
    "memberof": "src/timeline.js~Timeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/timeline.js~Timeline#setStartToItem",
    "access": "public",
    "description": "It assigns `newDateAsMoment` to the start of the segment (item), but first it converts it\nto moment or number/milliseconds according to `useMoment`.",
    "lineNumber": 537,
    "params": [
      {
        "nullable": null,
        "types": [
          "Item"
        ],
        "spread": false,
        "optional": false,
        "name": "item",
        "description": "The segment (item)."
      },
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "newDateAsMoment",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "void"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 207,
    "kind": "method",
    "name": "getEndFromItem",
    "memberof": "src/timeline.js~Timeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/timeline.js~Timeline#getEndFromItem",
    "access": "public",
    "description": "End of the segment (item).",
    "lineNumber": 549,
    "params": [
      {
        "nullable": null,
        "types": [
          "Item"
        ],
        "spread": false,
        "optional": false,
        "name": "item",
        "description": "The segment (item)."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "useMoment",
        "description": "This parameter is necessary because this method is also called when\nthe component receives new props. Default value: `this.props.useMoment`."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "moment"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 208,
    "kind": "method",
    "name": "setEndToItem",
    "memberof": "src/timeline.js~Timeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/timeline.js~Timeline#setEndToItem",
    "access": "public",
    "description": "It assigns `newDateAsMoment` to the end of the segment (item), but first it converts it\nto moment or number/milliseconds according to `useMoment`.",
    "lineNumber": 561,
    "params": [
      {
        "nullable": null,
        "types": [
          "Item"
        ],
        "spread": false,
        "optional": false,
        "name": "item",
        "description": "The segment (item)."
      },
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "newDateAsMoment",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "void"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 209,
    "kind": "method",
    "name": "getStartFromRowLayer",
    "memberof": "src/timeline.js~Timeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/timeline.js~Timeline#getStartFromRowLayer",
    "access": "public",
    "description": "Start of the layer as a moment object.",
    "lineNumber": 571,
    "params": [
      {
        "nullable": null,
        "types": [
          "RowLayer"
        ],
        "spread": false,
        "optional": false,
        "name": "layer",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "moment"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 210,
    "kind": "method",
    "name": "setStartToRowLayer",
    "memberof": "src/timeline.js~Timeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/timeline.js~Timeline#setStartToRowLayer",
    "access": "public",
    "description": "It assigns `newDateAsMoment` to the start of the segment (item), but first it converts it\nto moment or number/milliseconds according to `useMoment`.",
    "lineNumber": 582,
    "params": [
      {
        "nullable": null,
        "types": [
          "RowLayer"
        ],
        "spread": false,
        "optional": false,
        "name": "layer",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "newDateAsMoment",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 211,
    "kind": "method",
    "name": "getEndFromRowLayer",
    "memberof": "src/timeline.js~Timeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/timeline.js~Timeline#getEndFromRowLayer",
    "access": "public",
    "description": "End of the layer as a moment object.",
    "lineNumber": 592,
    "params": [
      {
        "nullable": null,
        "types": [
          "RowLayer"
        ],
        "spread": false,
        "optional": false,
        "name": "layer",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "moment"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 212,
    "kind": "method",
    "name": "setEndToRowLayer",
    "memberof": "src/timeline.js~Timeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/timeline.js~Timeline#setEndToRowLayer",
    "access": "public",
    "description": "It assigns `newDateAsMoment` to the end of the segment (item), but first it converts it\nto moment or number/milliseconds according to `useMoment`.",
    "lineNumber": 603,
    "params": [
      {
        "nullable": null,
        "types": [
          "RowLayer"
        ],
        "spread": false,
        "optional": false,
        "name": "layer",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "newDateAsMoment",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 213,
    "kind": "method",
    "name": "updateDimensions",
    "memberof": "src/timeline.js~Timeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/timeline.js~Timeline#updateDimensions",
    "access": "public",
    "description": "Re-renders the grid when the window or container is resized",
    "lineNumber": 610,
    "params": [],
    "return": null
  },
  {
    "__docId__": 214,
    "kind": "member",
    "name": "resizeTimeout",
    "memberof": "src/timeline.js~Timeline",
    "static": false,
    "longname": "src/timeline.js~Timeline#resizeTimeout",
    "access": "public",
    "description": null,
    "lineNumber": 612,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 215,
    "kind": "method",
    "name": "setTimeMap",
    "memberof": "src/timeline.js~Timeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/timeline.js~Timeline#setTimeMap",
    "access": "public",
    "description": "Sets the internal maps used by the component for looking up item & row data",
    "lineNumber": 626,
    "params": [
      {
        "nullable": null,
        "types": [
          "Item[]"
        ],
        "spread": false,
        "optional": false,
        "name": "items",
        "description": "The items to be displayed in the grid"
      },
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "startDate",
        "description": "The visible start date of the timeline"
      },
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "endDate",
        "description": "The visible end date of the timeline"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "useMoment",
        "description": "This parameter is necessary because this method is also called when\nthe component receives new props."
      }
    ],
    "return": null
  },
  {
    "__docId__": 216,
    "kind": "member",
    "name": "itemRowMap",
    "memberof": "src/timeline.js~Timeline",
    "static": false,
    "longname": "src/timeline.js~Timeline#itemRowMap",
    "access": "public",
    "description": null,
    "lineNumber": 631,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 217,
    "kind": "member",
    "name": "rowItemMap",
    "memberof": "src/timeline.js~Timeline",
    "static": false,
    "longname": "src/timeline.js~Timeline#rowItemMap",
    "access": "public",
    "description": null,
    "lineNumber": 632,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 218,
    "kind": "member",
    "name": "rowHeightCache",
    "memberof": "src/timeline.js~Timeline",
    "static": false,
    "longname": "src/timeline.js~Timeline#rowHeightCache",
    "access": "public",
    "description": null,
    "lineNumber": 633,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 219,
    "kind": "method",
    "name": "fillInTimelineWithEmptyRows",
    "memberof": "src/timeline.js~Timeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/timeline.js~Timeline#fillInTimelineWithEmptyRows",
    "access": "public",
    "description": "Compute the number of rows that fit inside the timeline. If there can fit\nmore rows than the model, fill in with empty groups.",
    "lineNumber": 659,
    "params": [
      {
        "nullable": null,
        "types": [
          "Group[]"
        ],
        "spread": false,
        "optional": false,
        "name": "groups",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 220,
    "kind": "method",
    "name": "itemFromElement",
    "memberof": "src/timeline.js~Timeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/timeline.js~Timeline#itemFromElement",
    "access": "public",
    "description": "Returns an item given its DOM element",
    "lineNumber": 711,
    "unknown": [
      {
        "tagName": "@prop",
        "tagValue": "{number|string} index The item's index"
      },
      {
        "tagName": "@prop",
        "tagValue": "{number} rowNo The row number the item is in"
      },
      {
        "tagName": "@prop",
        "tagValue": "{number} itemIndex Not really used - gets the index of the item in the row map"
      },
      {
        "tagName": "@prop",
        "tagValue": "{Item} item The provided item object"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "e",
        "description": "the DOM element of the item"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Item details"
    }
  },
  {
    "__docId__": 221,
    "kind": "method",
    "name": "getItem",
    "memberof": "src/timeline.js~Timeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/timeline.js~Timeline#getItem",
    "access": "public",
    "description": "Gets an item given its ID",
    "lineNumber": 725,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "item id"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Item"
      ],
      "spread": false,
      "description": "Item object"
    }
  },
  {
    "__docId__": 222,
    "kind": "method",
    "name": "changeGroup",
    "memberof": "src/timeline.js~Timeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/timeline.js~Timeline#changeGroup",
    "access": "public",
    "description": "Move an item from one row to another",
    "lineNumber": 738,
    "params": [
      {
        "nullable": null,
        "types": [
          "Item"
        ],
        "spread": false,
        "optional": false,
        "name": "item",
        "description": "The item object whose groups is to be changed"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "curRow",
        "description": "The item's current row index"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "newRow",
        "description": "The item's new row index"
      }
    ],
    "return": null
  },
  {
    "__docId__": 223,
    "kind": "method",
    "name": "setSelection",
    "memberof": "src/timeline.js~Timeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/timeline.js~Timeline#setSelection",
    "access": "public",
    "description": "Set the currently selected time ranges (for the timebar to display)",
    "lineNumber": 749,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object[]"
        ],
        "spread": false,
        "optional": false,
        "name": "selections",
        "description": "Of the form `[[start, end], [start, end], ...]`"
      }
    ],
    "return": null
  },
  {
    "__docId__": 224,
    "kind": "method",
    "name": "clearSelection",
    "memberof": "src/timeline.js~Timeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/timeline.js~Timeline#clearSelection",
    "access": "public",
    "description": "Clears the currently selected time range state",
    "lineNumber": 759,
    "params": [],
    "return": null
  },
  {
    "__docId__": 225,
    "kind": "method",
    "name": "getTimelineWidth",
    "memberof": "src/timeline.js~Timeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/timeline.js~Timeline#getTimelineWidth",
    "access": "public",
    "description": "Get the width of the timeline NOT including the left group list",
    "lineNumber": 768,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} The width in pixels"
      }
    ],
    "params": [
      {
        "nullable": true,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "totalWidth",
        "description": "Total timeline width. If not supplied we use the timeline ref"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The width in pixels"
    }
  },
  {
    "__docId__": 226,
    "kind": "method",
    "name": "getTimelineSnap",
    "memberof": "src/timeline.js~Timeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/timeline.js~Timeline#getTimelineSnap",
    "access": "public",
    "description": "Get the snap in milliseconds from snapMinutes or snap",
    "lineNumber": 777,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ number }"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        " number "
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 227,
    "kind": "member",
    "name": "refreshGrid",
    "memberof": "src/timeline.js~Timeline",
    "static": false,
    "longname": "src/timeline.js~Timeline#refreshGrid",
    "access": "public",
    "description": "re-computes the grid's row sizes",
    "lineNumber": 790,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object?"
        ],
        "spread": false,
        "optional": false,
        "name": "config",
        "description": "Config to pass wo react-virtualized's compute func"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 228,
    "kind": "method",
    "name": "setUpDragging",
    "memberof": "src/timeline.js~Timeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/timeline.js~Timeline#setUpDragging",
    "access": "public",
    "description": "",
    "lineNumber": 803,
    "params": [
      {
        "nullable": null,
        "types": [
          " boolean "
        ],
        "spread": false,
        "optional": false,
        "name": "canSelect",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          " boolean "
        ],
        "spread": false,
        "optional": false,
        "name": "canDrag",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          " boolean "
        ],
        "spread": false,
        "optional": false,
        "name": "canResize",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 229,
    "kind": "member",
    "name": "_itemInteractable",
    "memberof": "src/timeline.js~Timeline",
    "static": false,
    "longname": "src/timeline.js~Timeline#_itemInteractable",
    "access": "private",
    "description": null,
    "lineNumber": 814,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 230,
    "kind": "member",
    "name": "_selectRectangleInteractable",
    "memberof": "src/timeline.js~Timeline",
    "static": false,
    "longname": "src/timeline.js~Timeline#_selectRectangleInteractable",
    "access": "private",
    "description": null,
    "lineNumber": 815,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 231,
    "kind": "member",
    "name": "_handleItemRowEvent",
    "memberof": "src/timeline.js~Timeline",
    "static": false,
    "longname": "src/timeline.js~Timeline#_handleItemRowEvent",
    "access": "private",
    "description": null,
    "lineNumber": 1173,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 232,
    "kind": "method",
    "name": "cellRenderer",
    "memberof": "src/timeline.js~Timeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/timeline.js~Timeline#cellRenderer",
    "access": "public",
    "description": "",
    "lineNumber": 1200,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "width",
        "description": "container width (in px)"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 235,
    "kind": "method",
    "name": "getCursor",
    "memberof": "src/timeline.js~Timeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/timeline.js~Timeline#getCursor",
    "access": "public",
    "description": null,
    "lineNumber": 1295,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 236,
    "kind": "method",
    "name": "rowHeight",
    "memberof": "src/timeline.js~Timeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/timeline.js~Timeline#rowHeight",
    "access": "public",
    "description": "Helper for react virtuaized to get the row height given a row index",
    "lineNumber": 1304,
    "params": [
      {
        "name": "objectPattern",
        "types": [
          "{\"index\": *}"
        ],
        "defaultRaw": {
          "index": null
        },
        "defaultValue": "{\"index\":null}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 237,
    "kind": "method",
    "name": "grid_ref_callback",
    "memberof": "src/timeline.js~Timeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/timeline.js~Timeline#grid_ref_callback",
    "access": "public",
    "description": "Set the grid ref.",
    "lineNumber": 1313,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "reactComponent",
        "description": "Grid react element"
      }
    ],
    "return": null
  },
  {
    "__docId__": 238,
    "kind": "member",
    "name": "_grid",
    "memberof": "src/timeline.js~Timeline",
    "static": false,
    "longname": "src/timeline.js~Timeline#_grid",
    "access": "private",
    "description": null,
    "lineNumber": 1314,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 239,
    "kind": "member",
    "name": "_gridDomNode",
    "memberof": "src/timeline.js~Timeline",
    "static": false,
    "longname": "src/timeline.js~Timeline#_gridDomNode",
    "access": "private",
    "description": null,
    "lineNumber": 1315,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 240,
    "kind": "method",
    "name": "select_ref_callback",
    "memberof": "src/timeline.js~Timeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/timeline.js~Timeline#select_ref_callback",
    "access": "public",
    "description": "Set the select box ref.",
    "lineNumber": 1322,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "reactComponent",
        "description": "Selectbox react element"
      }
    ],
    "return": null
  },
  {
    "__docId__": 241,
    "kind": "member",
    "name": "_selectBox",
    "memberof": "src/timeline.js~Timeline",
    "static": false,
    "longname": "src/timeline.js~Timeline#_selectBox",
    "access": "private",
    "description": null,
    "lineNumber": 1323,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 242,
    "kind": "method",
    "name": "throttledMouseMoveFunc",
    "memberof": "src/timeline.js~Timeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/timeline.js~Timeline#throttledMouseMoveFunc",
    "access": "public",
    "description": "Event handler for onMouseMove.\nOnly calls back if a new snap time is reached",
    "lineNumber": 1330,
    "params": [
      {
        "name": "e",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 243,
    "kind": "member",
    "name": "mouse_snapped_time",
    "memberof": "src/timeline.js~Timeline",
    "static": false,
    "longname": "src/timeline.js~Timeline#mouse_snapped_time",
    "access": "public",
    "description": null,
    "lineNumber": 1342,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 244,
    "kind": "method",
    "name": "mouseMoveFunc",
    "memberof": "src/timeline.js~Timeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/timeline.js~Timeline#mouseMoveFunc",
    "access": "public",
    "description": null,
    "lineNumber": 1354,
    "undocument": true,
    "params": [
      {
        "name": "e",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 245,
    "kind": "method",
    "name": "calculateLeftOffset",
    "memberof": "src/timeline.js~Timeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/timeline.js~Timeline#calculateLeftOffset",
    "access": "public",
    "description": "Calculates left offset of the timeline (group lists). If props.tableColumns is defined,\nthe left offset is the sum of the widths of all tableColumns; otherwise returns groupOffset.",
    "lineNumber": 1364,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} left offset"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "left offset"
    },
    "params": []
  },
  {
    "__docId__": 246,
    "kind": "method",
    "name": "setVerticalGridLines",
    "memberof": "src/timeline.js~Timeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/timeline.js~Timeline#setVerticalGridLines",
    "access": "public",
    "description": "Setter for verticalGridLines (that will be passed to `BackgroundLayer`).",
    "lineNumber": 1381,
    "params": [
      {
        "nullable": null,
        "types": [
          " object "
        ],
        "spread": false,
        "optional": false,
        "name": "verticalGridLines",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 247,
    "kind": "method",
    "name": "render",
    "memberof": "src/timeline.js~Timeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/timeline.js~Timeline#render",
    "access": "public",
    "description": null,
    "lineNumber": 1385,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 248,
    "kind": "file",
    "name": "src/timeline.test.js",
    "content": "'use strict';\nimport React from 'react';\nimport {shallow} from 'enzyme';\nimport {expect} from 'chai';\n\nimport setup from 'setupTests';\n\nimport Timeline from 'timeline';\n\n// describe('<Timeline/>', function() {\n//   it('should have text', function() {\n//     const wrapper = shallow(<Timeline />);\n//     expect(wrapper.text()).to.equal('Hello');\n//   });\n// });\n",
    "static": true,
    "longname": "/home/poweruser/git/react-timeline-10000/src/timeline.test.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 249,
    "kind": "file",
    "name": "src/types.js",
    "content": "/**\n * This file is empty, but is needed, because we have types.d.ts. And we do import it from other files\n * (needed by tsc when it does its thing to generate the .d.ts files). And if we do this, storybook also\n * wants to see a \"real\" file.\n */\n",
    "static": true,
    "longname": "/home/poweruser/git/react-timeline-10000/src/types.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 250,
    "kind": "file",
    "name": "src/utils/commonUtils.js",
    "content": "/**\n * Add int pixels to a css style (left or top generally)\n * @param  {string} style Style string in css format\n * @param  {number} diff The pixels to add/subtract\n * @returns {string} Style as string for css use\n */\nexport function sumStyle(style, diff) {\n  return intToPix(pixToInt(style) + diff);\n}\n\n/**\n * Converts a pixel string to an int\n * @param  {string} pix Pixel string\n * @return {number} Integer value of the pixel string\n */\nexport function pixToInt(pix) {\n  return parseInt(pix.replace('px', ''));\n}\n\n/**\n * Convert integer to pixel string.\n * If not an integer the input is returned as is\n * @param  {number} int Integer value\n * @returns {string} Pixel string\n */\nexport function intToPix(int) {\n  if (int === Number(int)) return int + 'px';\n  return int;\n}\n",
    "static": true,
    "longname": "/home/poweruser/git/react-timeline-10000/src/utils/commonUtils.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 251,
    "kind": "function",
    "name": "sumStyle",
    "memberof": "src/utils/commonUtils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/commonUtils.js~sumStyle",
    "access": "public",
    "export": true,
    "importPath": "@crispico/react-timeline-10000/src/utils/commonUtils.js",
    "importStyle": "{sumStyle}",
    "description": "Add int pixels to a css style (left or top generally)",
    "lineNumber": 7,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} Style as string for css use"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "style",
        "description": "Style string in css format"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "diff",
        "description": "The pixels to add/subtract"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "Style as string for css use"
    }
  },
  {
    "__docId__": 252,
    "kind": "function",
    "name": "pixToInt",
    "memberof": "src/utils/commonUtils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/commonUtils.js~pixToInt",
    "access": "public",
    "export": true,
    "importPath": "@crispico/react-timeline-10000/src/utils/commonUtils.js",
    "importStyle": "{pixToInt}",
    "description": "Converts a pixel string to an int",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "pix",
        "description": "Pixel string"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Integer value of the pixel string"
    }
  },
  {
    "__docId__": 253,
    "kind": "function",
    "name": "intToPix",
    "memberof": "src/utils/commonUtils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/commonUtils.js~intToPix",
    "access": "public",
    "export": true,
    "importPath": "@crispico/react-timeline-10000/src/utils/commonUtils.js",
    "importStyle": "{intToPix}",
    "description": "Convert integer to pixel string.\nIf not an integer the input is returned as is",
    "lineNumber": 26,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} Pixel string"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "int",
        "description": "Integer value"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "Pixel string"
    }
  },
  {
    "__docId__": 254,
    "kind": "file",
    "name": "src/utils/commonUtils.test.js",
    "content": "import {expect} from 'chai';\n\nimport {intToPix, pixToInt} from './commonUtils';\n\ndescribe('Common Utils', function() {\n  describe('intToPix', function() {\n    it('should convert an int to a pixel string', function() {\n      expect(intToPix(1)).to.equal('1px');\n    });\n    it('should leave already converted strings as is', function() {\n      expect(intToPix('1px')).to.equal('1px');\n    });\n  });\n  describe('pixToInt', function() {\n    it('should convert a string to an int', function() {\n      expect(pixToInt('1px')).to.equal(1);\n    });\n    it('should convert a string to an int (2)', function() {\n      expect(pixToInt('1 px')).to.equal(1);\n    });\n  });\n});\n",
    "static": true,
    "longname": "/home/poweruser/git/react-timeline-10000/src/utils/commonUtils.test.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 255,
    "kind": "file",
    "name": "src/utils/itemUtils.js",
    "content": "'use strict';\n\nimport React from 'react';\nimport _ from 'lodash';\nimport moment from 'moment';\nimport {Item, RowLayer} from '../index';\n\n/**\n * Render all items in a row\n * @external {moment} http://momentjs.com/\n * @param  {Item[]} items List of items to render for this row\n * @param  {moment} vis_start The visible start of the timeline\n * @param  {moment} vis_end The visible end of the timeline\n * @param  {number} total_width pixel width of the timeline\n * @param  {number} itemHeight The height of the item in px\n * @param  {function} itemRenderer The renderer of the item\n * @param  {Object[]} selectedItems\n * @param  {Object} itemRendererDefaultProps\n * @param  {function} getStartFromItem Function that returns the start of an item\n * @param  {function} getEndFromItem Function that returns the end of an item\n */\nexport function rowItemsRenderer(\n  items,\n  vis_start,\n  vis_end,\n  total_width,\n  itemHeight,\n  itemRenderer,\n  selectedItems = [],\n  itemRendererDefaultProps,\n  getStartFromItem,\n  getEndFromItem\n) {\n  const start_end_ms = vis_end.diff(vis_start, 'milliseconds');\n  const pixels_per_ms = total_width / start_end_ms;\n  let filtered_items = _.sortBy(\n    _.filter(items, i => {\n      // if end not before window && start not after window\n      return !getEndFromItem(i).isBefore(vis_start) && !getStartFromItem(i).isAfter(vis_end);\n    }),\n    i => -getStartFromItem(i).unix()\n  ); // sorted in reverse order as we iterate over the array backwards\n  let displayItems = [];\n  let rowOffset = 0;\n  while (filtered_items.length > 0) {\n    let lastEnd = null;\n    for (let i = filtered_items.length - 1; i >= 0; i--) {\n      if (lastEnd === null || getStartFromItem(filtered_items[i]) >= lastEnd) {\n        let item = _.clone(filtered_items[i]);\n        item.rowOffset = rowOffset;\n        displayItems.push(item);\n        filtered_items.splice(i, 1);\n        lastEnd = getEndFromItem(item);\n      }\n    }\n    rowOffset++;\n  }\n  return _.map(displayItems, i => {\n    const Comp = itemRenderer;\n    let top = itemHeight * i['rowOffset'];\n    // itemHeight is also used to calculate the row height; the row height is the maximum number of overlapping items\n    // in a row multiplied with itemHeight.\n    // If the max overlapping items is 1, then itemHeight = row height,\n    // but we need to subtract 10 because of the margin (see rct9k-items-inner class in style.css)\n    const adjustedItemHeight = itemHeight - 10;\n    let item_offset_mins = getStartFromItem(i).diff(vis_start, 'milliseconds');\n    let item_duration_mins = getEndFromItem(i).diff(getStartFromItem(i), 'milliseconds');\n    let left = Math.round(item_offset_mins * pixels_per_ms);\n    let width = Math.round(item_duration_mins * pixels_per_ms);\n    let compClassnames = (i.className || itemRendererDefaultProps.className) + ' rct9k-items-inner';\n    let outerClassnames = 'rct9k-items-outer item_draggable';\n    let style = {};\n    let isSelected = selectedItems.indexOf(Number(i.key)) > -1;\n\n    if (isSelected) {\n      compClassnames += ' rct9k-items-selected';\n      outerClassnames += ' rct9k-items-outer-selected';\n      style = {};\n    }\n\n    return (\n      <span\n        key={i.key}\n        data-item-index={i.key}\n        className={outerClassnames}\n        style={{left, width, top, backgroundColor: 'transparent'}}>\n        <Comp {...itemRendererDefaultProps} {...i} item={i} className={compClassnames} height={adjustedItemHeight} />\n      </span>\n    );\n  });\n}\n\n/**\n * Render row layers\n * @param  {RowLayer[]} layers List of layers to render for this row\n * @param  {moment} vis_start The visible start of the timeline\n * @param  {moment} vis_end The visible end of the timeline\n * @param  {number} total_width pixel width of the timeline\n * @param  {number} itemHeight The layer height in px\n * @param  {function} getStartFromRowLayer Function that returns the start of a row layer\n * @param  {function} getEndFromRowLayer Function that returns the end of a row layer\n */\nexport function rowLayerRenderer(\n  layers,\n  vis_start,\n  vis_end,\n  total_width,\n  itemHeight,\n  getStartFromRowLayer,\n  getEndFromRowLayer\n) {\n  const start_end_ms = vis_end.diff(vis_start, 'milliseconds');\n  const pixels_per_ms = total_width / start_end_ms;\n  let filtered_items = _.sortBy(\n    _.filter(layers, i => {\n      return !getEndFromRowLayer(i).isBefore(vis_start) && !getStartFromRowLayer(i).isAfter(vis_end);\n    }),\n    i => -getStartFromRowLayer(i).unix()\n  ); // sorted in reverse order as we iterate over the array backwards\n  let displayItems = [];\n  let rowOffset = 0;\n  while (filtered_items.length > 0) {\n    let lastEnd = null;\n    for (let i = filtered_items.length - 1; i >= 0; i--) {\n      if (lastEnd === null || getStartFromRowLayer(filtered_items[i]) >= lastEnd) {\n        let item = _.clone(filtered_items[i]);\n        item.rowOffset = rowOffset;\n        displayItems.push(item);\n        filtered_items.splice(i, 1);\n        lastEnd = getEndFromRowLayer(item);\n      }\n    }\n    rowOffset++;\n  }\n  return _.map(displayItems, i => {\n    const {style, rowNumber} = i;\n    let top = itemHeight * i['rowOffset'];\n    let item_offset_mins = getStartFromRowLayer(i).diff(vis_start, 'milliseconds');\n    let item_duration_mins = getEndFromRowLayer(i).diff(getStartFromRowLayer(i), 'milliseconds');\n    let left = Math.round(item_offset_mins * pixels_per_ms);\n    let width = Math.round(item_duration_mins * pixels_per_ms);\n    let height = itemHeight - (rowNumber === 0 ? 2 : 1); // for border\n    let outerClassnames = 'rct9k-row-layer';\n\n    return (\n      <div\n        key={`r-${rowNumber}-${getStartFromRowLayer(i).unix()}`}\n        data-item-index={i.key}\n        className={outerClassnames}\n        style={{...style, left, width, top, height}}\n      />\n    );\n  });\n}\n\n/**\n * Gets the row object for a given x and y pixel location\n * @param  {number} x The x coordinate of the pixel location\n * @param  {number} y The y coordinate of the pixel location\n * @param  {Object} topDiv Div to search under\n * @returns {Object} The row object at that coordinate\n */\nexport function getNearestRowObject(x, y, topDiv = document) {\n  let elementsAtPixel = document.elementsFromPoint(x, y);\n  return _.find(elementsAtPixel, e => {\n    const inDiv = topDiv.contains(e);\n    return inDiv && e.hasAttribute('data-row-index');\n  });\n}\n\n/**\n * Gets the row number for a given row object\n * @param  {Object} elem The row object\n * @returns {number} The row number\n */\nexport function getRowObjectRowNumber(elem) {\n  return Number(elem ? elem.getAttribute('data-row-index') : 0);\n}\n\n/**\n * Gets the vertical margins and borders given an object\n * @param  {Object} elem The row object\n * @returns {number} the pixel position of the bottom of the element\n */\nexport function getVerticalMarginBorder(elem) {\n  const computedStyles = window.getComputedStyle(elem);\n  // top margin plus bottom margin halved\n  const rowMargins =\n    (Math.ceil(parseFloat(computedStyles['marginTop']) + parseFloat(computedStyles['marginBottom'])) || 1) / 2;\n  // half the size of the border seems important\n  const rowBorders =\n    (Math.ceil(parseFloat(computedStyles['borderTopWidth']) + parseFloat(computedStyles['borderBottomWidth'])) || 1) /\n    2;\n  return Number(rowMargins + rowBorders);\n}\n\n/**\n * Gets the true bottom location given an object\n * @param  {Object} elem an element\n * @returns {number} the pixel position of the bottom of the element\n */\nexport function getTrueBottom(elem) {\n  /*\n  @bendog: leaving this here as a helper, if there's ever a bug around inner items size\n  // get object shape\n  const rects = elem.getClientRects();\n  const bottom = Math.max(Object.values(rects).map(o => o.bottom), 0);\n   */\n  // calculate the true bottom\n  const bound = elem.getBoundingClientRect();\n  const bottom = Math.floor(bound.top + bound.height);\n  return Number(bottom);\n}\n\n/**\n * Gets the row number for a given x and y pixel location\n * @param  {number} x The x coordinate of the pixel location\n * @param  {number} y The y coordinate of the pixel location\n * @param  {Object} topDiv Div to search under\n * @returns {number} The row number\n */\nexport function getNearestRowNumber(x, y, topDiv = document) {\n  let elementsAtPixel = document.elementsFromPoint(x, y);\n  let targetRow = _.find(elementsAtPixel, e => {\n    const inDiv = topDiv.contains(e);\n    return inDiv && e.hasAttribute('data-row-index');\n  });\n  return targetRow ? targetRow.getAttribute('data-row-index') : 0;\n}\n\n/**\n * Use to find the height of a row, given a set of items\n * @param  {Item[]} items List of items\n * @param  {function} getStartFromItem Function that returns the start of an item.\n * @param  {function} getEndFromItem Function that returns the end of an item.\n * @param  {boolean} useMoment This parameter is necessary because this method is also called when\n * the component receives new props.\n * @returns {number} Max row height\n */\nexport function getMaxOverlappingItems(items, getStartFromItem, getEndFromItem, useMoment) {\n  let max = 0;\n  let sorted_items = _.sortBy(items, i => -getStartFromItem(i, useMoment).unix());\n  while (sorted_items.length > 0) {\n    let lastEnd = null;\n    for (let i = sorted_items.length - 1; i >= 0; i--) {\n      if (lastEnd === null || getStartFromItem(sorted_items[i], useMoment) >= lastEnd) {\n        lastEnd = getEndFromItem(sorted_items[i], useMoment);\n        sorted_items.splice(i, 1);\n      }\n    }\n    max++;\n  }\n  return Math.max(max, 1);\n}\n\n/**\n * It finds the ancestor with the provided className of the element.\n * @param {Object} the DOM element\n * @param {string} className\n * @returns {Object} ancestor with className\n */\nexport function findAncestorWithClassName(element, className) {\n  while ((element = element.parentNode) && !element.classList.contains(className));\n  return element;\n}\n\n/**\n * A special case is when we try to select items from a row that is scrolled (not fully visible).\n * The `top` position of that row is not visible, so when we move the mouse and try to find the nearest row object\n * using the `top` position, it will not find the actual row because at that position the row is not visible.\n * In this case we will use the `top` position of the viewport (the container of the rows).\n * @param {Object} row the DOM element of the row object\n * @param {number} top\n */\nexport function adjustRowTopPositionToViewport(row, top) {\n  let viewport = findAncestorWithClassName(row, 'ReactVirtualized__Grid').getBoundingClientRect();\n  if (viewport.top > top) {\n    return viewport.top;\n  }\n  return top;\n}\n",
    "static": true,
    "longname": "/home/poweruser/git/react-timeline-10000/src/utils/itemUtils.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 256,
    "kind": "external",
    "name": "moment",
    "externalLink": "http://momentjs.com/",
    "memberof": "src/utils/itemUtils.js",
    "static": true,
    "longname": "src/utils/itemUtils.js~moment",
    "access": "public",
    "description": "Render all items in a row",
    "lineNumber": 22,
    "params": [
      {
        "nullable": null,
        "types": [
          "Item[]"
        ],
        "spread": false,
        "optional": false,
        "name": "items",
        "description": "List of items to render for this row"
      },
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "vis_start",
        "description": "The visible start of the timeline"
      },
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "vis_end",
        "description": "The visible end of the timeline"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "total_width",
        "description": "pixel width of the timeline"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "itemHeight",
        "description": "The height of the item in px"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "itemRenderer",
        "description": "The renderer of the item"
      },
      {
        "nullable": null,
        "types": [
          "Object[]"
        ],
        "spread": false,
        "optional": false,
        "name": "selectedItems",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "itemRendererDefaultProps",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "getStartFromItem",
        "description": "Function that returns the start of an item"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "getEndFromItem",
        "description": "Function that returns the end of an item"
      }
    ]
  },
  {
    "__docId__": 257,
    "kind": "function",
    "name": "rowLayerRenderer",
    "memberof": "src/utils/itemUtils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/itemUtils.js~rowLayerRenderer",
    "access": "public",
    "export": true,
    "importPath": "@crispico/react-timeline-10000/src/utils/itemUtils.js",
    "importStyle": "{rowLayerRenderer}",
    "description": "Render row layers",
    "lineNumber": 103,
    "params": [
      {
        "nullable": null,
        "types": [
          "RowLayer[]"
        ],
        "spread": false,
        "optional": false,
        "name": "layers",
        "description": "List of layers to render for this row"
      },
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "vis_start",
        "description": "The visible start of the timeline"
      },
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "vis_end",
        "description": "The visible end of the timeline"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "total_width",
        "description": "pixel width of the timeline"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "itemHeight",
        "description": "The layer height in px"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "getStartFromRowLayer",
        "description": "Function that returns the start of a row layer"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "getEndFromRowLayer",
        "description": "Function that returns the end of a row layer"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 258,
    "kind": "function",
    "name": "getNearestRowObject",
    "memberof": "src/utils/itemUtils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/itemUtils.js~getNearestRowObject",
    "access": "public",
    "export": true,
    "importPath": "@crispico/react-timeline-10000/src/utils/itemUtils.js",
    "importStyle": "{getNearestRowObject}",
    "description": "Gets the row object for a given x and y pixel location",
    "lineNumber": 163,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object} The row object at that coordinate"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "x",
        "description": "The x coordinate of the pixel location"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "y",
        "description": "The y coordinate of the pixel location"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "topDiv",
        "description": "Div to search under"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "The row object at that coordinate"
    }
  },
  {
    "__docId__": 259,
    "kind": "function",
    "name": "getRowObjectRowNumber",
    "memberof": "src/utils/itemUtils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/itemUtils.js~getRowObjectRowNumber",
    "access": "public",
    "export": true,
    "importPath": "@crispico/react-timeline-10000/src/utils/itemUtils.js",
    "importStyle": "{getRowObjectRowNumber}",
    "description": "Gets the row number for a given row object",
    "lineNumber": 176,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} The row number"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "elem",
        "description": "The row object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The row number"
    }
  },
  {
    "__docId__": 260,
    "kind": "function",
    "name": "getVerticalMarginBorder",
    "memberof": "src/utils/itemUtils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/itemUtils.js~getVerticalMarginBorder",
    "access": "public",
    "export": true,
    "importPath": "@crispico/react-timeline-10000/src/utils/itemUtils.js",
    "importStyle": "{getVerticalMarginBorder}",
    "description": "Gets the vertical margins and borders given an object",
    "lineNumber": 185,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} the pixel position of the bottom of the element"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "elem",
        "description": "The row object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the pixel position of the bottom of the element"
    }
  },
  {
    "__docId__": 261,
    "kind": "function",
    "name": "getTrueBottom",
    "memberof": "src/utils/itemUtils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/itemUtils.js~getTrueBottom",
    "access": "public",
    "export": true,
    "importPath": "@crispico/react-timeline-10000/src/utils/itemUtils.js",
    "importStyle": "{getTrueBottom}",
    "description": "Gets the true bottom location given an object",
    "lineNumber": 202,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} the pixel position of the bottom of the element"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "elem",
        "description": "an element"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the pixel position of the bottom of the element"
    }
  },
  {
    "__docId__": 262,
    "kind": "function",
    "name": "getNearestRowNumber",
    "memberof": "src/utils/itemUtils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/itemUtils.js~getNearestRowNumber",
    "access": "public",
    "export": true,
    "importPath": "@crispico/react-timeline-10000/src/utils/itemUtils.js",
    "importStyle": "{getNearestRowNumber}",
    "description": "Gets the row number for a given x and y pixel location",
    "lineNumber": 222,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} The row number"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "x",
        "description": "The x coordinate of the pixel location"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "y",
        "description": "The y coordinate of the pixel location"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "topDiv",
        "description": "Div to search under"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The row number"
    }
  },
  {
    "__docId__": 263,
    "kind": "function",
    "name": "getMaxOverlappingItems",
    "memberof": "src/utils/itemUtils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/itemUtils.js~getMaxOverlappingItems",
    "access": "public",
    "export": true,
    "importPath": "@crispico/react-timeline-10000/src/utils/itemUtils.js",
    "importStyle": "{getMaxOverlappingItems}",
    "description": "Use to find the height of a row, given a set of items",
    "lineNumber": 240,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} Max row height"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Item[]"
        ],
        "spread": false,
        "optional": false,
        "name": "items",
        "description": "List of items"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "getStartFromItem",
        "description": "Function that returns the start of an item."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "getEndFromItem",
        "description": "Function that returns the end of an item."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "useMoment",
        "description": "This parameter is necessary because this method is also called when\nthe component receives new props."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Max row height"
    }
  },
  {
    "__docId__": 264,
    "kind": "function",
    "name": "findAncestorWithClassName",
    "memberof": "src/utils/itemUtils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/itemUtils.js~findAncestorWithClassName",
    "access": "public",
    "export": true,
    "importPath": "@crispico/react-timeline-10000/src/utils/itemUtils.js",
    "importStyle": "{findAncestorWithClassName}",
    "description": "It finds the ancestor with the provided className of the element.",
    "lineNumber": 262,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object} ancestor with className"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "the",
        "description": "DOM element"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "className",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "ancestor with className"
    }
  },
  {
    "__docId__": 265,
    "kind": "function",
    "name": "adjustRowTopPositionToViewport",
    "memberof": "src/utils/itemUtils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/itemUtils.js~adjustRowTopPositionToViewport",
    "access": "public",
    "export": true,
    "importPath": "@crispico/react-timeline-10000/src/utils/itemUtils.js",
    "importStyle": "{adjustRowTopPositionToViewport}",
    "description": "A special case is when we try to select items from a row that is scrolled (not fully visible).\nThe `top` position of that row is not visible, so when we move the mouse and try to find the nearest row object\nusing the `top` position, it will not find the actual row because at that position the row is not visible.\nIn this case we will use the `top` position of the viewport (the container of the rows).",
    "lineNumber": 275,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "row",
        "description": "the DOM element of the row object"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "top",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 266,
    "kind": "file",
    "name": "src/utils/itemUtils.test.js",
    "content": "import {expect} from 'chai';\n\nimport _ from 'lodash';\nimport moment from 'moment';\nimport {getMaxOverlappingItems} from './itemUtils';\nimport {convertDateToMoment} from './timeUtils';\n\nfunction getStartFromItem(item) {\n  return convertDateToMoment(item.start, true);\n}\n\nfunction getEndFromItem(item) {\n  return convertDateToMoment(item.end, true);\n}\n\n//\n// |--1--|\n//          |--2--|\n//   |--3--|\n//       |--4--|\n//     |--5--|\nconst allTestItems = [\n  {\n    key: '1',\n    title: '1',\n    color: 'blue',\n    row: 1,\n    start: moment('2000-01-01'),\n    end: moment('2000-01-01').add(1, 'days')\n  },\n  {\n    key: '2',\n    title: '2',\n    color: 'blue',\n    row: 1,\n    start: moment('2000-01-03'),\n    end: moment('2000-01-03')\n      .startOf('day')\n      .add(1, 'days')\n  },\n  {\n    key: '3',\n    title: '3',\n    color: 'blue',\n    row: 1,\n    start: moment('2000-01-01').add(1, 'hours'),\n    end: moment('2000-01-01')\n      .add(1, 'hours')\n      .add(1, 'days')\n  },\n  {\n    key: '4',\n    title: '4',\n    color: 'blue',\n    row: 1,\n    start: moment('2000-01-01').add(1, 'days'),\n    end: moment('2000-01-01')\n      .add(1, 'hours')\n      .add(1, 'days')\n  },\n  {\n    key: '5',\n    title: '5',\n    color: 'blue',\n    row: 1,\n    start: moment('2000-01-01').add(2, 'hours'),\n    end: moment('2000-01-01')\n      .add(2, 'hours')\n      .add(1, 'days')\n  }\n];\n\ndescribe('Item Utils', function() {\n  describe('getMaxOverlappingItems', function() {\n    it('should return a default of 1', function() {\n      const result = getMaxOverlappingItems([], getStartFromItem, getEndFromItem);\n      expect(result).to.equal(1);\n    });\n    // Diagram\n    //  |-----|  |----|\n    it('should return 1 when no overlapping items', function() {\n      let testInstanceIDs = ['1', '2'];\n      let items = _.filter(allTestItems, i => {\n        return _.includes(testInstanceIDs, i.key);\n      });\n      const result = getMaxOverlappingItems(items, getStartFromItem, getEndFromItem);\n      expect(result).to.equal(1);\n    });\n    // Diagram\n    //  |-----|\n    //    |------|\n    it('should return 2 when 2 items overlap', () => {\n      let testInstanceIDs = ['1', '3'];\n      let items = _.filter(allTestItems, i => {\n        return _.includes(testInstanceIDs, i.key);\n      });\n      const result = getMaxOverlappingItems(items, getStartFromItem, getEndFromItem);\n      expect(result).to.equal(2);\n    });\n    // Diagram\n    //  |-----|-----|\n    it('should return 1 when 2 items touch', () => {\n      let testInstanceIDs = ['1', '4'];\n      let items = _.filter(allTestItems, i => {\n        return _.includes(testInstanceIDs, i.key);\n      });\n      const result = getMaxOverlappingItems(items, getStartFromItem, getEndFromItem);\n      expect(result).to.equal(1);\n    });\n    // Diagram\n    //  |-----|\n    //    |------|\n    //       |------|\n    it('should return 3 when 3 items overlap', () => {\n      let testInstanceIDs = ['1', '3', '5'];\n      let items = _.filter(allTestItems, i => {\n        return _.includes(testInstanceIDs, i.key);\n      });\n      const result = getMaxOverlappingItems(items, getStartFromItem, getEndFromItem);\n      expect(result).to.equal(3);\n    });\n    // Diagram\n    //  |-----|  |------|\n    //      |------|\n    it('should return 2 when 2 of 3 items overlap', () => {\n      let testInstanceIDs = ['2', '3', '4'];\n      let items = _.filter(allTestItems, i => {\n        return _.includes(testInstanceIDs, i.key);\n      });\n      const result = getMaxOverlappingItems(items, getStartFromItem, getEndFromItem);\n      expect(result).to.equal(2);\n    });\n  });\n});\n",
    "static": true,
    "longname": "/home/poweruser/git/react-timeline-10000/src/utils/itemUtils.test.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 267,
    "kind": "function",
    "name": "getStartFromItem",
    "memberof": "src/utils/itemUtils.test.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/itemUtils.test.js~getStartFromItem",
    "access": "public",
    "export": false,
    "importPath": "@crispico/react-timeline-10000/src/utils/itemUtils.test.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "params": [
      {
        "name": "item",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 268,
    "kind": "function",
    "name": "getEndFromItem",
    "memberof": "src/utils/itemUtils.test.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/itemUtils.test.js~getEndFromItem",
    "access": "public",
    "export": false,
    "importPath": "@crispico/react-timeline-10000/src/utils/itemUtils.test.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "params": [
      {
        "name": "item",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 269,
    "kind": "variable",
    "name": "allTestItems",
    "memberof": "src/utils/itemUtils.test.js",
    "static": true,
    "longname": "src/utils/itemUtils.test.js~allTestItems",
    "access": "public",
    "export": false,
    "importPath": "@crispico/react-timeline-10000/src/utils/itemUtils.test.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "undefined[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 270,
    "kind": "file",
    "name": "src/utils/timeUtils.js",
    "content": "// Time utilities\n\nimport moment from 'moment';\n\n/**\n * Snaps a moment object to the given resolution\n * @param {moment} time The moment to snap\n * @param {number} snapMilliseconds The snap time in milliseconds\n * @returns {moment} Snapped moment\n */\nexport function timeSnap(time, snapMilliseconds) {\n  if (snapMilliseconds === 0) {\n    const newTime = time.clone();\n    newTime.set('millisecond', 0);\n    return newTime;\n  }\n  const newUnix = Math.round((time.unix() * 1000) / snapMilliseconds) * snapMilliseconds;\n  return moment(newUnix);\n}\n\n/**\n * Get the pixels per millisecond\n * @param {moment} vis_start The moment specifying the start of the visible timeline range\n * @param {moment} vis_end The moment specifying the end of the visible timeline range\n * @param {number} total_width The width of the timeline in pixels\n * @returns {float} The pixels per millisecond\n */\nexport function pixelsPerMillisecond(vis_start, vis_end, total_width) {\n  const start_end_ms = vis_end.diff(vis_start, 'milliseconds');\n  return total_width / start_end_ms;\n}\n\n/**\n *\n * @param {number} delta the delta distance in pixels\n * @param {moment} vis_start the visible start of the timeline\n * @param {moment} vis_end  the visible end of the timeline\n * @param {number} total_width  the pixel width of the timeline\n * @param {number} snapMilliseconds the number of milliseconds to snap to\n */\nexport function getSnapPixelFromDelta(delta, vis_start, vis_end, total_width, snapMilliseconds = 0) {\n  const pixelsPerSnapSegment = pixelsPerMillisecond(vis_start, vis_end, total_width) * snapMilliseconds;\n  return Math.round(delta / pixelsPerSnapSegment) * pixelsPerSnapSegment;\n}\n\n/**\n * Get the time at a pixel location\n * @param {number} pixel_location the pixel location (generally from left css style)\n * @param {moment} vis_start The visible start of the timeline\n * @param {moment} vis_end The visible end of the timeline\n * @param {number} total_width The pixel width of the timeline (row portion)\n * @param {number} snapMilliseconds The snap resolution (in ms)\n * @returns {moment} Moment object\n */\nexport function getTimeAtPixel(pixel_location, vis_start, vis_end, total_width, snapMilliseconds = 0) {\n  let min_offset = pixel_location / pixelsPerMillisecond(vis_start, vis_end, total_width);\n  let timeAtPix = vis_start.clone().add(min_offset, 'milliseconds');\n  if (snapMilliseconds !== 0) timeAtPix = timeSnap(timeAtPix, snapMilliseconds);\n  return timeAtPix;\n}\n\n/**\n * Get the pixel location at a specific time\n * @param  {objects} time The time (moment) object\n * @param  {moment} vis_start The visible start of the timeline\n * @param  {moment} vis_end The visible end of the timeline\n * @param  {number} total_width The width in pixels of the grid\n * @returns {number} The pixel offset\n */\nexport function getPixelAtTime(time, vis_start, vis_end, total_width) {\n  const min_from_start = time.diff(vis_start, 'milliseconds');\n  return min_from_start * pixelsPerMillisecond(vis_start, vis_end, total_width);\n}\n\n/**\n * Returns the duration from the {@link vis_start}\n * @param  {number} pixels\n * @param  {moment} vis_start The visible start of the timeline\n * @param  {moment} vis_end The visible end of the timeline\n * @param  {number} total_width The width in pixels of the grid\n * @returns {moment} Moment duration\n */\nexport function getDurationFromPixels(pixels, vis_start, vis_end, total_width) {\n  const start_end_ms = vis_end.diff(vis_start, 'milliseconds');\n  if (start_end_ms === 0) return moment.duration(0, 'milliseconds');\n  const pixels_per_ms = total_width / start_end_ms;\n  let millis = pixels / pixels_per_ms;\n  return moment.duration(millis, 'milliseconds');\n}\n\n/**\n * If `useMoment` is `true` then returns `date` as is. Otherwise converts `date` to\n * a moment object.\n *\n * @param {moment|number} date\n * @param {boolean} useMoment\n * @returns moment\n */\nexport function convertDateToMoment(date, useMoment) {\n  if (useMoment) {\n    return date;\n  }\n  return moment(date);\n}\n\n/**\n * If `useMoment` is `true` returns `dateAsMoment` as is. Otherwise it converts `dateAsMoment` to\n * number/milliseconds.\n *\n * @param {moment} dateAsMoment\n * @param {boolean} useMoment\n * @returns a moment object or a number/milliseconds\n */\nexport function convertMomentToDateType(dateAsMoment, useMoment) {\n  if (useMoment) {\n    return dateAsMoment;\n  }\n  return dateAsMoment.valueOf();\n}\n",
    "static": true,
    "longname": "/home/poweruser/git/react-timeline-10000/src/utils/timeUtils.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 271,
    "kind": "function",
    "name": "timeSnap",
    "memberof": "src/utils/timeUtils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/timeUtils.js~timeSnap",
    "access": "public",
    "export": true,
    "importPath": "@crispico/react-timeline-10000/src/utils/timeUtils.js",
    "importStyle": "{timeSnap}",
    "description": "Snaps a moment object to the given resolution",
    "lineNumber": 11,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{moment} Snapped moment"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "time",
        "description": "The moment to snap"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "snapMilliseconds",
        "description": "The snap time in milliseconds"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "moment"
      ],
      "spread": false,
      "description": "Snapped moment"
    }
  },
  {
    "__docId__": 272,
    "kind": "function",
    "name": "pixelsPerMillisecond",
    "memberof": "src/utils/timeUtils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/timeUtils.js~pixelsPerMillisecond",
    "access": "public",
    "export": true,
    "importPath": "@crispico/react-timeline-10000/src/utils/timeUtils.js",
    "importStyle": "{pixelsPerMillisecond}",
    "description": "Get the pixels per millisecond",
    "lineNumber": 28,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{float} The pixels per millisecond"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "vis_start",
        "description": "The moment specifying the start of the visible timeline range"
      },
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "vis_end",
        "description": "The moment specifying the end of the visible timeline range"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "total_width",
        "description": "The width of the timeline in pixels"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "float"
      ],
      "spread": false,
      "description": "The pixels per millisecond"
    }
  },
  {
    "__docId__": 273,
    "kind": "function",
    "name": "getSnapPixelFromDelta",
    "memberof": "src/utils/timeUtils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/timeUtils.js~getSnapPixelFromDelta",
    "access": "public",
    "export": true,
    "importPath": "@crispico/react-timeline-10000/src/utils/timeUtils.js",
    "importStyle": "{getSnapPixelFromDelta}",
    "description": "",
    "lineNumber": 41,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "delta",
        "description": "the delta distance in pixels"
      },
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "vis_start",
        "description": "the visible start of the timeline"
      },
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "vis_end",
        "description": "the visible end of the timeline"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "total_width",
        "description": "the pixel width of the timeline"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "snapMilliseconds",
        "description": "the number of milliseconds to snap to"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 274,
    "kind": "function",
    "name": "getTimeAtPixel",
    "memberof": "src/utils/timeUtils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/timeUtils.js~getTimeAtPixel",
    "access": "public",
    "export": true,
    "importPath": "@crispico/react-timeline-10000/src/utils/timeUtils.js",
    "importStyle": "{getTimeAtPixel}",
    "description": "Get the time at a pixel location",
    "lineNumber": 55,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{moment} Moment object"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "pixel_location",
        "description": "the pixel location (generally from left css style)"
      },
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "vis_start",
        "description": "The visible start of the timeline"
      },
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "vis_end",
        "description": "The visible end of the timeline"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "total_width",
        "description": "The pixel width of the timeline (row portion)"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "snapMilliseconds",
        "description": "The snap resolution (in ms)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "moment"
      ],
      "spread": false,
      "description": "Moment object"
    }
  },
  {
    "__docId__": 275,
    "kind": "function",
    "name": "getPixelAtTime",
    "memberof": "src/utils/timeUtils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/timeUtils.js~getPixelAtTime",
    "access": "public",
    "export": true,
    "importPath": "@crispico/react-timeline-10000/src/utils/timeUtils.js",
    "importStyle": "{getPixelAtTime}",
    "description": "Get the pixel location at a specific time",
    "lineNumber": 70,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} The pixel offset"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "objects"
        ],
        "spread": false,
        "optional": false,
        "name": "time",
        "description": "The time (moment) object"
      },
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "vis_start",
        "description": "The visible start of the timeline"
      },
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "vis_end",
        "description": "The visible end of the timeline"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "total_width",
        "description": "The width in pixels of the grid"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The pixel offset"
    }
  },
  {
    "__docId__": 276,
    "kind": "function",
    "name": "getDurationFromPixels",
    "memberof": "src/utils/timeUtils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/timeUtils.js~getDurationFromPixels",
    "access": "public",
    "export": true,
    "importPath": "@crispico/react-timeline-10000/src/utils/timeUtils.js",
    "importStyle": "{getDurationFromPixels}",
    "description": "Returns the duration from the {@link vis_start}",
    "lineNumber": 83,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{moment} Moment duration"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "pixels",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "vis_start",
        "description": "The visible start of the timeline"
      },
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "vis_end",
        "description": "The visible end of the timeline"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "total_width",
        "description": "The width in pixels of the grid"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "moment"
      ],
      "spread": false,
      "description": "Moment duration"
    }
  },
  {
    "__docId__": 277,
    "kind": "function",
    "name": "convertDateToMoment",
    "memberof": "src/utils/timeUtils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/timeUtils.js~convertDateToMoment",
    "access": "public",
    "export": true,
    "importPath": "@crispico/react-timeline-10000/src/utils/timeUtils.js",
    "importStyle": "{convertDateToMoment}",
    "description": "If `useMoment` is `true` then returns `date` as is. Otherwise converts `date` to\na moment object.",
    "lineNumber": 99,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "moment"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "moment",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "useMoment",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "moment"
    }
  },
  {
    "__docId__": 278,
    "kind": "function",
    "name": "convertMomentToDateType",
    "memberof": "src/utils/timeUtils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/timeUtils.js~convertMomentToDateType",
    "access": "public",
    "export": true,
    "importPath": "@crispico/react-timeline-10000/src/utils/timeUtils.js",
    "importStyle": "{convertMomentToDateType}",
    "description": "If `useMoment` is `true` returns `dateAsMoment` as is. Otherwise it converts `dateAsMoment` to\nnumber/milliseconds.",
    "lineNumber": 114,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "a moment object or a number/milliseconds"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "dateAsMoment",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "useMoment",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "a moment object or a number/milliseconds"
    }
  },
  {
    "__docId__": 279,
    "kind": "file",
    "name": "src/utils/timeUtils.test.js",
    "content": "import {expect} from 'chai';\n\nimport moment from 'moment';\nimport {\n  timeSnap,\n  getTimeAtPixel,\n  getPixelAtTime,\n  getDurationFromPixels,\n  getSnapPixelFromDelta,\n  convertDateToMoment,\n  convertMomentToDateType\n} from './timeUtils';\n\ndescribe('Time Utils', function() {\n  describe('timeSnap', function() {\n    it('should round up to the last sec', function() {\n      const testTime = moment('2000-01-01 10:00:00.872 Z', 'YYYY-MM-DD H:m:s.SSS Z');\n      const expectedTime = moment('2000-01-01 10:00:00.000 Z', 'YYYY-MM-DD H:m:s.SSS Z');\n      const snap = 1000;\n      const actualTime = timeSnap(testTime, snap);\n      expect(actualTime.unix()).to.equal(expectedTime.unix());\n    });\n    it('should round down to the last sec', function() {\n      const testTime = moment('2000-01-01 10:00:00.272 Z', 'YYYY-MM-DD H:m:s.SSS Z');\n      const expectedTime = moment('2000-01-01 10:00:00.000 Z', 'YYYY-MM-DD H:m:s.SSS Z');\n      const snap = 1000;\n      const actualTime = timeSnap(testTime, snap);\n      expect(actualTime.unix()).to.equal(expectedTime.unix());\n    });\n    it('should round up to the nearest min', function() {\n      const testTime = moment('2000-01-01 9:59:50 Z', 'YYYY-MM-DD H:m:s Z');\n      const expectedTime = moment('2000-01-01 10:00:00 Z', 'YYYY-MM-DD H:m:s Z');\n      const snap = 60 * 1000;\n      const actualTime = timeSnap(testTime, snap);\n      expect(actualTime.unix()).to.equal(expectedTime.unix());\n    });\n    it('should round down to the nearest min', function() {\n      const testTime = moment('2000-01-01 10:00:20 Z', 'YYYY-MM-DD H:m:s Z');\n      const expectedTime = moment('2000-01-01 10:00:00 Z', 'YYYY-MM-DD H:m:s Z');\n      const snap = 60 * 1000;\n      const actualTime = timeSnap(testTime, snap);\n      expect(actualTime.unix()).to.equal(expectedTime.unix());\n    });\n    it('should round up when at 30s (nearest min)', function() {\n      const testTime = moment('2000-01-01 10:00:30 Z', 'YYYY-MM-DD H:m:s Z');\n      const expectedTime = moment('2000-01-01 10:01:00 Z', 'YYYY-MM-DD H:m:s Z');\n      const snap = 60 * 1000;\n      const actualTime = timeSnap(testTime, snap);\n      expect(actualTime.unix()).to.equal(expectedTime.unix());\n    });\n    it('should round to nearest hour', function() {\n      const testTime = moment('2000-01-01 10:12:30 Z', 'YYYY-MM-DD H:m:s Z');\n      const expectedTime = moment('2000-01-01 10:00:00 Z', 'YYYY-MM-DD H:m:s Z');\n      const snap = 60 * 60 * 1000;\n      const actualTime = timeSnap(testTime, snap);\n      expect(actualTime.unix()).to.equal(expectedTime.unix());\n    });\n    it('should round to nearest hour over mid-night', function() {\n      const testTime = moment('2000-01-01 23:44:40 Z', 'YYYY-MM-DD H:m:s Z');\n      const expectedTime = moment('2000-01-02 00:00:00 Z', 'YYYY-MM-DD H:m:s Z');\n      const snap = 60 * 60 * 1000;\n      const actualTime = timeSnap(testTime, snap);\n      expect(actualTime.unix()).to.equal(expectedTime.unix());\n    });\n    it('should round up to nearest day', function() {\n      const testTime = moment('2000-01-01 12:44:40 Z', 'YYYY-MM-DD H:m:s Z');\n      const expectedTime = moment('2000-01-02 00:00:00 Z', 'YYYY-MM-DD H:m:s Z');\n      const snap = 60 * 60 * 24 * 1000;\n      const actualTime = timeSnap(testTime, snap);\n      expect(actualTime.unix()).to.equal(expectedTime.unix());\n    });\n    it('should round down to nearest day', function() {\n      const testTime = moment('2000-01-01 11:44:40 Z', 'YYYY-MM-DD H:m:s Z');\n      const expectedTime = moment('2000-01-01 00:00:00 Z', 'YYYY-MM-DD H:m:s Z');\n      const snap = 60 * 60 * 24 * 1000;\n      const actualTime = timeSnap(testTime, snap);\n      expect(actualTime.unix()).to.equal(expectedTime.unix());\n    });\n  });\n  describe('getTimeAtPixel', function() {\n    it('should return start time for 0', function() {\n      const visStart = moment('2000-01-01 00:00:00 Z', 'YYYY-MM-DD H:m:s Z');\n      const visEnd = moment('2000-01-08 00:00:00 Z', 'YYYY-MM-DD H:m:s Z'); // 7 days\n      const timelineWidth = 2000; //2000 px\n      const pixelOffset = 0;\n      let time = getTimeAtPixel(pixelOffset, visStart, visEnd, timelineWidth);\n      expect(time.unix()).to.equal(visStart.unix());\n    });\n    it('should return before start for -ve pixels', function() {\n      const visStart = moment('2000-01-01 00:00:00 Z', 'YYYY-MM-DD H:m:s Z');\n      const visEnd = moment('2000-01-08 00:00:00 Z', 'YYYY-MM-DD H:m:s Z'); // 7 days\n      const timelineWidth = 2000; //2000 px\n      const pixelOffset = -40;\n      let time = getTimeAtPixel(pixelOffset, visStart, visEnd, timelineWidth);\n      expect(time.unix()).to.lt(visStart.unix());\n    });\n    it('should return end time for width pixels', function() {\n      const visStart = moment('2000-01-01 00:00:00 Z', 'YYYY-MM-DD H:m:s Z');\n      const visEnd = moment('2000-01-08 00:00:00 Z', 'YYYY-MM-DD H:m:s Z'); // 7 days\n      const timelineWidth = 2000; //2000 px\n      const pixelOffset = 2000;\n      let time = getTimeAtPixel(pixelOffset, visStart, visEnd, timelineWidth);\n      expect(time.unix()).to.equal(visEnd.unix());\n    });\n    it('should return higher than width for over width pixels', function() {\n      const visStart = moment('2000-01-01 00:00:00 Z', 'YYYY-MM-DD H:m:s Z');\n      const visEnd = moment('2000-01-08 00:00:00 Z', 'YYYY-MM-DD H:m:s Z'); // 7 days\n      const timelineWidth = 2000; //2000 px\n      const pixelOffset = 2400;\n      let time = getTimeAtPixel(pixelOffset, visStart, visEnd, timelineWidth);\n      expect(time.unix()).to.gt(visEnd.unix());\n    });\n    it('should return correct fraction of time for given pixel location', function() {\n      const visStart = moment('2000-01-01 00:00:00 Z', 'YYYY-MM-DD H:m:s Z');\n      const visEnd = moment('2000-01-08 00:00:00 Z', 'YYYY-MM-DD H:m:s Z'); // 7 days\n      const timelineWidth = 2100; //2000 px\n      const pixelOffset = 300;\n      const expectedTime = visStart.clone().add((pixelOffset / timelineWidth) * 7, 'days');\n      let time = getTimeAtPixel(pixelOffset, visStart, visEnd, timelineWidth);\n      expect(time.unix()).to.equal(expectedTime.unix());\n    });\n  });\n  describe('getPixelAtTime', function() {\n    it('should return 0 for start time', function() {\n      const visStart = moment('2000-01-01 00:00:00 Z', 'YYYY-MM-DD H:m:s Z');\n      const visEnd = moment('2000-01-08 00:00:00 Z', 'YYYY-MM-DD H:m:s Z'); // 7 days\n      const timelineWidth = 2000; //2000 px\n      const testTime = visStart.clone();\n      let pixels = getPixelAtTime(testTime, visStart, visEnd, timelineWidth);\n      expect(pixels).to.equal(0);\n    });\n    it('should return -ve for before start time', function() {\n      const visStart = moment('2000-01-01 00:00:00 Z', 'YYYY-MM-DD H:m:s Z');\n      const visEnd = moment('2000-01-08 00:00:00 Z', 'YYYY-MM-DD H:m:s Z'); // 7 days\n      const timelineWidth = 2000; //2000 px\n      const testTime = moment('1999-12-30 00:00:00 Z', 'YYYY-MM-DD H:m:s Z');\n      let pixels = getPixelAtTime(testTime, visStart, visEnd, timelineWidth);\n      expect(pixels).to.lt(0);\n    });\n    it('should return width for end time', function() {\n      const visStart = moment('2000-01-01 00:00:00 Z', 'YYYY-MM-DD H:m:s Z');\n      const visEnd = moment('2000-01-08 00:00:00 Z', 'YYYY-MM-DD H:m:s Z'); // 7 days\n      const timelineWidth = 2000; //2000 px\n      const testTime = visEnd.clone();\n      let pixels = getPixelAtTime(testTime, visStart, visEnd, timelineWidth);\n      expect(pixels).to.equal(timelineWidth);\n    });\n    it('should return greater than width for after end time', function() {\n      const visStart = moment('2000-01-01 00:00:00 Z', 'YYYY-MM-DD H:m:s Z');\n      const visEnd = moment('2000-01-08 00:00:00 Z', 'YYYY-MM-DD H:m:s Z'); // 7 days\n      const timelineWidth = 2000; //2000 px\n      const testTime = moment('2000-01-09 00:00:00 Z', 'YYYY-MM-DD H:m:s Z');\n      let pixels = getPixelAtTime(testTime, visStart, visEnd, timelineWidth);\n      expect(pixels).to.gt(timelineWidth);\n    });\n    it('should return correct pixels for given fraction of time', function() {\n      const visStart = moment('2000-01-01 00:00:00 Z', 'YYYY-MM-DD H:m:s Z');\n      const visEnd = moment('2000-01-08 00:00:00 Z', 'YYYY-MM-DD H:m:s Z'); // 7 days\n      const timelineWidth = 2000; //2000 px\n      const testTime = moment('2000-01-04 12:00:00 Z', 'YYYY-MM-DD H:m:s Z');\n      const expectedPixels = timelineWidth * (3.5 / 7);\n      let pixels = getPixelAtTime(testTime, visStart, visEnd, timelineWidth);\n      expect(pixels).to.equal(expectedPixels);\n    });\n  });\n  describe('getDurationFromPixels', function() {\n    it('should return 0 for 0 pixels', function() {\n      const visStart = moment('2000-01-01 00:00:00 Z', 'YYYY-MM-DD H:m:s Z');\n      const visEnd = moment('2000-01-08 00:00:00 Z', 'YYYY-MM-DD H:m:s Z'); // 7 days\n      const timelineWidth = 2000; //2000 px\n      const pixelOffset = 0;\n      let duration = getDurationFromPixels(pixelOffset, visStart, visEnd, timelineWidth);\n      expect(duration.asSeconds()).to.equal(0);\n    });\n    it('should return negative duration for -ve pixels', function() {\n      const visStart = moment('2000-01-01 00:00:00 Z', 'YYYY-MM-DD H:m:s Z');\n      const visEnd = moment('2000-01-08 00:00:00 Z', 'YYYY-MM-DD H:m:s Z'); // 7 days\n      const timelineWidth = 2000; //2000 px\n      const pixelOffset = -40;\n      let duration = getDurationFromPixels(pixelOffset, visStart, visEnd, timelineWidth);\n      expect(duration.asSeconds()).to.lt(0);\n    });\n    it('should return (visible end - visible start) for width pixels', function() {\n      const visStart = moment('2000-01-01 00:00:00 Z', 'YYYY-MM-DD H:m:s Z');\n      const visEnd = moment('2000-01-08 00:00:00 Z', 'YYYY-MM-DD H:m:s Z'); // 7 days\n      const timelineWidth = 2000; //2000 px\n      const pixelOffset = 2000;\n      const expectedDuration = visEnd.diff(visStart, 'seconds');\n      let duration = getDurationFromPixels(pixelOffset, visStart, visEnd, timelineWidth);\n      expect(duration.asSeconds()).to.equal(expectedDuration);\n    });\n    it('should return higher than (visible end - visible start) for over width pixels', function() {\n      const visStart = moment('2000-01-01 00:00:00 Z', 'YYYY-MM-DD H:m:s Z');\n      const visEnd = moment('2000-01-08 00:00:00 Z', 'YYYY-MM-DD H:m:s Z'); // 7 days\n      const timelineWidth = 2000; //2000 px\n      const pixelOffset = 2400;\n      let duration = getDurationFromPixels(pixelOffset, visStart, visEnd, timelineWidth);\n      expect(duration.asSeconds()).to.gt(moment.duration(7, 'days').asSeconds());\n    });\n    it('should return correct fraction of duration for given pixel location', function() {\n      const visStart = moment('2000-01-01 00:00:00 Z', 'YYYY-MM-DD H:m:s Z');\n      const visEnd = moment('2000-01-08 00:00:00 Z', 'YYYY-MM-DD H:m:s Z'); // 7 days\n      const timelineWidth = 2100; //2000 px\n      const pixelOffset = 300;\n      const expectedDuration = (pixelOffset / timelineWidth) * 7 * 24 * 60 * 60;\n      let duration = getDurationFromPixels(pixelOffset, visStart, visEnd, timelineWidth);\n      expect(duration.asSeconds()).to.equal(expectedDuration);\n    });\n  }),\n    describe('convertDateToMoment', function() {\n      it('should return the received date(moment) when useMoment is true', function() {\n        const date = moment('2000-01-01 00:00:00 Z', 'YYYY-MM-DD H:m:s Z');\n        const useMoment = true;\n        let expectedMoment = date;\n        let actualMoment = convertDateToMoment(date, useMoment);\n        expect(actualMoment).to.deep.equal(expectedMoment);\n      });\n      it('should convert date to moment when useMoment is false', function() {\n        const date = moment('2000-01-01 00:00:00 Z', 'YYYY-MM-DD H:m:s Z').valueOf();\n        const useMoment = false;\n        let expectedMoment = moment(date);\n        let actualMoment = convertDateToMoment(date, useMoment);\n        expect(actualMoment).to.deep.equal(expectedMoment);\n      });\n    }),\n    describe('convertMomentToDateType', function() {\n      it('should return moment when useMoment is true', function() {\n        const date = moment('2000-01-01 00:00:00 Z', 'YYYY-MM-DD H:m:s Z');\n        const useMoment = true;\n        let expectedMoment = date;\n        let actualMoment = convertMomentToDateType(date, useMoment);\n        expect(actualMoment).to.deep.equal(expectedMoment);\n      });\n      it('should return date in millis when useMoment is false', function() {\n        const date = moment('2000-01-01 00:00:00 Z', 'YYYY-MM-DD H:m:s Z');\n        const useMoment = false;\n        let expectedDate = 946684800000;\n        let actualDate = convertMomentToDateType(date, useMoment);\n        expect(actualDate).to.deep.equal(expectedDate);\n      });\n    });\n});\n",
    "static": true,
    "longname": "/home/poweruser/git/react-timeline-10000/src/utils/timeUtils.test.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "kind": "index",
    "content": "# React Timeline 10000 (forked by the Flower Platform team)\n\n## Intro\n\nThis fork is developed and maintained by the \"Flower Platform\" team (which FYI has authored in the past [Gantt4Flex](http://gantt4flex.crispico.com/), a popular (at that time) commercial Gantt diagramming component during the [Adobe Flex](http://flex.apache.org/) era). The motivation of our contributions is driven by the fact that we use \"react-timeline-9000\" in some of our industrial projects. The intention is to develop new features that we can use ASAP in our software. ALL our contributions are meant to be integrated in the upstream repo, so they are developed having this constraint in mind. The upstream repo is the **official** one (for releases, clone, adding issues, etc.). And this is to be considered as an internal repo for us = the Flower Platform team.\n\nAdmin discussions w/ the upstream repo team are held in [this discussion](https://github.com/React9k/react-timeline-9000/discussions/255).\n\n## Process and versioning\n\n`package.json` on the **upstream repo** / `master` branch looks like this:\n\n```\n{\n  \"name\": \"react-timeline-9000\",\n  \"version\": \"1.1.3\",\n  ...\n```\n\nBut in **this repo** / `master-flower-platform` branch (which is considered to be the main branch of this repo) we have:\n\n```\n{\n  \"name\": \"@crispico/react-timeline-10000\",\n  \"version\": \"1.1.3-fp-ver-3\",\n  ...\n```\n\nThe `name` is changed so that we can publish it in our local NPM repo. We append to the original `version` the suffix `-fp-ver-N`. Where N is the version from Flower Platform. E.g. 3 means we added 3 commits compared to the original upstream. When a new contribution is added to our main branch = `master-flower-platform`, we increment this number. So we'll have e.g.: *1.1.3-fp-ver-**4***, *1.1.3-fp-ver-**5***, *1.1.**4**-fp-ver-**5***, *1.1.**4**-fp-ver-**6***, etc.\n\nBefore we begin new work, we should first create an issue in the upstream repo:\n* we prefix it w/ *[rt10000]*, like in this [example](https://github.com/React9k/react-timeline-9000/issues/190);\n* we explain what we want to do and ask for advice if needed.\n\nNew work is always done on new branches. E.g. `my-new-branch`. At the end of the work we **squash everything into a single commit** and perform a pull request towards upstream (mentioning the original issue cf. above). If we need the commit ASAP into our main branch:\n* we don't need to wait for their approval of the PR;\n* we make a PR and/or merge it into `master-flower-platform`;\n* then, we increment *fp-ver-N* to *fp-ver-N+1* cf. above.\n\n## Tracking of the pull requests submitted to the upstream repo\n\nWe prefix our issues in the upstream repo w/ `[rt10000]`.\n\n| Issue (mouse hover for title) | Pull request | Merged |\n| - | - | - |\n| React9k/react-timeline-9000#190 | React9k/react-timeline-9000#243 | yes |\n| React9k/react-timeline-9000#196 | React9k/react-timeline-9000#239 | yes |\n| React9k/react-timeline-9000#221 | React9k/react-timeline-9000#241 | yes |\n| React9k/react-timeline-9000#234 | React9k/react-timeline-9000#237 | yes |\n| minor | React9k/react-timeline-9000#257 | yes |\n| minor | React9k/react-timeline-9000#260 | yes |\n| React9k/react-timeline-9000#271 | React9k/react-timeline-9000#272 |  |\n\n## Original `README.md` of the upstream repo is below\n\n---\n\nA performance focused timeline component in react\n## Build Status\n[![Build Status](https://travis-ci.org/BHP-DevHub/react-timeline-9000.svg?branch=master)](https://travis-ci.org/BHP-DevHub/react-timeline-9000)\n[![CodeFactor](https://www.codefactor.io/repository/github/bhp-devhub/react-timeline-9000/badge)](https://www.codefactor.io/repository/github/bhp-devhub/react-timeline-9000)\n[![npm (scoped)](https://img.shields.io/npm/v/react-timeline-9000.svg)](https://www.npmjs.com/package/react-timeline-9000)\n\n## Demo\n* http://react-timeline-9000.s3-website-ap-southeast-2.amazonaws.com/\n\n## Documentation\n* http://react-timeline-9000.s3-website-ap-southeast-2.amazonaws.com/docs/\n\n\n## Getting Started\n\n| Action         | Command                               |\n| -------------- | ------------------------------------- |\n| Build          | `$ make`                              |\n| Test           | `$ make test` or  `$ make test-watch` |\n| Run dev server | `$ make run`                          |\n\n* Add `import react-timeline-9000/lib/style.css` (or use your own styles based on this file)\n\n## Contributing\nFeel free to make a PR :)\n\n# Interaction\n\nDefault interaction for multiple selection is largely governed by the leading item, which is defined as the item that is directly interacted with when multiple items are selected.\n\n## Dragging\n\nAll items will move by the same horizontal delta and row changes will be calculated by the row delta of the leading item\n\n## Resizing\n\nAll items will gain the resize delta from the leading item.\n\n### Overriding the default behaviour\n\nTBA\n\n`onInteraction(type, changes, leadTimeDelta, leaderGroupDelta,selectedItems)` \n\n# Props Summary\n\nSee http://react-timeline-9000.s3-website-ap-southeast-2.amazonaws.com/docs/ for detailed docs\n\n## Props\n| Name               | Default     | Description                                                                                                                                              |\n| ----------------   | -------     | ------------------------------------------------------------------------------------------------------------                                             |\n| groupOffset        |             |                                                                                                                                                          |\n| startDate          |             |                                                                                                                                                          |\n| endDate            |             |                                                                                                                                                          |\n| snapMinutes        |             |                                                                                                                                                          |\n| showCursorTime     |             |                                                                                                                                                          |\n| cursorTimeFormat   |             |                                                                                                                                                          |\n| itemHeight         |             |                                                                                                                                                          |\n| timelineMode       |             |                                                                                                                                                          |\n| timebarFormat      |             |                                                                                                                                                          |\n| itemRenderer       |             |                                                                                                                                                          |\n| itemStyle          | | Style applied to all items      |\n| itemClassName      | | Class name applied to all items |\n| groupRenderer      |             |                                                                                                                                                          |\n| shallowUpdateCheck | False       | If true timeline will try to minimize re-renders . Set to false if items don't show up/update on prop change                                             |\n| forceRedrawFunc  | () => False | Function called when `shallowUpdateCheck`==true. If returns true the timeline will be redrawn. If false the library will decide if redrawing is required |\n| useMoment        | True        | If true timeline will use moment for dates (including for items and rowLayers); otherwise the type for dates is number |\n\n## Data\n| Name             |\n| ---------------- |\n| items            |\n| groups           |\n| selectedItems    |\n\n### Items\n\nRequired props:\n* key - number\n\n### Groups\n\nRequired props:\n* id - number - needs to be consecutive\n\n## Callbacks\n| Name              |\n| ----------------  |\n| onItemClick       |\n| onItemDoubleClick |\n| onItemContext     |\n| onInteraction     |\n| onRowClick        |\n| onRowContext      |\n| onRowDoubleClick  |\n| onItemHover       |\n| onItemLeave       |\n\n# Styling\n* View `src/style.css` for styling examples.\n* For the default styles, import `react-timeline-9000/lib/style.css`\n\n### Default Z-indexes\n| Item                                  | Index |\n| ------------------------------------- | ----- |\n| Row Layers                            | 1     |\n| Vertical markers                      | 2     |\n| Timeline items                        | 3     |\n| Timeline items when dragging/resizing | 4     |\n| Selection box (for multi-select)      | 5     |\n| Group column                          | 6     |\n\n",
    "longname": "/home/poweruser/git/react-timeline-10000/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"name\": \"@crispico/react-timeline-10000\",\n  \"version\": \"2.1.0\",\n  \"description\": \"Performance focused timeline for react\",\n  \"private\": false,\n  \"types\": \"./types/index.d.ts\",\n  \"scripts\": {\n    \"build\": \"yarn tsc && webpack --config webpack.prod.js\",\n    \"build_lib\": \"yarn tsc && babel src --out-dir lib -x '.js,.jsx,.mdx,.html,.tsx' --ignore **/demo.js,**/demo_index.js,**/demo.html,**/demo/,**/setupTests.js,**/*/*.test.js,**/stories/ --copy-files --source-maps inline --no-copy-ignored\",\n    \"build_demo\": \"webpack --config webpack.demo.prod.js\",\n    \"start\": \"webpack-dev-server --open --config webpack.dev.js\",\n    \"docs\": \"esdoc && mv docs/index.html docs/index-docs.html\",\n    \"pretty\": \"prettier --write --tab-width 4 \\\"src/**/*.js\\\"\",\n    \"precommit\": \"lint-staged\",\n    \"storybook\": \"yarn tsc && start-storybook -p 6006\",\n    \"storybook-build\": \"yarn tsc && yarn docs && build-storybook\",\n    \"storybook-move\": \"rm -r ../flower-platform.github.io/foundation-react-gantt; mv storybook-static ../flower-platform.github.io/foundation-react-gantt\",\n    \"storybook-build-move\": \"yarn storybook-build && yarn storybook-move\",\n    \"tsc\": \"tsc && cp src/types.d.ts types/types.d.ts\"\n  },\n  \"lint-staged\": {\n    \"src/**/*.{js,jsx,json,css}\": [\n      \"prettier --single-quote --write\",\n      \"git add\"\n    ]\n  },\n  \"keywords\": [\n    \"react\",\n    \"timeline\"\n  ],\n  \"engines\": {\n    \"node\": \">=4.2.4\"\n  },\n  \"author\": \"Leighton Lilford\",\n  \"license\": \"MIT\",\n  \"files\": [\n    \"lib\",\n    \"types\"\n  ],\n  \"main\": \"lib/index.js\",\n  \"homepage\": \"https://github.com/flower-platform/react-timeline-10000\",\n  \"devDependencies\": {\n    \"@babel/cli\": \"^7.0.0\",\n    \"@storybook/addon-actions\": \"^6.3.11\",\n    \"@storybook/addon-essentials\": \"^6.3.11\",\n    \"@storybook/addon-links\": \"^6.3.11\",\n    \"@storybook/addon-storysource\": \"^6.5.12\",\n    \"@storybook/react\": \"^6.3.11\",\n    \"antd\": \"^3.6.5\",\n    \"babel-loader\": \"^8.2.5\",\n    \"chai\": \"^4.1.2\",\n    \"core-js\": \"^2.4.0\",\n    \"css-loader\": \"^0.28.11\",\n    \"enzyme\": \"^3.3.0\",\n    \"enzyme-adapter-react-16\": \"^1.1.1\",\n    \"esdoc\": \"^1.1.0\",\n    \"esdoc-ecmascript-proposal-plugin\": \"^1.0.0\",\n    \"esdoc-inject-style-plugin\": \"^1.0.0\",\n    \"esdoc-jsx-plugin\": \"^1.0.0\",\n    \"esdoc-standard-plugin\": \"^1.0.0\",\n    \"eslint\": \"^5.0.1\",\n    \"eslint-config-prettier\": \"^2.9.0\",\n    \"eslint-plugin-babel\": \"^5.1.0\",\n    \"eslint-plugin-import\": \"^2.12.0\",\n    \"eslint-plugin-prettier\": \"^2.6.0\",\n    \"eslint-plugin-react\": \"^7.10.0\",\n    \"html-webpack-plugin\": \"5.5.0\",\n    \"husky\": \"^0.14.3\",\n    \"ignore-styles\": \"^5.0.1\",\n    \"jsdom\": \"^16.5.0\",\n    \"lint-staged\": \"8.2.1\",\n    \"mocha\": \"^5.2.0\",\n    \"prettier\": \"^1.13.5\",\n    \"react\": \"^17.0.2\",\n    \"react-dom\": \"^17.0.2\",\n    \"semantic-ui-css\": \"^2.5.0\",\n    \"semantic-ui-react\": \"^2.1.3\",\n    \"style-loader\": \"^0.21.0\",\n    \"tern\": \"^0.21.0\",\n    \"typescript\": \"~4.4.0\",\n    \"uglifyjs-webpack-plugin\": \"^2.2.0\",\n    \"webpack\": \"^5.67.0\",\n    \"webpack-cli\": \"^4.9.2\",\n    \"webpack-dev-server\": \"^4.7.3\",\n    \"webpack-merge\": \"^5.8.0\"\n  },\n  \"dependencies\": {\n    \"color\": \"^4.2.3\",\n    \"core-js\": \"^2.4.0\",\n    \"interactjs\": \"^1.6.2\",\n    \"lodash\": \"^4.17.19\",\n    \"moment\": \"^2.22.2\",\n    \"react-virtualized\": \"^9.19.1\"\n  },\n  \"peerDependencies\": {\n    \"react\": \"^16.4.1 || ^17.0.0\",\n    \"react-dom\": \"^16.4.1 || ^17.0.0\"\n  }\n}\n",
    "longname": "/home/poweruser/git/react-timeline-10000/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  }
]