"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[3440],{97932:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>h,contentTitle:()=>l,default:()=>m,frontMatter:()=>c,metadata:()=>d,toc:()=>u});var t=n(85893),o=n(11151),s=n(93598);const i={text:'import { Utils } from "@crispico/foundation-react";\nimport { TraceMapCache } from "@famiprog-foundation/tests-are-demo/dist-lib/lib/TraceMapCache";\nimport { TestableTimers } from "../utils/TestableTimers";\n\n// #region testable-timers-field1\nexport class ClientErrorLogger {\n// #endregion\n\n    queueCapacity = 10;\n    retryIntervalMs = 15000;\n\n    protected errorQueue: string[] | undefined;\n\n    /**\n     * Type is number. But there seem to be an error in the types. Or rather conflict w/ the function from node.js\n     */\n    protected retryTimeoutId?: any;\n\n    protected sendInProgress = false;\n\n    // #region testable-timers-field2\n    timers = new TestableTimers();\n    // #endregion\n\n    constructor() {\n        this.addToQueueAndTryToSend = this.addToQueueAndTryToSend.bind(this);\n        this.sendFromQueue = this.sendFromQueue.bind(this);\n        this.onError = this.onError.bind(this);\n        this.onUnhandledRejection = this.onUnhandledRejection.bind(this);\n    }\n\n    public start() {\n        if (this.errorQueue) {\n            throw new Error("Cannot call start() twice");\n        }\n        this.errorQueue = [];\n        window.addEventListener("error", this.onError);\n        // when a promise was rejected (returns an error) cf. https://developer.mozilla.org/en-US/docs/Web/API/Window/unhandledrejection_event\n        window.addEventListener("unhandledrejection", this.onUnhandledRejection);\n        \n        return this;\n    }\n\n    public stop() {\n        window.removeEventListener("error", this.onError);\n        window.removeEventListener("unhandledrejection", this.onUnhandledRejection);\n        this.errorQueue = undefined;\n    }\n\n    protected onError(e: ErrorEvent) {\n        this.addToQueueAndTryToSend(e.error);\n    }\n\n    protected onUnhandledRejection(e: PromiseRejectionEvent) {\n        this.addToQueueAndTryToSend(e.reason);\n    }\n\n    protected async addToQueueAndTryToSend(e: Error) {\n        const error = await TraceMapCache.INSTANCE.decodeStackTrace(e);\n        if (!error || !this.errorQueue || this.errorQueue.length >= this.queueCapacity) {\n            return;\n        }\n\n        this.errorQueue.push(error);\n        this.sendFromQueue();\n    }\n\n    protected async sendFromQueue() {\n        if (!this.errorQueue || this.sendInProgress) {\n            // the previous error is "in flight". So the previous call to sendQueue() is "paused". We don\'t do anything. When\n            // it will be back, the loop will find the newly added error in the queue and send it also\n            return;\n        }\n        // if a timer is in progress, let\'s stop it; we don\'t want it to interfere during the async call below\n        this.clearTimeout();\n        // in theory (and in practice also I hope), if we enter this function, we have at least one error. Even\n        // for the timer.\n        do {\n            const error = this.errorQueue[0];\n            try {\n                this.sendInProgress = true;\n                await this.sendError(error);\n            } catch {\n                this.setTimeout();\n                this.sendInProgress = false;\n                return;\n            } finally {\n                this.sendInProgress = false;\n            }\n            // send to server succeeded\n            this.errorQueue = this.errorQueue.slice(1);\n        } while (this.errorQueue.length);\n    }\n\n    protected async sendError(error: string) {\n        const url = Utils.adjustUrlToServerContext(\'clientErrorLogger/logClientError\');\n        await fetch(url!, { method: \'PUT\', body: error });\n    }\n\n    protected setTimeout() {\n        // #region testable-timers-use\n        this.retryTimeoutId = this.timers.setTimeout(this.sendFromQueue, this.retryIntervalMs);\n        // #endregion testable-timers-use\n    }\n\n    protected clearTimeout() {\n        this.retryTimeoutId =  this.timers.clearTimeout(this.retryTimeoutId);\n    }\n}\n',path:"foundation-react/src/foundation-react/clientErrorLogger/ClientErrorLogger.ts"};var a=n(12073);const c={},l=void 0,d={id:"foundation-react/utils/TestableTimers",title:"TestableTimers",description:"The technique to test code that uses timers is the following:",source:"@site/docs/foundation-react/utils/TestableTimers.md",sourceDirName:"foundation-react/utils",slug:"/foundation-react/utils/TestableTimers",permalink:"/docusaurus/docs/foundation-react/utils/TestableTimers",draft:!1,unlisted:!1,editUrl:"https://gitlab.xops-online.com/foundation/foundation-jhipster-gwt/-/blob/master/docusaurus/docs/foundation-react/utils/TestableTimers.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"cellContextMenu",permalink:"/docusaurus/docs/foundation-react/EntityTablePage/cellContextMenu"},next:{title:"foundation-server",permalink:"/docusaurus/docs/category/foundation-server"}},h={},u=[{value:"Instructions for devs",id:"instructions-for-devs",level:2}];function g(e){const r={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.p,{children:"The technique to test code that uses timers is the following:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["Before the test, we ",(0,t.jsx)(r.strong,{children:"replace the timers"})," w/ a mocks."]}),"\n",(0,t.jsxs)(r.li,{children:["During the test, from the test code, we ",(0,t.jsx)(r.strong,{children:"trigger ourselves"})," the timer by invoking the mock. I.e. we control time."]}),"\n",(0,t.jsx)(r.li,{children:'E.g. if a code adds a timer for 5 seconds, our test won\'t wait those 5 seconds. Our test code will say "the 5 seconds have passed; please continue".'}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(s.lj,{children:"foundation-react/src/foundation-react/utils/TestableTimers.ts"})," helps us in applying this technique. This class implements the same interface as ",(0,t.jsx)(r.code,{children:"FakeTimers.createClock()"})," from ",(0,t.jsx)(r.a,{href:"https://github.com/sinonjs/fake-timers#var-clock--faketimerscreateclocknow-looplimit",children:"Sinon.JS / Fake timers lib"}),". ",(0,t.jsx)(r.a,{href:"https://sinonjs.org/",children:"Sinon.JS"})," is a popular library for dealing w/ mocks in JS."]}),"\n",(0,t.jsx)(r.h2,{id:"instructions-for-devs",children:"Instructions for devs"}),"\n",(0,t.jsxs)(r.p,{children:["Instructions extracted from ",(0,t.jsx)(r.code,{children:"ClientErrorLogger"})," & co."]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(s.h8,{s:"1"})," We create an instance of ",(0,t.jsx)(r.code,{children:"TestableTimers"}),", as a field in our class."]}),"\n",(0,t.jsx)(s.M_,{src:i,region:"testable-timers-field1"}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.code,{children:"..."})}),"\n",(0,t.jsx)(s.M_,{src:i,region:"testable-timers-field2"}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(s.h8,{s:"2"})," When we need a timer, instead of invoking the normal function, we invoke the one from our instance."]}),"\n",(0,t.jsx)(s.M_,{src:i,region:"testable-timers-use"}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(s.h8,{s:"3"})," At the beginning of the test, replace the instance of ",(0,t.jsx)(r.code,{children:"TestableTimers"})," w/ a ",(0,t.jsx)(r.code,{children:"BrowserClock"})," from sinon."]}),"\n",(0,t.jsx)(s.M_,{src:a.Z,region:"testable-timers-mock1a"}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.code,{children:"..."})}),"\n",(0,t.jsx)(s.M_,{src:a.Z,region:"testable-timers-mock1b"}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.code,{children:"..."})}),"\n",(0,t.jsx)(s.M_,{src:a.Z,region:"testable-timers-mock2a"}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.code,{children:"..."})}),"\n",(0,t.jsx)(s.M_,{src:a.Z,region:"testable-timers-mock2b"}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(s.h8,{s:"4"}),' In the test, "control the time". I.e. after a function that is using a timer is invoked, fire the timer "manually".']}),"\n",(0,t.jsx)(s.M_,{src:a.Z,region:"testable-timers-mock-use1"}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.code,{children:"..."})}),"\n",(0,t.jsx)(s.M_,{src:a.Z,region:"testable-timers-mock-use2"}),"\n",(0,t.jsx)(r.admonition,{type:"note",children:(0,t.jsxs)(r.p,{children:["During tests, ",(0,t.jsx)(r.code,{children:"ClientErrorLogger.timers: TestableTimers"})," and ",(0,t.jsx)(r.code,{children:"clock: BrowserClock"})," are the same instance. But in the test we manipulate it using ",(0,t.jsx)(r.code,{children:"clock"}),", because the ",(0,t.jsx)(r.code,{children:"BrowserClock"})," type is richer, exposing methods such as ",(0,t.jsx)(r.code,{children:"runAllSync()"}),"."]})}),"\n",(0,t.jsx)(r.admonition,{type:"note",children:(0,t.jsxs)(r.p,{children:["The ",(0,t.jsx)(r.a,{href:"https://github.com/sinonjs/fake-timers",children:"@sinonjs/fake-timers"})," have other interesting functions. Depending on your case, they might come in handy. The library is even capable of mocking global functions such as ",(0,t.jsx)(r.code,{children:"setTimeout()"}),". However, this is not a good practice. Maybe you'll interfere w/ other timers, that you don't want to mock. A good example is the TestsAreDemo library. Mocking the global timer functions breaks things in the library."]})})]})}function m(e={}){const{wrapper:r}={...(0,o.a)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(g,{...e})}):g(e)}},93598:(e,r,n)=>{n.d(r,{sS:()=>h,Tm:()=>u,M_:()=>g,Fb:()=>m,JR:()=>f,lj:()=>l,h8:()=>d});n(67294);class t{static now(){return new Date}static consoleLogJson(e,r){void 0===r&&(r=!0);const n=JSON.stringify(e,(()=>{const e=new WeakSet;return(r,n)=>{if(!r.startsWith("__react")){if("object"==typeof n&&null!==n){if(e.has(n))return;e.add(n)}return n}}})(),2);return r&&console.log(n),n}static substringAfter(e,r,n){const t=n?e.lastIndexOf(r):e.indexOf(r);return t<0?e:e.substring(t+r.length)}static setTimeoutPromise(e,r){return new Promise((n=>setTimeout((()=>{const r=e?.();n(r)}),r)))}}var o=n(9286),s=n(25142),i=n(73981),a=n(91262),c=n(85893);const l=e=>{return(0,c.jsx)(c.Fragment,{children:(0,c.jsxs)("a",{target:"_blank",href:(r=e.children,(r.startsWith("foundation/")?"https://gitlab.xops-online.com/foundation/foundation/-/tree/main/"+t.substringAfter(r,"foundation/"):"https://gitlab.xops-online.com/foundation/foundation-jhipster-gwt/-/tree/master/"+r)+(e.lineNumbers?.[0]?`#L${e.lineNumbers[0]}`:"")+(e.lineNumbers?.[1]?`-L${e.lineNumbers[1]}`:"")),children:[t.substringAfter(e.children,"/",!0),e.region&&(0,c.jsxs)("small",{children:["\xa0",(0,c.jsxs)("i",{children:["(region ",e.region,",\xa0",e.lineNumbers[0]===e.lineNumbers[1]?(0,c.jsxs)(c.Fragment,{children:["at line ",e.lineNumbers[0]]}):(0,c.jsxs)(c.Fragment,{children:["between lines [",e.lineNumbers[0],", ",e.lineNumbers[1],"])"]})]})]})]})});var r},d=e=>(0,c.jsx)(s.Z,{circular:!0,color:"blue",children:e.s}),h=e=>{let{src:{text:r,path:n},region:t,...s}=e;const i=new RegExp(`#region\\s*${t}[^\\r\\n]*\\r?\\n(.*?)#endregion`,"s").exec(r);if(!i)throw new Error(`In file = ${n}, cannot find region = ${t}, i.e. a portion like:\n\n#region ${t}\n...\n#endregion`);let a,d=1,h=-1;for(a=0;a<i.index+i[0].length;a++)"\n"===r[a]&&d++,-1===h&&a>=i.index&&(h=d);h++,d--;let u=i[1];u=/(.*)(\r?\n.*?$)/gs.exec(u)[1],u="\n"+u;const g=u.match(/\n(\s)*\S/);let m;if(g&&(m=g[1])){const e=new RegExp(`\\n(${m}*)\\S`,"g");let r,n=-1;for(;null!==(r=e.exec(u));)(n<0||n>r[1].length)&&(n=r[1].length);const t=m.repeat(n);u=u.replace(new RegExp("\\n"+t,"g"),"\n")}return u=u.substring(1),(0,c.jsx)(c.Fragment,{children:(0,c.jsx)(o.Z,{title:(0,c.jsxs)(c.Fragment,{children:["Snippet extracted from ",(0,c.jsx)(l,{region:t,lineNumbers:[h,d],children:n})]}),...s,children:u})})},u=e=>(0,c.jsx)(h,{language:"java",...e}),g=e=>(0,c.jsx)(h,{language:"ts",...e}),m=e=>(0,c.jsx)(a.Z,{children:()=>(0,c.jsx)(i.J6,{recordedTestsUrl:"https://gitlab.xops-online.com/foundation/foundation-jhipster-gwt/-/raw/master/leave-management/leave-management-react/public/recordedTests/recordedTest.json",includeCredentialsInJsonRequestRegex:/https:\/\/gitlab\.xops-online\.com\/*/,...e})}),f=e=>(0,c.jsx)(a.Z,{children:()=>(0,c.jsx)(i.J6,{recordedTestsUrl:"https://gitlab.xops-online.com/foundation/foundation-jhipster-gwt/-/raw/master/leave-management/leave-management-react/public/recordedTestsServer/recordedTest.json",includeCredentialsInJsonRequestRegex:/https:\/\/gitlab\.xops-online\.com\/*/,...e})})},12073:(e,r,n)=>{n.d(r,{Z:()=>t});const t={text:'import { ClientErrorLoggerForTests } from "./ClientErrorLoggerForTests";\nimport { Scenario, tad } from "@famiprog-foundation/tests-are-demo";\nimport { TraceMapCache } from "@famiprog-foundation/tests-are-demo/dist-lib/lib/TraceMapCache";\nimport { Utils } from "../utils/Utils";\nimport React from "react";\nimport { createClock, BrowserClock } from "@sinonjs/fake-timers";\n\ndeclare global {\n    var forTestingClientErrorLogger_onError: ((ev: ErrorEvent) => void) | undefined;\n    var forTestingClientErrorLogger_onUnhandledRejection: ((ev: PromiseRejectionEvent) => void) | undefined;\n}\n\n// #region testable-timers-mock1a\nexport class ClientErrorLoggerTad extends React.Component {\n// #endregion testable-timers-mock1a\n\n    clientErrorLoger!: ClientErrorLoggerForTests;\n\n    // #region testable-timers-mock1b\n    clock!: BrowserClock;\n    // #endregion testable-timers-mock1b\n\n    // #region testable-timers-mock2a\n    async before() {\n        // #endregion testable-timers-mock2a\n        this.clientErrorLoger = new ClientErrorLoggerForTests().start();\n        // #region testable-timers-mock2b\n        this.clock = this.clientErrorLoger.timers = createClock() as BrowserClock;\n        // #endregion testable-timers-mock2b\n        window.forTestingClientErrorLogger_onError = (e: ErrorEvent) => {\n            e.stopImmediatePropagation(); e.preventDefault();\n            window.dispatchEvent(new ErrorEvent("error_forwarded", e));\n        }\n        window.forTestingClientErrorLogger_onUnhandledRejection = (e: PromiseRejectionEvent) => {\n            e.stopImmediatePropagation(); e.preventDefault();\n            window.dispatchEvent(new PromiseRejectionEvent("unhandledrejection_forwarded", e));\n        }\n    }\n\n    async after() {\n        this.clientErrorLoger.stop();\n        window.forTestingClientErrorLogger_onUnhandledRejection = undefined;\n        window.forTestingClientErrorLogger_onError = undefined;\n    }\n\n    async beforeEach() {\n        const url = Utils.adjustUrlToServerContext("clientErrorLoggerTadHelper/deleteLogContent");\n        await fetch(url!, { method: "POST" });\n        await tad.waitForCommunicationFinished();\n    }\n\n    /**\n     * In the file: `logs/client-error.log` (cf. `logback-main.xml`) such errors look like this:\n     * \n     * ```\n     * 2024-01-29 16:17:18,938 [      XNIO-1 task-54] ClientErrorLoggerController: user = admin; session = ERuRWsgJRxqc2YhbqHrLdRBKN_0LZgTdly9tEvMn; error = Error: Generated Error for test\n     *      at ClientErrorLoggerTestsAreDemo.generateError (http://localhost:3000/.../leave-management/leave-management-react/src/@crispico/foundation-react/clientErrorLogger/ClientErrorLoggerTestsAreDemo.ts:131:1) [return new Error("Generated Error for test");]\n     *      at ClientErrorLoggerTestsAreDemo.whenCatchErrorThenLogIt (http://localhost:3000/.../leave-management/leave-management-react/src/@crispico/foundation-react/clientErrorLogger/ClientErrorLoggerTestsAreDemo.ts:54:1) [const error = this.generateError();]\n     *      ...\n     * ```\n     * \n     * Such an use case may be useful in **production**. E.g.:\n     * \n     * * Maybe some users have got errors that happen, but they don\'t notice something wrong w/ the app => nobody complains.\n     * * Maybe the app enters in an unstable state, but a browser refresh fixes it => nobody complains.\n     */\n    @Scenario("WHEN an unhandled error is caught, THEN it is sent to the server and logged")\n    async whenCatchErrorThenLogIt() {\n        // For the other tests we throw an error and we rely on the global handler to catch it. But in this case, the stack trace is not good\n        // enough to also test its content. Hence we throw it here, to have something precise to compare w/ what was logged.\n        const error = this.generateError();\n        this.clientErrorLoger.tadCatchError(error);\n        tad.waitForCommunicationFinishedNextTimeoutTemp(9000);\n        await tad.waitForCommunicationFinished();\n        const logContent = await this.getLogContent();\n        const loggedError = await TraceMapCache.INSTANCE.decodeStackTrace(error);\n        await tad.assertWaitable.include(logContent, loggedError)\n    }\n\n    /**\n     * ... AND the sending is periodically retried. WHEN the server is back online, THEN the queue is sent.\n     */\n    @Scenario("WHEN an error is caught, AND the server is not accessible, THEN it is queued ... ")\n    // #region testable-timers-mock-use1\n    async whenCatchErrorAndSendToServerOnSecondTry() {\n    // #endregion\n        this.clientErrorLoger.setFailSendError(true);\n        // because the code from index.html, mocha\'s uncaught error handler won\'t be triggred by this error\n        setTimeout(() => { throw this.generateError() }, 1);\n        await tad.waitForCommunicationFinished();\n        tad.cc("The send to server was failed, the timeout was registered.");\n        await tad.assertWaitable.isNumber(this.clientErrorLoger.getTimeoutId());\n        // the connection to server was establish\n        // #region testable-timers-mock-use2\n        this.clientErrorLoger.setFailSendError(false);\n        await this.clock.runAllAsync();\n        // #endregion testable-timers-mock-use\n        await tad.waitForCommunicationFinished();\n        tad.cc("The send to server was successful.");\n        await tad.assertWaitable.isUndefined(this.clientErrorLoger.getTimeoutId());\n        const numberLoggedErorrs = await this.getNumberLoggedErors();\n        tad.cc("The error was logged.");\n        await tad.assertWaitable.equal(numberLoggedErorrs, 1);\n    }\n\n    @Scenario("WHEN *multiple* errors are caught, AND the server is not accessible ...")\n    _() { }\n\n    @Scenario("... THEN all of them are queued AND sent later")\n    async whenCatchMultipleErrorsAndOnSecondCatchSendBoth() {\n        this.clientErrorLoger.setFailSendError(true);\n        setTimeout(() => { throw this.generateError() }, 1);\n        await tad.waitForCommunicationFinished();\n        tad.cc("The send to server was failed, the error was queued.");\n        await tad.assertWaitable.equal(this.clientErrorLoger.getQueueLen(), 1);\n        this.clientErrorLoger.setFailSendError(false);\n        // catch second error\n        setTimeout(() => { throw this.generateError() }, 1);\n        await tad.waitForCommunicationFinished();\n        tad.cc("The send to server was successful.");\n        await tad.assertWaitable.equal(this.clientErrorLoger.getQueueLen(), 0);\n        const numberLoggedErorrs = await this.getNumberLoggedErors();\n        tad.cc("The both errors was logged.");\n        await tad.assertWaitable.equal(numberLoggedErorrs, 2);\n    }\n\n    /**\n     * I.e. we send the first errors and discard the last ones. The queue is a normal queue, not a circular one.\n     * \n     * Actually this is a common use case for dev. W/o the queue & limit, if the server is down, every server call would generate an error.\n     * Including when trying to send errors, so say hello to an endless loop and an unresponsive browser.\n     */\n    @Scenario("... AND the queue is full, THEN new errors are rejected")\n    async whenCatchErrorsAndQueueIsFull() {\n        // this number need to be graher that this.clientErrorLogger.queueCapacity\n        const numberOfGeneratedErrors = 20;\n        this.clientErrorLoger.setFailSendError(true);\n        for (let i = 0; i < numberOfGeneratedErrors; i++) {\n            setTimeout(() => { throw this.generateError() }, 1);\n        }\n        await tad.waitForCommunicationFinished();\n        tad.cc(`Catch ${numberOfGeneratedErrors} errors and problems with send to server, keep only ${this.clientErrorLoger.queueCapacity}`);\n        await tad.assertWaitable.equal(this.clientErrorLoger.getQueueLen(), this.clientErrorLoger.queueCapacity);\n        this.clientErrorLoger.setFailSendError(false);\n        await this.clock.runAllAsync();\n        tad.waitForCommunicationFinishedNextTimeoutTemp(1500);\n        await tad.waitForCommunicationFinished();\n        const numberLoggedErorrs = await this.getNumberLoggedErors();\n        tad.cc("The errors was logged.");\n        await tad.assertWaitable.equal(numberLoggedErorrs, this.clientErrorLoger.queueCapacity);\n    }\n\n    private generateError() {\n        return new Error("Generated Error for test");\n    }\n\n    private async getLogContent() {\n        // #region tad-helper-from-client\n        const url = Utils.adjustUrlToServerContext("clientErrorLoggerTadHelper/logContent");\n        return (await fetch(url!, { method: "GET" })).text();\n        // #endregion\n    }\n\n    private async getNumberLoggedErors() {\n        const logContent = await this.getLogContent();\n        return logContent.match(/ClientErrorLoggerController/g)?.length || 0;\n    }\n}\n',path:"foundation-react/src/foundation-react/clientErrorLogger/ClientErrorLoggerTad.ts"}}}]);