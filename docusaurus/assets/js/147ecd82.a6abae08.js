(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[2824],{22921:(e,t,n)=>{"use strict";n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>g,default:()=>h,frontMatter:()=>c,metadata:()=>u,toc:()=>m});var r=n(85893),o=n(11151),i=n(93598);const a={text:'package com.crispico.foundation.server.clientErrorLogger;\n\nimport java.io.File;\nimport java.io.IOException;\n\nimport org.apache.commons.io.FileUtils;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport com.crispico.foundation.server.log.LogLocationPropertyDefiner;\n\n/**\n * @author Cristian Spiescu\n */\n// #region tad-helper-class\n@Controller\n@RequestMapping("/clientErrorLoggerTadHelper")\npublic class ClientErrorLoggerControllerTadHelper {\n\n\t@RequestMapping(value = "/deleteLogContent", method = RequestMethod.POST)\n\t@ResponseBody()\n\tpublic void deleteLogFileContent() throws IOException {\n\t\tFileUtils.write(this.getLogFile(), "", "utf-8", false);\n\t}\n// #endregion\n\n\t@RequestMapping(value = "/logContent", method = RequestMethod.GET)\n\t@ResponseBody()\n\tpublic String getLogFileContent() throws IOException {\n\t\treturn FileUtils.readFileToString(this.getLogFile(), "utf-8");\n\t}\n\n\tprivate File getLogFile() {\n\t\tString logPath = LogLocationPropertyDefiner.getLogPath("logs");\n\t\treturn new File(logPath + (logPath.length() > 0 ? "/" : "") + "logs/client-error.log");\n\t}\n}\n',path:"leave-management/leave-management-server/src/test/java/com/crispico/foundation/server/clientErrorLogger/ClientErrorLoggerControllerTadHelper.java"};var s=n(37548),l=n(12073);const c={},g=void 0,u={id:"tests-are-demo/Pattern: using ...TadHelper.java from TAD client tests",title:"Pattern: using ...TadHelper.java from TAD client tests",description:"Sometimes, during a TAD test that runs on the client, we may need the help of a bit of code that runs on the server. In order to perform/simulate some actions, and/or to do some verifications.",source:"@site/docs/tests-are-demo/Pattern: using ...TadHelper.java from TAD client tests.md",sourceDirName:"tests-are-demo",slug:"/tests-are-demo/Pattern: using ...TadHelper.java from TAD client tests",permalink:"/docusaurus/docs/tests-are-demo/Pattern: using ...TadHelper.java from TAD client tests",draft:!1,unlisted:!1,editUrl:"https://gitlab.xops-online.com/foundation/foundation-jhipster-gwt/-/blob/master/docusaurus/docs/tests-are-demo/Pattern: using ...TadHelper.java from TAD client tests.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Demo",permalink:"/docusaurus/docs/tests-are-demo/demo"},next:{title:"Tutorial",permalink:"/docusaurus/docs/tests-are-demo/old/tutorial"}},d={},m=[{value:"Instructions for devs",id:"instructions-for-devs",level:2}];function p(e){const t={code:"code",h2:"h2",li:"li",p:"p",ul:"ul",...(0,o.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:"Sometimes, during a TAD test that runs on the client, we may need the help of a bit of code that runs on the server. In order to perform/simulate some actions, and/or to do some verifications."}),"\n",(0,r.jsx)(t.h2,{id:"instructions-for-devs",children:"Instructions for devs"}),"\n",(0,r.jsxs)(t.p,{children:["Instructions extracted from ",(0,r.jsx)(t.code,{children:"ClientErrorLogger"})," & co. In this case, the helper does things such as:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"deleting some log files on the server before and/or after the test;"}),"\n",(0,r.jsx)(t.li,{children:"return log contents from the disk in order to perform verifications on the client, etc."}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(i.h8,{s:"1"})," We create a controller. Notice:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["the ",(0,r.jsx)(t.code,{children:"...TadHelper"})," suffix,"]}),"\n",(0,r.jsx)(t.li,{children:"the package == the package of the tested family of classes,"}),"\n",(0,r.jsxs)(t.li,{children:["but the folder is ",(0,r.jsx)(t.code,{children:"src/test/java"}),"."]}),"\n"]}),"\n",(0,r.jsx)(i.Tm,{src:a,region:"tad-helper-class"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(i.h8,{s:"2"})," Declare the bean in an ",(0,r.jsx)(t.code,{children:"@Configuration"})," file. Notice the usage of the test profile (hence instantiated only in test mode)."]}),"\n",(0,r.jsx)(i.Tm,{src:s.Z,region:"tad-helper-bean"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(i.h8,{s:"3"})," Call it from the TAD client test."]}),"\n",(0,r.jsx)(i.Tm,{src:l.Z,region:"tad-helper-from-client"})]})}function h(e={}){const{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}},93598:(e,t,n)=>{"use strict";n.d(t,{sS:()=>u,Tm:()=>d,M_:()=>m,Fb:()=>p,JR:()=>h,lj:()=>c,h8:()=>g});n(67294);class r{static now(){return new Date}static consoleLogJson(e,t){void 0===t&&(t=!0);const n=JSON.stringify(e,(()=>{const e=new WeakSet;return(t,n)=>{if(!t.startsWith("__react")){if("object"==typeof n&&null!==n){if(e.has(n))return;e.add(n)}return n}}})(),2);return t&&console.log(n),n}static substringAfter(e,t,n){const r=n?e.lastIndexOf(t):e.indexOf(t);return r<0?e:e.substring(r+t.length)}static setTimeoutPromise(e,t){return new Promise((n=>setTimeout((()=>{const t=e?.();n(t)}),t)))}}var o=n(9286),i=n(25142),a=n(73981),s=n(91262),l=n(85893);const c=e=>{return(0,l.jsx)(l.Fragment,{children:(0,l.jsxs)("a",{target:"_blank",href:(t=e.children,(t.startsWith("foundation/")?"https://gitlab.xops-online.com/foundation/foundation/-/tree/main/"+r.substringAfter(t,"foundation/"):"https://gitlab.xops-online.com/foundation/foundation-jhipster-gwt/-/tree/master/"+t)+(e.lineNumbers?.[0]?`#L${e.lineNumbers[0]}`:"")+(e.lineNumbers?.[1]?`-L${e.lineNumbers[1]}`:"")),children:[r.substringAfter(e.children,"/",!0),e.region&&(0,l.jsxs)("small",{children:["\xa0",(0,l.jsxs)("i",{children:["(region ",e.region,",\xa0",e.lineNumbers[0]===e.lineNumbers[1]?(0,l.jsxs)(l.Fragment,{children:["at line ",e.lineNumbers[0]]}):(0,l.jsxs)(l.Fragment,{children:["between lines [",e.lineNumbers[0],", ",e.lineNumbers[1],"])"]})]})]})]})});var t},g=e=>(0,l.jsx)(i.Z,{circular:!0,color:"blue",children:e.s}),u=e=>{let{src:{text:t,path:n},region:r,...i}=e;const a=new RegExp(`#region\\s*${r}[^\\r\\n]*\\r?\\n(.*?)#endregion`,"s").exec(t);if(!a)throw new Error(`In file = ${n}, cannot find region = ${r}, i.e. a portion like:\n\n#region ${r}\n...\n#endregion`);let s,g=1,u=-1;for(s=0;s<a.index+a[0].length;s++)"\n"===t[s]&&g++,-1===u&&s>=a.index&&(u=g);u++,g--;let d=a[1];d=/(.*)(\r?\n.*?$)/gs.exec(d)[1],d="\n"+d;const m=d.match(/\n(\s)*\S/);let p;if(m&&(p=m[1])){const e=new RegExp(`\\n(${p}*)\\S`,"g");let t,n=-1;for(;null!==(t=e.exec(d));)(n<0||n>t[1].length)&&(n=t[1].length);const r=p.repeat(n);d=d.replace(new RegExp("\\n"+r,"g"),"\n")}return d=d.substring(1),(0,l.jsx)(l.Fragment,{children:(0,l.jsx)(o.Z,{title:(0,l.jsxs)(l.Fragment,{children:["Snippet extracted from ",(0,l.jsx)(c,{region:r,lineNumbers:[u,g],children:n})]}),...i,children:d})})},d=e=>(0,l.jsx)(u,{language:"java",...e}),m=e=>(0,l.jsx)(u,{language:"ts",...e}),p=e=>(0,l.jsx)(s.Z,{children:()=>(0,l.jsx)(a.J6,{recordedTestsUrl:"https://gitlab.xops-online.com/foundation/foundation-jhipster-gwt/-/raw/master/leave-management/leave-management-react/public/recordedTests/recordedTest.json",includeCredentialsInJsonRequestRegex:/https:\/\/gitlab\.xops-online\.com\/*/,...e})}),h=e=>(0,l.jsx)(s.Z,{children:()=>(0,l.jsx)(a.J6,{recordedTestsUrl:"https://gitlab.xops-online.com/foundation/foundation-jhipster-gwt/-/raw/master/leave-management/leave-management-react/public/recordedTestsServer/recordedTest.json",includeCredentialsInJsonRequestRegex:/https:\/\/gitlab\.xops-online\.com\/*/,...e})})},13411:e=>{function t(e){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}t.keys=()=>[],t.resolve=t,t.id=13411,e.exports=t},12073:(e,t,n)=>{"use strict";n.d(t,{Z:()=>r});const r={text:'import { ClientErrorLoggerForTests } from "./ClientErrorLoggerForTests";\nimport { Scenario, tad } from "@famiprog-foundation/tests-are-demo";\nimport { TraceMapCache } from "@famiprog-foundation/tests-are-demo/dist-lib/lib/TraceMapCache";\nimport { Utils } from "../utils/Utils";\nimport React from "react";\nimport { createClock, BrowserClock } from "@sinonjs/fake-timers";\n\ndeclare global {\n    var forTestingClientErrorLogger_onError: ((ev: ErrorEvent) => void) | undefined;\n    var forTestingClientErrorLogger_onUnhandledRejection: ((ev: PromiseRejectionEvent) => void) | undefined;\n}\n\n// #region testable-timers-mock1a\nexport class ClientErrorLoggerTad extends React.Component {\n// #endregion testable-timers-mock1a\n\n    clientErrorLoger!: ClientErrorLoggerForTests;\n\n    // #region testable-timers-mock1b\n    clock!: BrowserClock;\n    // #endregion testable-timers-mock1b\n\n    // #region testable-timers-mock2a\n    async before() {\n        // #endregion testable-timers-mock2a\n        this.clientErrorLoger = new ClientErrorLoggerForTests().start();\n        // #region testable-timers-mock2b\n        this.clock = this.clientErrorLoger.timers = createClock() as BrowserClock;\n        // #endregion testable-timers-mock2b\n        window.forTestingClientErrorLogger_onError = (e: ErrorEvent) => {\n            e.stopImmediatePropagation(); e.preventDefault();\n            window.dispatchEvent(new ErrorEvent("error_forwarded", e));\n        }\n        window.forTestingClientErrorLogger_onUnhandledRejection = (e: PromiseRejectionEvent) => {\n            e.stopImmediatePropagation(); e.preventDefault();\n            window.dispatchEvent(new PromiseRejectionEvent("unhandledrejection_forwarded", e));\n        }\n    }\n\n    async after() {\n        this.clientErrorLoger.stop();\n        window.forTestingClientErrorLogger_onUnhandledRejection = undefined;\n        window.forTestingClientErrorLogger_onError = undefined;\n    }\n\n    async beforeEach() {\n        const url = Utils.adjustUrlToServerContext("clientErrorLoggerTadHelper/deleteLogContent");\n        await fetch(url!, { method: "POST" });\n        await tad.waitForCommunicationFinished();\n    }\n\n    /**\n     * In the file: `logs/client-error.log` (cf. `logback-main.xml`) such errors look like this:\n     * \n     * ```\n     * 2024-01-29 16:17:18,938 [      XNIO-1 task-54] ClientErrorLoggerController: user = admin; session = ERuRWsgJRxqc2YhbqHrLdRBKN_0LZgTdly9tEvMn; error = Error: Generated Error for test\n     *      at ClientErrorLoggerTestsAreDemo.generateError (http://localhost:3000/.../leave-management/leave-management-react/src/@crispico/foundation-react/clientErrorLogger/ClientErrorLoggerTestsAreDemo.ts:131:1) [return new Error("Generated Error for test");]\n     *      at ClientErrorLoggerTestsAreDemo.whenCatchErrorThenLogIt (http://localhost:3000/.../leave-management/leave-management-react/src/@crispico/foundation-react/clientErrorLogger/ClientErrorLoggerTestsAreDemo.ts:54:1) [const error = this.generateError();]\n     *      ...\n     * ```\n     * \n     * Such an use case may be useful in **production**. E.g.:\n     * \n     * * Maybe some users have got errors that happen, but they don\'t notice something wrong w/ the app => nobody complains.\n     * * Maybe the app enters in an unstable state, but a browser refresh fixes it => nobody complains.\n     */\n    @Scenario("WHEN an unhandled error is caught, THEN it is sent to the server and logged")\n    async whenCatchErrorThenLogIt() {\n        // For the other tests we throw an error and we rely on the global handler to catch it. But in this case, the stack trace is not good\n        // enough to also test its content. Hence we throw it here, to have something precise to compare w/ what was logged.\n        const error = this.generateError();\n        this.clientErrorLoger.tadCatchError(error);\n        tad.waitForCommunicationFinishedNextTimeoutTemp(9000);\n        await tad.waitForCommunicationFinished();\n        const logContent = await this.getLogContent();\n        const loggedError = await TraceMapCache.INSTANCE.decodeStackTrace(error);\n        await tad.assertWaitable.include(logContent, loggedError)\n    }\n\n    /**\n     * ... AND the sending is periodically retried. WHEN the server is back online, THEN the queue is sent.\n     */\n    @Scenario("WHEN an error is caught, AND the server is not accessible, THEN it is queued ... ")\n    // #region testable-timers-mock-use1\n    async whenCatchErrorAndSendToServerOnSecondTry() {\n    // #endregion\n        this.clientErrorLoger.setFailSendError(true);\n        // because the code from index.html, mocha\'s uncaught error handler won\'t be triggred by this error\n        setTimeout(() => { throw this.generateError() }, 1);\n        await tad.waitForCommunicationFinished();\n        tad.cc("The send to server was failed, the timeout was registered.");\n        await tad.assertWaitable.isNumber(this.clientErrorLoger.getTimeoutId());\n        // the connection to server was establish\n        // #region testable-timers-mock-use2\n        this.clientErrorLoger.setFailSendError(false);\n        await this.clock.runAllAsync();\n        // #endregion testable-timers-mock-use\n        await tad.waitForCommunicationFinished();\n        tad.cc("The send to server was successful.");\n        await tad.assertWaitable.isUndefined(this.clientErrorLoger.getTimeoutId());\n        const numberLoggedErorrs = await this.getNumberLoggedErors();\n        tad.cc("The error was logged.");\n        await tad.assertWaitable.equal(numberLoggedErorrs, 1);\n    }\n\n    @Scenario("WHEN *multiple* errors are caught, AND the server is not accessible ...")\n    _() { }\n\n    @Scenario("... THEN all of them are queued AND sent later")\n    async whenCatchMultipleErrorsAndOnSecondCatchSendBoth() {\n        this.clientErrorLoger.setFailSendError(true);\n        setTimeout(() => { throw this.generateError() }, 1);\n        await tad.waitForCommunicationFinished();\n        tad.cc("The send to server was failed, the error was queued.");\n        await tad.assertWaitable.equal(this.clientErrorLoger.getQueueLen(), 1);\n        this.clientErrorLoger.setFailSendError(false);\n        // catch second error\n        setTimeout(() => { throw this.generateError() }, 1);\n        await tad.waitForCommunicationFinished();\n        tad.cc("The send to server was successful.");\n        await tad.assertWaitable.equal(this.clientErrorLoger.getQueueLen(), 0);\n        const numberLoggedErorrs = await this.getNumberLoggedErors();\n        tad.cc("The both errors was logged.");\n        await tad.assertWaitable.equal(numberLoggedErorrs, 2);\n    }\n\n    /**\n     * I.e. we send the first errors and discard the last ones. The queue is a normal queue, not a circular one.\n     * \n     * Actually this is a common use case for dev. W/o the queue & limit, if the server is down, every server call would generate an error.\n     * Including when trying to send errors, so say hello to an endless loop and an unresponsive browser.\n     */\n    @Scenario("... AND the queue is full, THEN new errors are rejected")\n    async whenCatchErrorsAndQueueIsFull() {\n        // this number need to be graher that this.clientErrorLogger.queueCapacity\n        const numberOfGeneratedErrors = 20;\n        this.clientErrorLoger.setFailSendError(true);\n        for (let i = 0; i < numberOfGeneratedErrors; i++) {\n            setTimeout(() => { throw this.generateError() }, 1);\n        }\n        await tad.waitForCommunicationFinished();\n        tad.cc(`Catch ${numberOfGeneratedErrors} errors and problems with send to server, keep only ${this.clientErrorLoger.queueCapacity}`);\n        await tad.assertWaitable.equal(this.clientErrorLoger.getQueueLen(), this.clientErrorLoger.queueCapacity);\n        this.clientErrorLoger.setFailSendError(false);\n        await this.clock.runAllAsync();\n        tad.waitForCommunicationFinishedNextTimeoutTemp(1500);\n        await tad.waitForCommunicationFinished();\n        const numberLoggedErorrs = await this.getNumberLoggedErors();\n        tad.cc("The errors was logged.");\n        await tad.assertWaitable.equal(numberLoggedErorrs, this.clientErrorLoger.queueCapacity);\n    }\n\n    private generateError() {\n        return new Error("Generated Error for test");\n    }\n\n    private async getLogContent() {\n        // #region tad-helper-from-client\n        const url = Utils.adjustUrlToServerContext("clientErrorLoggerTadHelper/logContent");\n        return (await fetch(url!, { method: "GET" })).text();\n        // #endregion\n    }\n\n    private async getNumberLoggedErors() {\n        const logContent = await this.getLogContent();\n        return logContent.match(/ClientErrorLoggerController/g)?.length || 0;\n    }\n}\n',path:"foundation-react/src/foundation-react/clientErrorLogger/ClientErrorLoggerTad.ts"}},37548:(e,t,n)=>{"use strict";n.d(t,{Z:()=>r});const r={text:'package com.crispico.leave_management;\n\nimport java.net.UnknownHostException;\n\nimport javax.inject.Inject;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.DependsOn;\nimport org.springframework.context.annotation.Import;\nimport org.springframework.context.annotation.Profile;\nimport org.springframework.core.env.Environment;\n\nimport com.crispico.foundation.server.ServerUtils;\nimport com.crispico.foundation.server.clientErrorLogger.ClientErrorLoggerControllerTadHelper;\nimport com.crispico.foundation.server.distributedTracing.DependenciesFinder;\nimport com.crispico.foundation.server.jhipster.generated.JhipsterRuntimeApp;\nimport com.crispico.foundation.server.jhipster.lib.config.JHipsterConstants;\nimport com.crispico.foundation.server.organizationControllerTadHelper.OrganizationControllerTadHelper;\nimport com.crispico.foundation.server.service.settingsEntityService.SettingsCache;\nimport com.crispico.foundation.server.spring.FoundationServerApp;\nimport com.crispico.leave_management.demoMode.DemoModeServiceLeaveManagement;\nimport com.crispico.leave_management.performance_logging.PerformanceLoggingAspect;\nimport com.crispico.leave_management.service.TaskService;\nimport com.crispico.leave_management.service.employeeService.EmployeeService.Color;\nimport com.crispico.leave_management.service.employeeService.EmployeeService.EmployeeServiceDemoReportSettings;\nimport com.crispico.leave_management.service.employeeService.EmployeeService.EmployeeServiceHeaderSettings;\n\nimport brave.Tracer;\nimport graphql.schema.GraphQLSchema;\nimport graphql.schema.idl.SchemaPrinter;\n/**\n * @author Cristian Spiescu\n */\n@FoundationServerApp\n@Import(LeaveManagementScheduledTaskConfig.class)\npublic class LeaveManagementApp extends JhipsterRuntimeApp {\n\t\n\tprotected static class AfterStartup {\n\t\t\t\t\n\t\t@Inject\n\t\tprotected Environment environment;\n\n\t\t@Inject\n\t\tprotected void postCreate(GraphQLSchema schema) {\t\t\t\n\t        SchemaPrinter schemaPrinter = new SchemaPrinter(SchemaPrinter.Options.defaultOptions());\n\t        System.out.println(schemaPrinter.print(schema));\n\t        System.out.println();\n\t\t}\n\t}\n\t\n\t@Autowired\n\tTracer tracer;\n\n\tpublic LeaveManagementApp(Environment env) {\n\t\tsuper(env);\n\t}\n\n\tpublic static void main(String[] args) throws UnknownHostException {\n\t\tJhipsterRuntimeApp.main(LeaveManagementApp.class, args);\n\t}\n\n\t@Bean\n\tprotected AfterStartup afterStartup() {\n\t\treturn new AfterStartup();\n\t}\n\n\t@Bean\n\t@DependsOn("performanceLoggingParameters")\n\t@ConditionalOnProperty(name = "foundation.performance-log.disable-default-aspect", havingValue = "true")\n\tpublic PerformanceLoggingAspect performanceLoggingAspect() {\n\t\tPerformanceLoggingAspect result = new PerformanceLoggingAspect();\n\t\treturn result;\n\t}\n\t\n\t@Bean\n\tpublic SettingsCache<TaskService.CreateDailyTasksSettings> createDailyTasksSettings() {\n\t\tTaskService.CreateDailyTasksSettings defaultValue = new TaskService.CreateDailyTasksSettings();\n\t\tdefaultValue.createInWeekend = false;\n\t\treturn new SettingsCache<>(defaultValue);\n\t}\n\n\t@Bean\n\tpublic SettingsCache<TaskService.TaskSalarySettings> taskSalarySettings() {\n\t\treturn new SettingsCache<>(new TaskService.TaskSalarySettings());\n\t}\n\t\n\t@Bean\n\tpublic SettingsCache<EmployeeServiceDemoReportSettings> employeeServiceDemoReportSettings() {\n\t\treturn new SettingsCache<>(new EmployeeServiceDemoReportSettings());\n\t}\n\t\n\t// #region settings1-bean\n\t@Bean\n\tpublic SettingsCache<EmployeeServiceHeaderSettings> employeeServiceHeaderSettings() {\n\t\treturn new SettingsCache<>(ServerUtils.jsonLike(new EmployeeServiceHeaderSettings(), s -> {\n\t\t\ts.showBasicSettingsButton = false;\n\t\t\ts.settingsButtonColor = Color.blue;\n\t\t\ts.postItMessage = "";\n\t\t}));\n\t}\n\t// #endregion\n\t\n\t@Bean\n\tpublic DependenciesFinder dependenciesFinder() {\n\t\treturn new DependenciesFinder();\n\t}\n\t\n\t// #region tad-helper-bean\n\t@Bean\n\t@Profile(JHipsterConstants.SPRING_PROFILE_TEST)\n\tpublic ClientErrorLoggerControllerTadHelper clientErrorLoggerControllerTadHelper() {\n\t\treturn new ClientErrorLoggerControllerTadHelper();\n\t}\n\t\n\t@Bean\n\t@Profile(JHipsterConstants.SPRING_PROFILE_TEST)\n\tpublic OrganizationControllerTadHelper organizationControllerTadHelper() {\n\t\treturn new OrganizationControllerTadHelper();\n\t}\n\t// #endregion\n\n// CS: am dezactivat zipkin pentru ca aveam multa poluare in consola; @see pom.xml\t\n\t\n//\t@Bean\n//\tpublic Sampler defaultSampler() {\n//\t\treturn Sampler.ALWAYS_SAMPLE;\n//\t}\n//\n//\t@Bean\n//\tpublic JdbcEventListener jdbcEventListner() {\n//\t\treturn new JdbcEventListener() {\n//\n//\t\t\tpublic Map<String, String> result = new TreeMap<>();\n//\t\t\tpublic List<Map<String, String>> results = new ArrayList<Map<String, String>>();\n//\n//\t\t\t@Override\n//\t\t\tpublic void onAfterResultSetGet(ResultSetInformation resultSetInformation, String columnLabel, Object value, SQLException e) {\n//\t\t\t\ttry {\n//\t\t\t\t\tString tableName = resultSetInformation.getResultSet().getMetaData().getTableName(1);\n//\t\t\t\t\tif (!result.containsKey("tableName")) {\n//\t\t\t\t\t\tresult.put("tableName", tableName);\n//\t\t\t\t\t}\n//\t\t\t\t} catch (SQLException e1) {\n//\t\t\t\t\te1.printStackTrace();\n//\t\t\t\t}\n//\t\t\t\tresult.put(convertColumnLabelToColumnName(columnLabel, resultSetInformation), value != null ? value.toString() : null);\n//\t\t\t}\n//\n//\t\t\t@Override\n//\t\t\tpublic void onAfterResultSetNext(ResultSetInformation resultSetInformation, long timeElapsedNanos, boolean hasNext, SQLException e) {\n//\t\t\t\tif (!result.isEmpty()) {\n//\t\t\t\t\tMap<String, String> resultCopy = new TreeMap<String, String>();\n//\t\t\t\t\tresultCopy.putAll(result);\n//\t\t\t\t\tresults.add(resultCopy);\n//\t\t\t\t\tresult.clear();\n//\t\t\t\t}\n//\t\t\t}\n//\n//\t\t\t@Override\n//\t\t\tpublic void onAfterCommit(ConnectionInformation connectionInformation, long timeElapsedNanos, SQLException e) {\n//\t\t\t\tSpan newSpan = tracer.currentSpan();\n//\t\t\t\ttry (Tracer.SpanInScope ws = tracer.withSpanInScope(newSpan.start())) {\n//\t\t\t\t\tnewSpan.tag("Query results", processResults(results));\n//\t\t\t\t} finally {\n//\t\t\t\t\tnewSpan.finish();\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println("Query results: " + processResults(results));\n//\t\t\t\tresults.clear();\n//\t\t\t}\n//\n//\t\t\tpublic String processResults(List<Map<String, String>> results) {\n//\t\t\t\tString tableName = null, resultAsString = "";\n//\t\t\t\tif (results.size() == 0) {\n//\t\t\t\t\treturn "[]";\n//\t\t\t\t}\n//\n//\t\t\t\tCollections.sort(results, new Comparator<Map<String, String>>() {\n//\t\t\t\t\t@Override\n//\t\t\t\t\tpublic int compare(Map<String, String> result1, Map<String, String> result2) {\n//\t\t\t\t\t\tString tableName1 = result1.get("tableName");\n//\t\t\t\t\t\tif (tableName1 == null) {\n//\t\t\t\t\t\t\t// CS: I don\'t know this code; but sometimes it enters here and would give a NPE\n//\t\t\t\t\t\t\t// I think the issue is deeper; because when this happens, the error persist; so\n//\t\t\t\t\t\t\t// the system is in a dubious state. To be investigated.\n//\t\t\t\t\t\t\treturn -1;\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\treturn tableName1.compareTo(result2.get("tableName"));\n//\t\t\t\t\t}\n//\t\t\t\t});\n//\n//\t\t\t\tfor (int i = 0; i < results.size(); i++) {\n//\t\t\t\t\tMap<String, String> result = results.get(i);\n//\n//\t\t\t\t\tString currentTableName = result.get("tableName");\n//\t\t\t\t\tif (currentTableName != "") {\n//\t\t\t\t\t\t// currentTableName can be empty when the query looks like "SELECT COUNT..."\n//\t\t\t\t\t\t// in this case, the table name can not be retrieved from ResultSetMetaData, but this query and its result can be seen on zipkin\n//\t\t\t\t\t\tif (currentTableName != tableName) {\n//\t\t\t\t\t\t\ttableName = currentTableName;\n//\t\t\t\t\t\t\tresultAsString += (i != 0 ? "\\n" : "") + "// " + currentTableName + "\\n " + "[";\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\tresultAsString += result.toString() + (i == results.size() - 1 || (i + 1 < results.size() && results.get(i + 1).get("tableName") != currentTableName) ? "]" : ", \\n");\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t\treturn resultAsString;\n//\t\t\t}\n//\n//\t\t\tpublic String convertColumnLabelToColumnName(String columnLabel, ResultSetInformation resultSetInformation) {\n//\t\t\t\ttry {\n//\t\t\t\t\tResultSetMetaData metaData = resultSetInformation.getResultSet().getMetaData();\n//\t\t\t\t\tfor (int i = 1; i <= metaData.getColumnCount(); i++) {\n//\t\t\t\t\t\tif (metaData.getColumnLabel(i).toUpperCase().equals(columnLabel.toUpperCase())) {\n//\t\t\t\t\t\t\treturn metaData.getColumnName(i).toLowerCase();\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t} catch (SQLException e) {\n//\t\t\t\t\te.printStackTrace();\n//\t\t\t\t}\n//\t\t\t\treturn columnLabel;\n//\t\t\t}\n//\t\t};\n//\t}\n\t\n// TODO CS/UCS: cand va merge treaba, sa incercam ceva de genul:\n// deci ea ar crea bean-uri dinamic; \n//\t@Bean\n//\tpublic SettingsService settingsService() {\n//\t\treturn new SettingsService(CreateDailyTasksSettings.class, ...);\n//\t}\n\t\n\t// #region demo-mode-bean\n\t@Bean\n\t@Profile(JHipsterConstants.SPRING_PROFILE_TEST)\n\tpublic DemoModeServiceLeaveManagement demoModeService() {\n\t\treturn new DemoModeServiceLeaveManagement();\n\t}\n\t// #endregion\n}\n',path:"leave-management/leave-management-server/src/main/java/com/crispico/leave_management/LeaveManagementApp.java"}},24654:()=>{},62183:()=>{},13024:()=>{},62715:()=>{},13611:()=>{},28353:()=>{},1210:()=>{},43454:()=>{}}]);