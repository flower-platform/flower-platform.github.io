(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[3791],{95984:(e,r,t)=>{"use strict";t.r(r),t.d(r,{assets:()=>g,contentTitle:()=>c,default:()=>m,frontMatter:()=>l,metadata:()=>d,toc:()=>u});var n=t(85893),o=t(11151),s=t(93598);const i={text:'package com.crispico.leave_management.tadHelpers;\n\nimport java.io.File;\nimport java.io.IOException;\n\nimport org.apache.commons.io.FileUtils;\nimport org.springframework.context.annotation.Profile;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport com.crispico.foundation.server.jhipster.lib.config.JHipsterConstants;\nimport com.crispico.foundation.server.log.LogLocationPropertyDefiner;\n\n/**\n * @author Cristian Spiescu\n */\n// #region tad-helper-class\n@Controller\n@RequestMapping("/clientErrorLoggerTadHelper")\n@Profile(JHipsterConstants.SPRING_PROFILE_TEST)\npublic class ClientErrorLoggerTadHelper {\n\n\t@RequestMapping(value = "/deleteLogContent", method = RequestMethod.POST)\n\t@ResponseBody()\n\tpublic void deleteLogFileContent() throws IOException {\n\t\tFileUtils.write(this.getLogFile(), "", "utf-8", false);\n\t}\n// #endregion\n\n\t@RequestMapping(value = "/logContent", method = RequestMethod.GET)\n\t@ResponseBody()\n\tpublic String getLogFileContent() throws IOException {\n\t\treturn FileUtils.readFileToString(this.getLogFile(), "utf-8");\n\t}\n\n\tprivate File getLogFile() {\n\t\tString logPath = LogLocationPropertyDefiner.getLogPath("logs");\n\t\treturn new File(logPath + (logPath.length() > 0 ? "/" : "") + "logs/client-error.log");\n\t}\n}\n',path:"leave-management/leave-management-server/src/test/java/com/crispico/leave_management/tadHelpers/ClientErrorLoggerTadHelper.java"};var a=t(12073);const l={},c="Pattern: using ...TadHelper.java from TAD client tests",d={id:"tests-are-demo/pattern-tad-helper",title:"Pattern: using ...TadHelper.java from TAD client tests",description:"Sometimes, during a TAD test that runs on the client, we may need the help of a bit of code that runs on the server. In order to perform/simulate some actions, and/or to do some verifications.",source:"@site/docs/tests-are-demo/pattern-tad-helper.md",sourceDirName:"tests-are-demo",slug:"/tests-are-demo/pattern-tad-helper",permalink:"/docusaurus/docs/tests-are-demo/pattern-tad-helper",draft:!1,unlisted:!1,editUrl:"https://gitlab.xops-online.com/foundation/foundation-jhipster-gwt/-/blob/master/docusaurus/docs/tests-are-demo/pattern-tad-helper.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Todos and drafts",permalink:"/docusaurus/docs/tests-are-demo/old2/Todos and drafts"},next:{title:"[old] React Gantt",permalink:"/docusaurus/docs/category/old-react-gantt"}},g={},u=[{value:"Instructions for devs",id:"instructions-for-devs",level:2}];function h(e){const r={code:"code",h1:"h1",h2:"h2",li:"li",p:"p",ul:"ul",...(0,o.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(r.h1,{id:"pattern-using-tadhelperjava-from-tad-client-tests",children:"Pattern: using ...TadHelper.java from TAD client tests"}),"\n",(0,n.jsx)(r.p,{children:"Sometimes, during a TAD test that runs on the client, we may need the help of a bit of code that runs on the server. In order to perform/simulate some actions, and/or to do some verifications."}),"\n",(0,n.jsx)(r.h2,{id:"instructions-for-devs",children:"Instructions for devs"}),"\n",(0,n.jsxs)(r.p,{children:["Instructions extracted from ",(0,n.jsx)(r.code,{children:"ClientErrorLogger"})," & co. In this case, the helper does things such as:"]}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsx)(r.li,{children:"deleting some log files on the server before and/or after the test;"}),"\n",(0,n.jsx)(r.li,{children:"return log contents from the disk in order to perform verifications on the client, etc."}),"\n"]}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(s.h8,{s:"1"})," We create a controller. Notice:"]}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:["in source dir ",(0,n.jsx)(r.code,{children:"src/test/java"})]}),"\n",(0,n.jsxs)(r.li,{children:["package/file name, e.g. for ",(0,n.jsx)(r.code,{children:"MyTad.tsx"})," -> ",(0,n.jsx)(r.code,{children:"com.myapp.tadHelpers/MyTadHelper.java"})]}),"\n"]}),"\n",(0,n.jsx)(s.Tm,{src:i,region:"tad-helper-class"}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(s.h8,{s:"2"})," Call it from the TAD client test."]}),"\n",(0,n.jsx)(s.Tm,{src:a.Z,region:"tad-helper-from-client"})]})}function m(e={}){const{wrapper:r}={...(0,o.a)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},93598:(e,r,t)=>{"use strict";t.d(r,{sS:()=>g,Tm:()=>u,M_:()=>h,Fb:()=>m,JR:()=>p,lj:()=>c,h8:()=>d});t(67294);class n{static now(){return new Date}static consoleLogJson(e,r){void 0===r&&(r=!0);const t=JSON.stringify(e,(()=>{const e=new WeakSet;return(r,t)=>{if(!r.startsWith("__react")){if("object"==typeof t&&null!==t){if(e.has(t))return;e.add(t)}return t}}})(),2);return r&&console.log(t),t}static substringAfter(e,r,t){const n=t?e.lastIndexOf(r):e.indexOf(r);return n<0?e:e.substring(n+r.length)}static setTimeoutPromise(e,r){return new Promise((t=>setTimeout((()=>{const r=e?.();t(r)}),r)))}}var o=t(9286),s=t(25142),i=t(73981),a=t(91262),l=t(85893);const c=e=>{return(0,l.jsx)(l.Fragment,{children:(0,l.jsxs)("a",{target:"_blank",href:(r=e.children,(r.startsWith("foundation/")?"https://gitlab.xops-online.com/foundation/foundation/-/tree/main/"+n.substringAfter(r,"foundation/"):"https://gitlab.xops-online.com/foundation/foundation-jhipster-gwt/-/tree/master/"+r)+(e.lineNumbers?.[0]?`#L${e.lineNumbers[0]}`:"")+(e.lineNumbers?.[1]?`-L${e.lineNumbers[1]}`:"")),children:[n.substringAfter(e.children,"/",!0),e.region&&(0,l.jsxs)("small",{children:["\xa0",(0,l.jsxs)("i",{children:["(region ",e.region,",\xa0",e.lineNumbers[0]===e.lineNumbers[1]?(0,l.jsxs)(l.Fragment,{children:["at line ",e.lineNumbers[0]]}):(0,l.jsxs)(l.Fragment,{children:["between lines [",e.lineNumbers[0],", ",e.lineNumbers[1],"])"]})]})]})]})});var r},d=e=>(0,l.jsx)(s.Z,{circular:!0,color:"blue",children:e.s}),g=e=>{let{src:{text:r,path:t},region:n,...s}=e;const i=new RegExp(`#region\\s*${n}[^\\r\\n]*\\r?\\n(.*?)#endregion`,"s").exec(r);if(!i)throw new Error(`In file = ${t}, cannot find region = ${n}, i.e. a portion like:\n\n#region ${n}\n...\n#endregion`);let a,d=1,g=-1;for(a=0;a<i.index+i[0].length;a++)"\n"===r[a]&&d++,-1===g&&a>=i.index&&(g=d);g++,d--;let u=i[1];u=/(.*)(\r?\n.*?$)/gs.exec(u)[1],u="\n"+u;const h=u.match(/\n(\s)*\S/);let m;if(h&&(m=h[1])){const e=new RegExp(`\\n(${m}*)\\S`,"g");let r,t=-1;for(;null!==(r=e.exec(u));)(t<0||t>r[1].length)&&(t=r[1].length);const n=m.repeat(t);u=u.replace(new RegExp("\\n"+n,"g"),"\n")}return u=u.substring(1),(0,l.jsx)(l.Fragment,{children:(0,l.jsx)(o.Z,{title:(0,l.jsxs)(l.Fragment,{children:["Snippet extracted from ",(0,l.jsx)(c,{region:n,lineNumbers:[g,d],children:t})]}),...s,children:u})})},u=e=>(0,l.jsx)(g,{language:"java",...e}),h=e=>(0,l.jsx)(g,{language:"ts",...e}),m=e=>(0,l.jsx)(a.Z,{children:()=>(0,l.jsx)(i.J6,{recordedTestsUrl:"https://gitlab.xops-online.com/foundation/foundation-jhipster-gwt/-/raw/master/leave-management/leave-management-react/public/recordedTests/recordedTest.json",includeCredentialsInJsonRequestRegex:/https:\/\/gitlab\.xops-online\.com\/*/,...e})}),p=e=>(0,l.jsx)(a.Z,{children:()=>(0,l.jsx)(i.J6,{recordedTestsUrl:"https://gitlab.xops-online.com/foundation/foundation-jhipster-gwt/-/raw/master/leave-management/leave-management-react/public/recordedTestsServer/recordedTest.json",includeCredentialsInJsonRequestRegex:/https:\/\/gitlab\.xops-online\.com\/*/,...e})})},13411:e=>{function r(e){var r=new Error("Cannot find module '"+e+"'");throw r.code="MODULE_NOT_FOUND",r}r.keys=()=>[],r.resolve=r,r.id=13411,e.exports=r},12073:(e,r,t)=>{"use strict";t.d(r,{Z:()=>n});const n={text:'import { ClientErrorLoggerForTests } from "./ClientErrorLoggerForTests";\nimport { Scenario, tad } from "@famiprog-foundation/tests-are-demo";\nimport { TraceMapCache } from "@famiprog-foundation/tests-are-demo/dist-lib/lib/TraceMapCache";\nimport { Utils } from "../utils/Utils";\nimport React from "react";\nimport { createClock, BrowserClock } from "@sinonjs/fake-timers";\n\ndeclare global {\n    var forTestingClientErrorLogger_onError: ((ev: ErrorEvent) => void) | undefined;\n    var forTestingClientErrorLogger_onUnhandledRejection: ((ev: PromiseRejectionEvent) => void) | undefined;\n}\n\n// #region testable-timers-mock1a\nexport class ClientErrorLoggerTad extends React.Component {\n// #endregion testable-timers-mock1a\n\n    clientErrorLoger!: ClientErrorLoggerForTests;\n\n    // #region testable-timers-mock1b\n    clock!: BrowserClock;\n    // #endregion testable-timers-mock1b\n\n    // #region testable-timers-mock2a\n    async before() {\n        // #endregion testable-timers-mock2a\n        this.clientErrorLoger = new ClientErrorLoggerForTests().start();\n        // #region testable-timers-mock2b\n        this.clock = this.clientErrorLoger.timers = createClock() as BrowserClock;\n        // #endregion testable-timers-mock2b\n        window.forTestingClientErrorLogger_onError = (e: ErrorEvent) => {\n            e.stopImmediatePropagation(); e.preventDefault();\n            window.dispatchEvent(new ErrorEvent("error_forwarded", e));\n        }\n        window.forTestingClientErrorLogger_onUnhandledRejection = (e: PromiseRejectionEvent) => {\n            e.stopImmediatePropagation(); e.preventDefault();\n            window.dispatchEvent(new PromiseRejectionEvent("unhandledrejection_forwarded", e));\n        }\n    }\n\n    async after() {\n        this.clientErrorLoger.stop();\n        window.forTestingClientErrorLogger_onUnhandledRejection = undefined;\n        window.forTestingClientErrorLogger_onError = undefined;\n    }\n\n    async beforeEach() {\n        const url = Utils.adjustUrlToServerContext("clientErrorLoggerTadHelper/deleteLogContent");\n        await fetch(url!, { method: "POST" });\n        await tad.waitForCommunicationFinished();\n    }\n\n    /**\n     * In the file: `logs/client-error.log` (cf. `logback-main.xml`) such errors look like this:\n     * \n     * ```\n     * 2024-01-29 16:17:18,938 [      XNIO-1 task-54] ClientErrorLoggerController: user = admin; session = ERuRWsgJRxqc2YhbqHrLdRBKN_0LZgTdly9tEvMn; error = Error: Generated Error for test\n     *      at ClientErrorLoggerTestsAreDemo.generateError (http://localhost:3000/.../leave-management/leave-management-react/src/@crispico/foundation-react/clientErrorLogger/ClientErrorLoggerTestsAreDemo.ts:131:1) [return new Error("Generated Error for test");]\n     *      at ClientErrorLoggerTestsAreDemo.whenCatchErrorThenLogIt (http://localhost:3000/.../leave-management/leave-management-react/src/@crispico/foundation-react/clientErrorLogger/ClientErrorLoggerTestsAreDemo.ts:54:1) [const error = this.generateError();]\n     *      ...\n     * ```\n     * \n     * Such an use case may be useful in **production**. E.g.:\n     * \n     * * Maybe some users have got errors that happen, but they don\'t notice something wrong w/ the app => nobody complains.\n     * * Maybe the app enters in an unstable state, but a browser refresh fixes it => nobody complains.\n     */\n    @Scenario("WHEN an unhandled error is caught, THEN it is sent to the server and logged")\n    async whenCatchErrorThenLogIt() {\n        // For the other tests we throw an error and we rely on the global handler to catch it. But in this case, the stack trace is not good\n        // enough to also test its content. Hence we throw it here, to have something precise to compare w/ what was logged.\n        const error = this.generateError();\n        this.clientErrorLoger.tadCatchError(error);\n        tad.waitForCommunicationFinishedNextTimeoutTemp(9000);\n        await tad.waitForCommunicationFinished();\n        const logContent = await this.getLogContent();\n        const loggedError = await TraceMapCache.INSTANCE.decodeStackTrace(error);\n        await tad.assertWaitable.include(logContent, loggedError)\n    }\n\n    /**\n     * ... AND the sending is periodically retried. WHEN the server is back online, THEN the queue is sent.\n     */\n    @Scenario("WHEN an error is caught, AND the server is not accessible, THEN it is queued ... ")\n    // #region testable-timers-mock-use1\n    async whenCatchErrorAndSendToServerOnSecondTry() {\n    // #endregion\n        this.clientErrorLoger.setFailSendError(true);\n        // because the code from index.html, mocha\'s uncaught error handler won\'t be triggred by this error\n        setTimeout(() => { throw this.generateError() }, 1);\n        await tad.waitForCommunicationFinished();\n        tad.cc("The send to server was failed, the timeout was registered.");\n        await tad.assertWaitable.isNumber(this.clientErrorLoger.getTimeoutId());\n        // the connection to server was establish\n        // #region testable-timers-mock-use2\n        this.clientErrorLoger.setFailSendError(false);\n        await this.clock.runAllAsync();\n        // #endregion testable-timers-mock-use\n        await tad.waitForCommunicationFinished();\n        tad.cc("The send to server was successful.");\n        await tad.assertWaitable.isUndefined(this.clientErrorLoger.getTimeoutId());\n        const numberLoggedErorrs = await this.getNumberLoggedErors();\n        tad.cc("The error was logged.");\n        await tad.assertWaitable.equal(numberLoggedErorrs, 1);\n    }\n\n    @Scenario("WHEN *multiple* errors are caught, AND the server is not accessible ...")\n    _() { }\n\n    @Scenario("... THEN all of them are queued AND sent later")\n    async whenCatchMultipleErrorsAndOnSecondCatchSendBoth() {\n        this.clientErrorLoger.setFailSendError(true);\n        setTimeout(() => { throw this.generateError() }, 1);\n        await tad.waitForCommunicationFinished();\n        tad.cc("The send to server was failed, the error was queued.");\n        await tad.assertWaitable.equal(this.clientErrorLoger.getQueueLen(), 1);\n        this.clientErrorLoger.setFailSendError(false);\n        // catch second error\n        setTimeout(() => { throw this.generateError() }, 1);\n        await tad.waitForCommunicationFinished();\n        tad.cc("The send to server was successful.");\n        await tad.assertWaitable.equal(this.clientErrorLoger.getQueueLen(), 0);\n        const numberLoggedErorrs = await this.getNumberLoggedErors();\n        tad.cc("The both errors was logged.");\n        await tad.assertWaitable.equal(numberLoggedErorrs, 2);\n    }\n\n    /**\n     * I.e. we send the first errors and discard the last ones. The queue is a normal queue, not a circular one.\n     * \n     * Actually this is a common use case for dev. W/o the queue & limit, if the server is down, every server call would generate an error.\n     * Including when trying to send errors, so say hello to an endless loop and an unresponsive browser.\n     */\n    @Scenario("... AND the queue is full, THEN new errors are rejected")\n    async whenCatchErrorsAndQueueIsFull() {\n        // this number need to be graher that this.clientErrorLogger.queueCapacity\n        const numberOfGeneratedErrors = 20;\n        this.clientErrorLoger.setFailSendError(true);\n        for (let i = 0; i < numberOfGeneratedErrors; i++) {\n            setTimeout(() => { throw this.generateError() }, 1);\n        }\n        await tad.waitForCommunicationFinished();\n        tad.cc(`Catch ${numberOfGeneratedErrors} errors and problems with send to server, keep only ${this.clientErrorLoger.queueCapacity}`);\n        await tad.assertWaitable.equal(this.clientErrorLoger.getQueueLen(), this.clientErrorLoger.queueCapacity);\n        this.clientErrorLoger.setFailSendError(false);\n        await this.clock.runAllAsync();\n        tad.waitForCommunicationFinishedNextTimeoutTemp(1500);\n        await tad.waitForCommunicationFinished();\n        const numberLoggedErorrs = await this.getNumberLoggedErors();\n        tad.cc("The errors was logged.");\n        await tad.assertWaitable.equal(numberLoggedErorrs, this.clientErrorLoger.queueCapacity);\n    }\n\n    private generateError() {\n        return new Error("Generated Error for test");\n    }\n\n    private async getLogContent() {\n        // #region tad-helper-from-client\n        const url = Utils.adjustUrlToServerContext("clientErrorLoggerTadHelper/logContent");\n        return (await fetch(url!, { method: "GET" })).text();\n        // #endregion\n    }\n\n    private async getNumberLoggedErors() {\n        const logContent = await this.getLogContent();\n        return logContent.match(/ClientErrorLoggerController/g)?.length || 0;\n    }\n}\n',path:"foundation-react/src/foundation-react/clientErrorLogger/ClientErrorLoggerTad.ts"}},24654:()=>{},62183:()=>{},13024:()=>{},62715:()=>{},13611:()=>{},28353:()=>{},1210:()=>{},43454:()=>{}}]);