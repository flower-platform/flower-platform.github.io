"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[9348],{74278:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>r,toc:()=>l});var n=i(85893),o=i(11151);const a={},s='[WIP / waiting a concrete case] "Locking" test data',r={id:"featurebook/recipes-wip/locking-test-data",title:'[WIP / waiting a concrete case] "Locking" test data',description:"E.g. in base DB I have 10 employees. 8 active and 2 inactive (i1, i2). I have some code/reports that work w/ inactive people. We'll test that the results contain i1 and i2.",source:"@site/docs/featurebook/recipes-wip/locking-test-data.md",sourceDirName:"featurebook/recipes-wip",slug:"/featurebook/recipes-wip/locking-test-data",permalink:"/docusaurus/docs/featurebook/recipes-wip/locking-test-data",draft:!1,unlisted:!1,editUrl:"https://gitlab.xops-online.com/foundation/foundation-jhipster-gwt/-/blob/master/docusaurus/docs/featurebook/recipes-wip/locking-test-data.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:'[To move] I encourage people to use "Inspect testid"',permalink:"/docusaurus/docs/featurebook/recipes/use-inspect-test-id"},next:{title:"[WIP] Expression needed for action or test is ugly? Consider refactoring for improved testability",permalink:"/docusaurus/docs/featurebook/recipes-wip/refactor-for-testability"}},c={},l=[];function d(e){const t={h1:"h1",li:"li",p:"p",ul:"ul",...(0,o.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"wip--waiting-a-concrete-case-locking-test-data",children:'[WIP / waiting a concrete case] "Locking" test data'}),"\n",(0,n.jsx)(t.p,{children:"E.g. in base DB I have 10 employees. 8 active and 2 inactive (i1, i2). I have some code/reports that work w/ inactive people. We'll test that the results contain i1 and i2."}),"\n",(0,n.jsx)(t.p,{children:"In N months, somebody needs to enrich the data set, by adding more employees. Including inactive ones (i3, i4). This will break the initial tests that were expecting only i1 and i2. Because now there are i1, i2, i3, i4."}),"\n",(0,n.jsx)(t.p,{children:'So a policy will be needed regarding "locking" test data.'}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"let's properly spec this, when it will happen"}),"\n",(0,n.jsx)(t.li,{children:'one idea would be to use a convention in the "populate db" area. To say "data locked by test ...". This way people will see that they shouldn\'t modify the data.'}),"\n",(0,n.jsx)(t.li,{children:'ok, so what to do? We should leverage the feature to populate in "layers". I.e. define a new "layer", and the new particular test should specify that it uses it.'}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},11151:(e,t,i)=>{i.d(t,{Z:()=>r,a:()=>s});var n=i(67294);const o={},a=n.createContext(o);function s(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);