(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[410],{96741:(e,n,r)=>{"use strict";r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>m,frontMatter:()=>s,metadata:()=>p,toc:()=>c});var t=r(85893),o=r(11151),i=r(93598);const a={text:'import { FilterOperators, Messages } from "@crispico/foundation-gwt-js";\r\nimport { CrudSettings } from "@crispico/foundation-react/entity_crud/CrudSettings";\r\nimport "@crispico/foundation-react/entity_crud/fieldRenderersEditors/EntityFilter";\r\nimport { roleToUserEntityDescriptor } from "@crispico/foundation-react/pages/role/roleEntityDescriptor";\r\nimport { ColorRegistry, ColorRegistryRRC } from "@crispico/foundation-react/utils/ColorRegistry";\r\nimport { configureStore, EnhancedStore } from "@reduxjs/toolkit";\r\nimport { Drawer } from "antd";\r\nimport { QueryOptions } from "apollo-client";\r\nimport { ConnectedRouter, connectRouter, push, routerMiddleware } from "connected-react-router";\r\nimport { DocumentNode } from "graphql";\r\nimport gql from "graphql-tag";\r\nimport { createHashHistory, createLocation, History, Location, UnregisterCallback } from "history";\r\nimport Interweave from "interweave";\r\nimport lodash from \'lodash\';\r\nimport moment from "moment-timezone";\r\nimport React, { ReactElement, ReactNode, Suspense } from \'react\';\r\nimport ReactDOM from "react-dom";\r\nimport { Provider } from "react-redux";\r\nimport { Link, matchPath, Redirect, Route, Switch, useHistory } from \'react-router-dom\';\r\nimport { combineReducers, Unsubscribe } from "redux";\r\nimport thunk from "redux-thunk";\r\nimport { Button, Container, Dimmer, Dropdown, Header, Icon, Loader, Menu, Message, Modal, SemanticICONS, Label } from "semantic-ui-react";\r\nimport { logout } from "./apollo-gen-foundation/logout";\r\nimport { apolloClient, apolloClientHolder, initApolloClient } from "./apolloClient";\r\nimport { AppMetaTempGlobals } from "./AppMetaTempGlobals";\r\nimport { CompMeta, Optional } from "./CompMeta";\r\nimport { ColumnConfigDropdown, currentColumnConfigId, currentEditorColumnConfigId, sliceColumnConfigDropdown } from "./components/ColumnConfig/ColumnConfigDropdown";\r\nimport { columnConfigEntityDescriptor } from "./components/ColumnConfig/ColumnConfigEntityDescriptor";\r\nimport { ContainerWithHeader, ContainerWithHeaderContext } from "./components/containerWithHeader/ContainerWithHeader";\r\nimport { currentCustomQueryId } from "./components/CustomQuery/CustomQueryDropdown";\r\nimport { customQueryEntityDescriptor } from "./components/CustomQuery/CustomQueryEntityDescriptor";\r\nimport { Filter } from "./components/CustomQuery/Filter";\r\nimport { HorizontalMenu } from "./components/HorizontalMenu/HorizontalMenu";\r\nimport { ModalExt, Severity } from "./components/ModalExt/ModalExt";\r\nimport { Expanded, OnSelectParams, RenderItemParams, SliceTree, Tree } from "./components/TreeNew/Tree";\r\nimport { entityDescriptors, runAfterStartupRunnables, sessionGlobalCurrentOrganizationToFilterBy, sessionGlobalReload } from "./entity_crud/entityCrudConstants";\r\nimport { EntityDescriptor } from "./entity_crud/EntityDescriptor";\r\nimport { EntityDescriptorPopulatorFromEntityGen } from "./entity_crud/EntityDescriptorPopulatorFromEntityGen";\r\nimport { SliceEntityEditorPage } from "./entity_crud/EntityEditorPage";\r\nimport { FieldType } from "./entity_crud/FieldType";\r\nimport { FindByFilterParams } from "./entity_crud/FindByFilterParams";\r\nimport "./messages";\r\nimport { EntityDescriptorForServerUtils } from "./flower/entityDescriptorsForServer/EntityDescriptorForServerUtils";\r\n// import * as zeroTrainingAudit from \'./pages/Audit/stories\';\r\nimport { LOGOUT } from "./pages/loginPage/queries";\r\nimport { NotificationComponent, sliceNotificationComponent } from "./pages/notification/NotificationComponent";\r\nimport { organizationEntityDescriptor, OrganizationManyToOneEditorStandalone } from "./pages/SettingsEntity/settingsEntityDescriptor";\r\nimport { AppRouteProps, ConnectedComponentInSimpleComponent, ConnectedPageHelper, ConnectedPageInfo, createSliceFoundation, getBaseImpures, getBaseReducers, PrivateRouteProps, PropsFrom, RootReducerForPages, StateFrom } from "./reduxHelpers";\r\nimport { TestUtils } from "./utils/TestUtils";\r\nimport { ShowGlobalAlertParams, DATABASE_MENU_ENTRY, Utils, ENT_READ } from "./utils/Utils";\r\nimport { ZeroTrainingArticlesRegistry, ZeroTrainingContext } from "./zeroTraining/dataStructures";\r\nimport * as zeroTrainingZt from "./zeroTraining/stories/demoZeroTraining.stories";\r\nimport { ZeroTrainingArticlePageRoute } from "./zeroTraining/ZeroTrainingArticlePage";\r\nimport { ZeroTrainingIndexPageRoute } from "./zeroTraining/ZeroTrainingIndexPage";\r\nimport { ReduxReusableComponents, RRC_SINGLETON } from "./reduxReusableComponents/ReduxReusableComponents";\r\nimport { infoCurrentUserEditorPage } from "./pages/user/CurrentUserEditorPage";\r\nimport _ from "lodash";\r\nimport { Clock } from "./components/Clock/Clock";\r\nimport { TreeMenu, TreeMenuRRC } from "./components/treeMenu/TreeMenu";\r\nimport { TreeMenuSearch } from "./components/treeMenu/TreeMenuSearch";\r\nimport { WrapperWithRenderFunction } from "./utils/WrapperWithRenderFunction";\r\nimport "@crispico/foundation-react/pages/Audit/auditEntityDescriptor"; // out of the blue, only in prot, this was imported AFTER finalizeDescriptors() was ran => the registered afterStartupRunnable(), wouldn\'t be ran any more. Hence I force its inclusion here\r\nimport { ClientErrorLogger } from "./clientErrorLogger/ClientErrorLogger";\r\nimport { ToolkitStore } from "@reduxjs/toolkit/dist/configureStore";\r\n\r\nconst ACTION_RESET_STORE = "reset-store";\r\n// session storage item; used to switch between normal and phone mode (temporary menu entry added on XOPS proj)\r\nexport const PHONE_MODE_KEY = \'app.phoneMode\';\r\n\r\nexport interface BigState<I extends FoundationInitializationsForClient = FoundationInitializationsForClient> {\r\n    AppContainer: {\r\n        initializationsForClient: I;\r\n        menuEntries: { [key: string]: Optional<MenuEntry[]> };\r\n    }\r\n}\r\n\r\nexport interface FoundationInitializationsForClient {\r\n    version: string[2];\r\n    currentUser: Optional<User>;\r\n    currentRole: Optional<Role>;\r\n    currentPermissions: Optional<any>;\r\n    currentOrganization: Optional<Organization>;\r\n    allOrganizationsAccess: Optional<boolean>;\r\n\r\n    visualStyleSettings: VisualStyleSettings;\r\n    homePageSettings: HomePageSettings;\r\n    colorSettings: ColorSettings;\r\n    internationalizationSettings: InternationalizationSettings;\r\n    notificationSettings?: NotificationSettings;\r\n    auditSettings?: AuditSettings;\r\n    userSettings?: UserSettings;\r\n    crudSettings?: CrudSettings;\r\n    organizationSettings?: OrganizationSettings;\r\n    oktaAuthenticationAvailable?: boolean;\r\n    rememberMeEnabled?: boolean;\r\n    ldapAvailable: boolean;\r\n    fileBrowserBulkDownloadMaximumFileSize: number;\r\n    tempSettings?: TempSettings;\r\n}\r\n\r\nexport interface User {\r\n    id: number;\r\n    username: string;\r\n    firstName: Optional<string>;\r\n    lastName: Optional<string>;\r\n    isAdmin: boolean;\r\n    language: Optional<string>\r\n}\r\n\r\nexport interface Role {\r\n    id: any;\r\n    name: string;\r\n    permissions: String;\r\n    isAdmin: boolean;\r\n}\r\n\r\nexport interface Organization {\r\n    id: any;\r\n    name: string;\r\n    qualifiedName: string;\r\n    parent?: Organization;\r\n    children?: Organization[];\r\n}\r\n\r\nexport enum OrganizationFilter {\r\n    NONE = "NONE", LEFT_SIDE = "LEFT_SIDE"\r\n};\r\nexport interface OrganizationSettings {\r\n    globalOrganizationFilter: OrganizationFilter;\r\n}\r\n\r\nexport interface VisualStyleSettings {\r\n    appTitle?: string;\r\n    headerLogo?: string;\r\n    headerLogoRight?: boolean;\r\n    clientHeaderLogo?: string;\r\n    whiteBackgroundHeaderLogo?: boolean;\r\n    whiteBackgroundClientHeaderLogo?: boolean;\r\n\r\n    homeLogo?: string;\r\n    homeTitle?: string;\r\n    homeBackgroundImage?: string;\r\n    homeLogo2?: string;\r\n}\r\n\r\nexport interface HomePageSettings {\r\n    usePersonalHomePage: boolean;\r\n    dashboardId: number;\r\n    footerBarText: string;\r\n}\r\n\r\nexport interface ColorSettings {\r\n    data: Array<Color>\r\n}\r\n\r\nexport interface Color {\r\n    name: string;\r\n    value?: number;\r\n    thisColorIsAliasFor?: string\r\n}\r\n\r\nexport interface NotificationSettings {\r\n    maxNumberOfNotificationDisplayed: number;\r\n    refreshRate: number;\r\n}\r\n\r\nexport interface TempSettings {\r\n    historyGraphInitialFields: string;\r\n}\r\n\r\nexport interface AuditSettings {\r\n    maxRowsForPopup: number;\r\n}\r\n\r\nexport interface UserSettings {\r\n    passwordMinLength: number;\r\n    passwordMaxLength: number;\r\n    passwordHasUpperCaseConstraint: boolean;\r\n    passwordHasLowerCaseConstraint: boolean;\r\n    passwordHasNumberConstraint: boolean;\r\n    passwordHasSpecialCharacterConstraint: boolean;\r\n}\r\n\r\nexport type MenuEntry = {\r\n    id: number,\r\n    name: string,\r\n    icon: string,\r\n    color: string\r\n}\r\n\r\nexport interface InternationalizationSettings {\r\n    showBothOriginalAndTranslated: boolean;\r\n    translatableByUserLanguagesMap: {\r\n        [language: string]: {\r\n            entriesMap: { [original: string]: string }\r\n        }\r\n    },\r\n    dateFormat?: string,\r\n    timeFormat?: string,\r\n    dateFormats?: [\r\n        { name: string, momentJsFormat: string, momentJsFormatShorter: string }\r\n    ]\r\n    timeFormats?: [\r\n        { name: string, momentJsFormat: string, momentJsFormatShorter: string }\r\n    ],\r\n    defaultLanguage: string\r\n}\r\n\r\nexport interface ShowCrudButtons {\r\n    showImportButton: boolean,\r\n    showExportButton: boolean,\r\n    showShareLinkButton: boolean,\r\n    showCustomQueryButton: boolean,\r\n    showCustomQueryEmailSchedule: boolean,\r\n    showColumnConfigButton: boolean,\r\n    showAuditButton: boolean,\r\n    showExportAsCsvButton: boolean,\r\n}\r\n\r\nexport enum EntityFormLightOpenType { MODAL, DRAWER };\r\n\r\nconst menuEntries = [] as any[];\r\nvar menuInitialExpandedIds = {} as { [key: string]: boolean; };\r\nexport const searchOptions = {} as { [key: string]: string[] };\r\n\r\nclass SliceOrganizationTree extends SliceTree {\r\n\r\n    static ORGANIZATION_TREE_ROOT_ID = "organizationsTreeRootId";\r\n\r\n    hasChildren(item: any) {\r\n        if (item instanceof Array) {\r\n            return item.length > 0\r\n        }\r\n        return item?.children?.length > 0;\r\n    }\r\n\r\n    getChildren(item: any) {\r\n        if (item instanceof Array) {\r\n            return item.map((o: Organization) => ({ localId: "" + o.id, item: o }));\r\n        }\r\n        if (item.children) {\r\n            const children: any = [];\r\n            item.children?.sort((a: any, b: any) => a.name && b.name ? a.name.toLowerCase().localeCompare(b.name.toLowerCase()) : 0).forEach((o: Organization) => children.push({ localId: "" + o.id, item: o }));\r\n            return children;\r\n        }\r\n    }\r\n}\r\nconst sliceOrganizationsTree: SliceOrganizationTree = createSliceFoundation(SliceOrganizationTree);\r\n\r\n/**\r\n * @author Cristian Spiescu\r\n */\r\nexport class AppMeta {\r\n\r\n    componentCreated = false;\r\n\r\n    routes: JSX.Element[] = [];\r\n\r\n    entityCrudMenus: any[] | undefined;\r\n\r\n    reducerCombination: any = {};\r\n\r\n    showHorizontalMenu: boolean = false;\r\n\r\n    showSearchBarOnTitleBar: boolean = false;\r\n\r\n    showNotifications: boolean = true;\r\n\r\n    showTimeZone: boolean = true;\r\n\r\n    showOrganization: boolean = true;\r\n\r\n    showMyAccountMenuEntry: boolean = true;\r\n\r\n    showBackButton: boolean = false;\r\n    showReloadButton: boolean = false;\r\n    showHomeButton: boolean = true;\r\n    showClock: boolean = false;\r\n    showHeaderLogo: boolean = true;\r\n\r\n    removeMenuEntryWhenNoPermission: boolean = true;\r\n\r\n    scrollOnlyContentInEditor: boolean = false;\r\n\r\n    showCrudButtons: ShowCrudButtons = {\r\n        showImportButton: true,\r\n        showExportButton: true,\r\n        showShareLinkButton: true,\r\n        showCustomQueryButton: true,\r\n        showCustomQueryEmailSchedule: true,\r\n        showColumnConfigButton: true,\r\n        showAuditButton: true,\r\n        showExportAsCsvButton: true,\r\n    };\r\n\r\n    /**\r\n     * SH: Temporary property used to hide "View properties" tab on Proteus.\r\n     */\r\n    showViewPropertiesTab: boolean = true;\r\n\r\n    entityFormLightOpenType: EntityFormLightOpenType = EntityFormLightOpenType.MODAL;\r\n    /**\r\n     * SH: By default, for each ED, the property \'hasAttachedDashboards\' is true.\r\n     * This property is used to define if dashboards are implemented at the project level.\r\n     */\r\n    dashboardsAvailable: boolean = true;\r\n\r\n    newRootReducer = new RootReducerForPages();\r\n\r\n    zeroTrainingArticlesRegistry = new ZeroTrainingArticlesRegistry();\r\n\r\n    helperAppContainer!: ConnectedPageHelper<typeof sliceAppContainer>;\r\n\r\n    globalPermissions: Set<string> = new Set();\r\n\r\n    loadOrganizationsQuery!: DocumentNode;\r\n\r\n    store!: ToolkitStore;\r\n\r\n    // list of EntityDescriptors used by UI (e.g. for menu entries, role config)\r\n    protected uiEntityDescriptors: Optional<{ [entityName: string]: EntityDescriptor }>;\r\n\r\n    protected globalErrorHandler?: ClientErrorLogger;\r\n\r\n    get menuInitialExpandedIds() {\r\n        return menuInitialExpandedIds;\r\n    }\r\n\r\n    set menuInitialExpandedIds(value) {\r\n        menuInitialExpandedIds = value;\r\n    }\r\n\r\n    get menuEntries() {\r\n        return menuEntries;\r\n    }\r\n\r\n    set menuEntries(value) {\r\n        menuEntries.splice(0, menuEntries.length);\r\n        Array.prototype.push.apply(menuEntries, value); // this trick to pass an array into the varargs param\r\n    }\r\n\r\n    constructor(public metas: CompMeta<any, any>[]) {\r\n        this.globalPermissions.add(DATABASE_MENU_ENTRY);\r\n        if (AppMetaTempGlobals.appMetaInstance) {\r\n            // TODO CC: this doesn\'t work for storybook\r\n            // throw new Error("Illegal state: an instance of AppHelper already exists")\r\n        }\r\n        AppMetaTempGlobals.appMetaInstance = this;\r\n        AppMetaTempGlobals.appMetaInstance = this;\r\n\r\n        this.configQueries();\r\n        if (!Utils.isTest()) {\r\n            Utils.showGlobalAlert = params => {\r\n                // Sometimes when developing, we may generate an error so early, that the React app is not completely setup.\r\n                // And in this case it\'s shameful to generate another error while trying to display the initial error. \r\n                // Hence the "fallback" version below\r\n                if (!this.helperAppContainer?.dispatchers) {\r\n                    alert(`Global alert fallback. Severity: ${params.severity}. Title: ${params.title}\\nMessage: ${params.message}`);\r\n                    return;\r\n                }\r\n                this.helperAppContainer.dispatchers.showGlobalAlert(params);\r\n            }\r\n        }\r\n\r\n        metas.forEach((m, i) => {\r\n            m.contributeRootReducer(this.reducerCombination);\r\n            this.routes.push(m.createRoute(this.computeRoute));\r\n        });\r\n        this.routes.push(ZeroTrainingIndexPageRoute());\r\n        this.routes.push(ZeroTrainingArticlePageRoute());\r\n\r\n        this.zeroTrainingArticlesRegistry.addFromModule(zeroTrainingZt);\r\n        // this.zeroTrainingArticlesRegistry.addFromModule(zeroTrainingAudit);\r\n        this.addEntityDescriptors([customQueryEntityDescriptor]);\r\n        this.addEntityDescriptors([columnConfigEntityDescriptor]);\r\n        // The current user slice extends the user slice that requires the one to many entity descriptors to be defined\r\n        // @see EntityEditorPage.onBeforeMergeByConnectedPageHelper\r\n        this.addEntityDescriptors([roleToUserEntityDescriptor]);\r\n\r\n        SliceEntityEditorPage.sliceColumnConfigDropdown = sliceColumnConfigDropdown;\r\n        SliceEntityEditorPage.ColumnConfigDropdown = ColumnConfigDropdown;\r\n        this.getCurrentUser = this.getCurrentUser.bind(this);\r\n        this.computeRoute = this.computeRoute.bind(this);\r\n        // This method, besides other things, creates the routes described in each entityDescriptor.connectedPageInfo \r\n        // We need this to execute no matter if a user is currently logged in order for the <PrivateRoutes> to be registered \r\n        // so that the redirect to login mechanism (when no user logged in) to work \r\n        this.entityCrudMenus = AppMetaTempGlobals.appMetaInstance.finalizeEntityDescriptors();\r\n        //  register the globalErrorHandler\r\n        this.createGlobalErrorHandler();\r\n    }\r\n\r\n    // #region client-error-logger-start\r\n    protected createGlobalErrorHandler() {\r\n        this.globalErrorHandler = new ClientErrorLogger().start();\r\n    }\r\n    // #endregion\r\n\r\n    /**\r\n     * CC: Temporary property, call or not onLocationChanged from appContainer constructor\r\n     * Is set to false for XopsMobile APK.\r\n    */\r\n    canCallOnLocationChangedFromAppContainerConstructor(): boolean {\r\n        return true;\r\n    }\r\n\r\n    protected computeRouteForComponent(props: PrivateRouteProps) {\r\n        return <Route {...props} component={props.component} />;\r\n    }\r\n\r\n    protected computeRoute(props: PrivateRouteProps): JSX.Element {\r\n        if (props.privateRoute === false || !ConnectedPageHelper.tempEnableSecurity) {\r\n            return this.computeRouteForComponent(props);\r\n        }\r\n        if (!this.getCurrentUser()) {\r\n            return <Redirect to={{ pathname: \'/login\', state: { from: props.location } }} />;\r\n        }\r\n        return !props.permission || this.hasPermission(props.permission) ? this.computeRouteForComponent(props) : this.getRedirectToError(props.permission, props.location);\r\n    }\r\n\r\n    addConnectedPageInfos(infos: ConnectedPageInfo[]) {\r\n        for (let info of infos) {\r\n            const helper = new ConnectedPageHelper(info);\r\n            this.newRootReducer.add(helper);\r\n            this.routes.push(helper.getRoute(this.computeRoute));\r\n        }\r\n    }\r\n\r\n    createStore(initialState?: any, history?: History) {\r\n        this.helperAppContainer = new ConnectedPageHelper<typeof sliceAppContainer>(infoAppContainer);\r\n        this.newRootReducer.add(this.helperAppContainer);\r\n\r\n        Utils.showSpinner = (spinnerText?: string, showSpinnerCloseButton: boolean = true) => this.helperAppContainer.dispatchers.setInReduxState({ showSpinner: true, spinnerText: spinnerText, showSpinnerCloseButton: showSpinnerCloseButton });\r\n        Utils.hideSpinner = () => this.helperAppContainer.dispatchers.setInReduxState({ showSpinner: false, spinnerCloseConfirmationModalOpen: false });\r\n\r\n        if (!this.menuEntries) {\r\n            this.menuEntries = [];\r\n        }\r\n\r\n        const middleware: any = [thunk];\r\n        let rc = this.reducerCombination;\r\n        if (history) {\r\n            middleware.push(routerMiddleware(history));\r\n            rc = { ...rc, router: connectRouter(history) };\r\n        }\r\n        return configureStore({ reducer: this.createRootReducer(rc), preloadedState: initialState, \r\n            enhancers: [ReduxReusableComponents.storeEnhancer],\r\n            middleware: getDefaultMiddleware => [...getDefaultMiddleware(ReduxReusableComponents.enhanceMiddlewareConfig()), ...middleware],\r\n        }) as unknown as EnhancedStore<any, any>;\r\n    }\r\n\r\n    createRootReducer(reducerCombination: any) {\r\n        const combinedReducer: any = combineReducers(reducerCombination);\r\n        return (state: any, action: any) => {\r\n            if (action.type === ACTION_RESET_STORE) {\r\n                // state.router is not reset in order to preserve the current route for the user\r\n                return { router: state.router };\r\n            }\r\n            const newState = this.newRootReducer.reducer(state, action);\r\n            // newState.router = rc.router(state?.router, action);\r\n\r\n            // temp ca sa scapam de warning/eroare emis de reducerul creat de combineReducers()\r\n            const cleanedUpOldState = !state ? undefined : Object.keys(reducerCombination).reduce((obj, field) => {\r\n                obj[field] = state[field];\r\n                return obj;\r\n            }, {} as any);\r\n\r\n            Object.assign(newState, combinedReducer(cleanedUpOldState, action));\r\n            return newState;\r\n        }\r\n    }\r\n\r\n    protected async invokeGetInitializationsForClientQuery(options: QueryOptions) {\r\n        return await apolloClientHolder.apolloClient.query(options);\r\n    }\r\n\r\n    protected async loadInitializationsForClient_fromConstructor() {\r\n        this.loadInitializationsForClient();\r\n    }\r\n\r\n    protected initRRCSingletons() {\r\n\r\n    }\r\n\r\n    public async loadInitializationsForClient() {\r\n        const query = this.getClientInitializationService_initializationsForClient_query(this.getFieldsForInitializationsForClient());\r\n        const initializationsForClient = (await this.invokeGetInitializationsForClientQuery({ query, context: { showSpinner: false } })).data.clientInitializationService_initializationsForClient as FoundationInitializationsForClient;\r\n\r\n        document.title = this.getAppTitle(initializationsForClient.visualStyleSettings);\r\n        global.oktaAuthenticationAvailable = initializationsForClient.oktaAuthenticationAvailable === true;\r\n        global.rememberMeEnabled = initializationsForClient.rememberMeEnabled === true;\r\n        global.fileBrowserBulkDownloadMaximumFileSize = initializationsForClient.fileBrowserBulkDownloadMaximumFileSize;\r\n        \r\n        const dateFormat = initializationsForClient.internationalizationSettings?.dateFormats?.find(f => f.name === initializationsForClient.internationalizationSettings?.dateFormat);\r\n        if (dateFormat) {\r\n            Utils.dateFormat = dateFormat.momentJsFormat;\r\n            Utils.dateFormatShorter = dateFormat.momentJsFormatShorter;\r\n        }\r\n        const timeFormat = initializationsForClient.internationalizationSettings?.timeFormats?.find(f => f.name === initializationsForClient.internationalizationSettings?.timeFormat);\r\n        if (timeFormat) {\r\n            Utils.timeFormat = timeFormat.momentJsFormatShorter;\r\n            Utils.timeWithSecFormat = timeFormat.momentJsFormat;\r\n        }\r\n        Utils.dateTimeFormat = Utils.dateFormat + " " + Utils.timeFormat;\r\n        if (initializationsForClient.colorSettings) {\r\n            ColorRegistry.INSTANCE.init(initializationsForClient.colorSettings);\r\n        }\r\n\r\n        Messages.getInstance().setTranslatableByUser({\r\n            // internationalizationSettings currently not available for prot; hence ?\r\n            getShowBothOriginalAndTranslated: () => initializationsForClient.internationalizationSettings?.showBothOriginalAndTranslated,\r\n            get: (language: string, original: string) => {\r\n                const l = initializationsForClient.internationalizationSettings?.translatableByUserLanguagesMap[language];\r\n                if (!l) { return null };\r\n                return l.entriesMap[original];\r\n            }\r\n        });\r\n\r\n        this.resetMenuEntries();\r\n\r\n        let language = initializationsForClient.internationalizationSettings.defaultLanguage;\r\n\r\n        if (initializationsForClient.currentUser?.language) {\r\n            let userSettings = initializationsForClient.crudSettings?.forEntities.find((forEntity) => forEntity.entityName === "User")\r\n            if (userSettings) {\r\n                // Check if the user language exists in fieldIntervals for `language` field (known languages)\r\n                let currentUserLanguage = userSettings.fieldDescriptorSettings\r\n                    .find((field) => field.fieldRef === "language")?.fieldIntervals?.find((interval) =>\r\n                        interval.from === initializationsForClient.currentUser?.language);\r\n                if (currentUserLanguage) {\r\n                    language = initializationsForClient.currentUser.language\r\n                }\r\n            }\r\n        }\r\n\r\n        Messages.getInstance().setLanguage(language);\r\n\r\n        // We will add entries in menu only if a user is logged in \r\n        if (initializationsForClient.currentUser) {\r\n            if (this.hasHomePageMenuEntry()) {\r\n                this.menuEntries.push({ content: _msg("HomePage.title"), to: "/", icon: "home", exact: true });\r\n            }\r\n\r\n            // We update the content of the menu entries in order for their messages to be translated in the current user language\r\n            this.entityCrudMenus = this.entityCrudMenus!.map(menuEntry => { return { ...menuEntry, content: _msg(menuEntry.entityMenuProps.labelKey) } });\r\n            this.entityCrudMenus = this.entityCrudMenus!.sort(this.compareMenuEntries);\r\n            this.menuEntries.push(...this.createMenuEntries(initializationsForClient, this.entityCrudMenus));\r\n\r\n            if (initializationsForClient.currentUser?.isAdmin || AppMetaTempGlobals.appMetaInstance.hasPermission(DATABASE_MENU_ENTRY, false, initializationsForClient.currentPermissions)) {\r\n                this.menuEntries.push({ content: _msg("Menu.database"), icon: "database", submenus: this.entityCrudMenus });\r\n            }\r\n        }\r\n\r\n        await this.getEntityDescriptorsForServer();\r\n        this.addCustomFieldsToEntityDescriptors();\r\n\r\n        if (initializationsForClient.currentUser) {\r\n            this.initRRCSingletons();\r\n        }\r\n\r\n        if (initializationsForClient.currentUser && AppMetaTempGlobals.appMetaInstance.showOrganization) {\r\n            await this.loadOrganizations(initializationsForClient.currentUser, initializationsForClient.currentOrganization);\r\n        }\r\n\r\n        this.populateDescriptorsWithSettings(initializationsForClient.crudSettings);\r\n        this.helperAppContainer.dispatchers.setInReduxState({ initializationsForClientLoaded: true, initializationsForClient });\r\n\r\n        // assign/switch "/" for routes: home <-> personalHomePage\r\n        for (let i = 0; i < this.routes.length; i++) {\r\n            const route = this.routes[i];\r\n            let props: AppRouteProps = route.props;\r\n            if (props.homePageType) {\r\n                let newPath: string;\r\n                if (props.homePageType === "normal") {\r\n                    newPath = initializationsForClient.homePageSettings.usePersonalHomePage ? "/homeOld" : "/";\r\n                } else {\r\n                    // props.homePageType === "personal"\r\n                    newPath = initializationsForClient.homePageSettings.usePersonalHomePage ? "/" : "/personalHomePage";\r\n                }\r\n                this.routes[i] = <route.type key={route.key} {...props} path={newPath} />\r\n            }\r\n        }\r\n        if (AppMetaTempGlobals.history.location.pathname === "/") {\r\n            // if pers home page, sometimes the normal home page is still displayed\r\n            // a re-render (e.g. via "forceUpdate()") would suffice; but currently I cannot have a reliable\r\n            // comp here; hence I work on the history; I observed that this action doesn\'t add a new \r\n            // history entry, and it seems to force a rerender\r\n            AppMetaTempGlobals.history.push("/");\r\n        }\r\n\r\n        window.sessionStorage.removeItem(sessionGlobalReload);\r\n\r\n        return initializationsForClient;\r\n    }\r\n\r\n    /**\r\n     * Copies (merges) the FieldDescriptorSettings received from the server, into the ones that exist on the client.\r\n     * Having FDS defined on the client is not a common practice, but it\'s possible.\r\n     */\r\n    protected populateDescriptorsWithSettings(crudSettings?: CrudSettings) {\r\n        global.crudSettings = crudSettings;\r\n        crudSettings?.forEntities.map(forEntity => {\r\n            const ed = entityDescriptors[forEntity.entityName];\r\n            if (!ed) {\r\n                return;\r\n            }\r\n            ed.entityDescriptorSettings = forEntity;\r\n            forEntity.fieldDescriptorSettings.forEach(fdSettings => {\r\n                if (!fdSettings.fieldRef || ed?.getFieldDescriptorChain(fdSettings.fieldRef).length === 0 || ed?.getFieldDescriptorChain(fdSettings.fieldRef)[0] === undefined) {\r\n                    return;\r\n                }\r\n                let fds = [ed?.getField(fdSettings.fieldRef)];\r\n                fds.forEach(fd => {\r\n                    if (fd) {\r\n                        // IMPORTANT: for lists it will merge items based on their indexes!!! \r\n                        // For the moment we don\'t see a real case for it.\r\n                        // There is also a \'mergeWith\' if we need to do something else for them in the future.\r\n                        fd.fieldDescriptorSettings = lodash.merge(fd.fieldDescriptorSettings, fdSettings);\r\n                        if (fdSettings.icon) {\r\n                            fd.icon = fdSettings.icon as SemanticICONS;\r\n                        }\r\n                    }\r\n                });\r\n            })\r\n        });\r\n    }\r\n\r\n    public hasPermission(permission: string, showErrorMessageIfNoPermission?: boolean, permissions?: any): boolean {\r\n        if (TestUtils.storybookMode || Utils.isTest()) {\r\n            return true;\r\n        }\r\n        const value = this.helperAppContainer.dispatchers.hasPermission(permission, permissions);\r\n        if (!value && showErrorMessageIfNoPermission) {\r\n            this.helperAppContainer.dispatchers.showGlobalAlert({ message: _msg("error.insufficient.rights.title") + "\\n" + _msg("error.insufficient.rights.details", \'"\' + permission + \'"\'), severity: Severity.ERROR });\r\n        }\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Meant to be overwritten\r\n     * @author Daniela Buzatu\r\n     */\r\n    public getRedirectToError(permission: string, location?: any) {\r\n        return <Redirect to={{ pathname: \'/error\', state: { from: location, headerMessage: _msg("error.insufficient.rights.title"), errorMessage: _msg("error.insufficient.rights.details", permission) } }} />;\r\n    }\r\n\r\n    protected async getEntityDescriptorsForServer() {\r\n        const operationName = "entityDescriptorForServerService_entityDescriptors";\r\n        const result = (await apolloClientHolder.apolloClient.query({ query: gql(`query q{ ${operationName} }`), context: { showSpinner: false } })).data[operationName];\r\n        Object.assign(EntityDescriptorForServerUtils.entityDescriptorsForServer, result);\r\n    }\r\n\r\n    protected addCustomFieldsToEntityDescriptors() {\r\n        for (const ed of Object.values(entityDescriptors)) {\r\n            const fields = Object.values(ed.fields).filter(field => field.isCustomField === true).map(field => field.name);\r\n            if (fields && fields.length > 0) {\r\n                ed.removeFieldDescriptors(...fields);\r\n            }\r\n        }\r\n\r\n        new Set<string>(Object.values(EntityDescriptorForServerUtils.entityDescriptorsForServer)\r\n            .map(entity => entity.entityName))\r\n            .forEach(entityName => {\r\n                Object.entries(EntityDescriptorForServerUtils.entityDescriptorsForServer[entityName].fields)\r\n                    .filter(([key, field]) => key === field.fieldName && field.customField)\r\n                    .forEach(([key, field]) => {\r\n                        entityDescriptors[entityName].addFieldDescriptor({\r\n                            name: field.fieldName,\r\n                            type: field.fieldType || FieldType.defaultScalar,\r\n                            isCustomField: true\r\n                        })\r\n                    })\r\n            });\r\n    }\r\n\r\n    protected getFieldsForOrg() {\r\n        return "id name qualifiedName"\r\n    }\r\n\r\n    protected getStructureForOrg() {\r\n        const orgFields = this.getFieldsForOrg();\r\n        return `${orgFields} parent { ${orgFields} } children { \r\n            ${orgFields} children {\r\n                ${orgFields} children {\r\n                    ${orgFields} children {\r\n                        ${orgFields} \r\n                    }\r\n                }\r\n            }\r\n        }`;\r\n    }\r\n\r\n    protected configQueries = () => {\r\n        const orgStructure = this.getStructureForOrg();\r\n        this.loadOrganizationsQuery = gql(`query userService_getOrganizations($userId: Long!) {\r\n            userService_organizations(userId: $userId) { \r\n                ${orgStructure}\r\n            } \r\n          }`);\r\n    }\r\n    protected async loadOrganizations(user: User, currentOrg: Optional<Organization>) {\r\n        const result = (await apolloClientHolder.apolloClient.query({ query: this.loadOrganizationsQuery, variables: { userId: user.id }, context: { showSpinner: false } })).data.userService_organizations;\r\n        global.organizations = result;\r\n        // get value from session if available\r\n        const orgId = window.sessionStorage.getItem(sessionGlobalCurrentOrganizationToFilterBy);\r\n        const orgFilterFromSession = orgId !== null && orgId !== "" ? global.organizations?.find(o => orgId === "" + o.id) : undefined;\r\n        global.currentOrganizationToFilterBy = orgFilterFromSession?.id === currentOrg?.id ? undefined : orgFilterFromSession;\r\n        // set tree root\r\n        let orgTreeRoot = {\r\n            children:\r\n                currentOrg\r\n                    ? result.filter((x: Organization) => x.qualifiedName === currentOrg.qualifiedName)\r\n                    : [{ id: SliceOrganizationTree.ORGANIZATION_TREE_ROOT_ID }].concat(result.filter((x: Organization) => x.parent === null))\r\n        }\r\n        this.helperAppContainer.dispatchers.organizationsTree.setInReduxState({ root: orgTreeRoot });\r\n        // select root node if no selection provided\r\n        !global.currentOrganizationToFilterBy && this.helperAppContainer.dispatchers.organizationsTree.selectItem(currentOrg ? "" + currentOrg.id : SliceOrganizationTree.ORGANIZATION_TREE_ROOT_ID);\r\n    }\r\n\r\n    protected getClientInitializationService_initializationsForClient_query(fields: string) {\r\n        return gql(`query q { clientInitializationService_initializationsForClient { ${fields} } }`);\r\n    }\r\n\r\n    protected getSecurityFieldsForInitializationsForClient() {\r\n        return " currentRole {id name} currentOrganization {id qualifiedName name} currentPermissions allOrganizationsAccess ldapAvailable rememberMeEnabled";\r\n    }\r\n\r\n    protected getFieldsForInitializationsForClient() {\r\n        let result = "";\r\n        if (ConnectedPageHelper.tempEnableSecurity) {\r\n            result += this.getSecurityFieldsForInitializationsForClient();\r\n        }\r\n\r\n        result += ` version \r\n        visualStyleSettings { appTitle headerLogo clientHeaderLogo whiteBackgroundHeaderLogo whiteBackgroundClientHeaderLogo homeLogo homeTitle homeBackgroundImage homeLogo2 headerLogoRight } \r\n        homePageSettings { usePersonalHomePage dashboardId footerBarText }\r\n        internationalizationSettings { defaultLanguage showBothOriginalAndTranslated translatableByUserLanguagesMap dateFormat timeFormat dateFormats { name momentJsFormat momentJsFormatShorter } timeFormats { name momentJsFormat momentJsFormatShorter }  }\r\n        colorSettings { data { name value thisColorIsAliasFor } } \r\n        notificationSettings { maxNumberOfNotificationDisplayed refreshRate }\r\n        auditSettings { maxRowsForPopup }\r\n        userSettings { passwordMinLength passwordMaxLength  passwordHasUpperCaseConstraint passwordHasLowerCaseConstraint passwordHasNumberConstraint passwordHasSpecialCharacterConstraint }\r\n        crudSettings { forEntities { entityName defaultColumnConfig defaultCustomQuery externalLink editorHeaderImage fieldsInHeader { name fields } fieldDescriptorSettings { fieldRef inHeaderOrderIndex physicalQuantity measurementUnit numberOfDecimals fieldIntervals { from to enumOrderIndex color applyColorTo label } } } physicalQuantities { name defaultMeasurementUnitSymbol measurementUnits { name symbol scaleFactorTowardsDefaultMeasurementUnit translationFactorTowardsDefaultMeasurementUnit } } }\r\n        organizationSettings { globalOrganizationFilter }\r\n        oktaAuthenticationAvailable\r\n        fileBrowserBulkDownloadMaximumFileSize\r\n        tempSettings { historyGraphInitialFields }\r\n        `;\r\n\r\n        return result;\r\n    }\r\n\r\n    beforeLogout() {\r\n        // nothing here, used by super\r\n    }\r\n\r\n    createLogoutParams() {\r\n        return { oktaUserId: document.cookie.split(\'; \').find((row: string) => row.startsWith(\'oktaUserId=\'))?.split(\'=\')[1] };\r\n    }\r\n\r\n    async logout() {\r\n        this.beforeLogout();\r\n\r\n        // We need to clean sessionStorage at logout. In this way, different unsaved changes from this session\r\n        // (e.g. changes for default CCs or CQs on different tables) are deleted and default values are restored\r\n        window.sessionStorage.clear();\r\n\r\n        this.helperAppContainer.dispatchers.setInReduxState({ initializationsForClient: undefined, initializationsForClientLoaded: false });\r\n\r\n        // when processing a GraphQL request server-side, we don\'t have a access to a HTTP response\r\n        // to delete a cookie for the client. Server-side, we lose the token entity for this session, so,\r\n        // even if we didn\'t delete it here, automatic login would not be possible.\r\n        document.cookie = "auth_token=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";\r\n\r\n        await apolloClient.mutate<logout>({ mutation: LOGOUT, variables: { logoutParams: this.createLogoutParams() } });\r\n\r\n        this.loadInitializationsForClient();\r\n\r\n        if (ConnectedPageHelper.tempEnableSecurity) {\r\n            AppMetaTempGlobals.history.push("/login");\r\n        }\r\n    }\r\n\r\n    async afterLogin() {\r\n        await AppMetaTempGlobals.appMetaInstance.loadInitializationsForClient();\r\n    }\r\n\r\n    getAppTitle(visualStyleSettings: Optional<VisualStyleSettings>) {\r\n        return visualStyleSettings?.appTitle || "App title";\r\n    }\r\n\r\n    public getAdditionalItemsForRightMenu(): any | null {\r\n        return null;\r\n    }\r\n\r\n    public getAdditionalUserMenuEntries(): any[] {\r\n        return [];\r\n    }\r\n\r\n    public getAdditionalUserHeaderEntries(): any[] {\r\n        return [];\r\n    }\r\n\r\n    public getIsSpecialPageWithoutHeader() {\r\n        return AppMetaTempGlobals.history.location.pathname.startsWith("/passwordResetFinish");\r\n    }\r\n\r\n    public goBack() {\r\n        AppMetaTempGlobals.history.goBack();\r\n    }\r\n\r\n    addEntityDescriptors(eds: EntityDescriptor[]) {\r\n        // nop for the moment; at least forces the user to import the script and call this\r\n        // in the future, this should invoke a runnable to trigger the customization\r\n    }\r\n\r\n    finalizeEntityDescriptors() {\r\n        // duplicated below :(\r\n        EntityDescriptorPopulatorFromEntityGen.INSTANCE.processRemainingEntitiesGen();\r\n        runAfterStartupRunnables();\r\n\r\n        // create pages and add in menu list only the ones in uiEntityDescriptors\r\n        let eds = this.getUIEntityDescriptors();\r\n        const entityCrudMenus = [];\r\n        for (let ed in eds) {\r\n            const d = eds[ed];\r\n            this.addConnectedPageInfos(d.getHelpers());\r\n            entityCrudMenus.push(d.getMenuEntry());\r\n        }\r\n\r\n        return entityCrudMenus;\r\n    }\r\n\r\n    getUIEntityDescriptors(): { [entityName: string]: EntityDescriptor } {\r\n        if (this.uiEntityDescriptors === undefined) {\r\n            this.uiEntityDescriptors = {};\r\n            Object.values(entityDescriptors).filter(ed => ed.showInUI).map(ed => this.uiEntityDescriptors![ed.name] = ed);\r\n        }\r\n        return this.uiEntityDescriptors!;\r\n    }\r\n\r\n    protected renderRRCSingletons() {\r\n        return <></>;\r\n    }\r\n\r\n    getAppComponent = () => {\r\n        if (this.componentCreated) {\r\n            throw new Error("Illegal state; app already created");\r\n        }\r\n\r\n        if (TestUtils.storybookMode) {\r\n            // duplicated from above :(\r\n            runAfterStartupRunnables();\r\n        }\r\n        initApolloClient();\r\n\r\n        const that = this;\r\n        const history = createHashHistory();\r\n        AppMetaTempGlobals.history = history;\r\n        history.listen(l => {\r\n            AppMetaTempGlobals.locationPathnamePrevious = AppMetaTempGlobals.locationPathnameCurrent;\r\n            AppMetaTempGlobals.locationPathnameCurrent = l.pathname;\r\n        });\r\n\r\n        return class extends React.Component<any, { reloading: boolean }> {\r\n            constructor(props: any) {\r\n                super(props);\r\n                this.softReload = this.softReload.bind(this);\r\n\r\n                that.store = that.createStore(undefined, history);\r\n\r\n                this.state = { reloading: false };\r\n                that.loadInitializationsForClient_fromConstructor();\r\n            }\r\n\r\n            /**\r\n             * Previously, when the user would change the organization, a full web page reload would be triggered. This was reasonable,\r\n             * because we want all state cleared, which may be: Redux, local component state, "normal" variables/attributes. We don\'t want\r\n             * an individual component or page to have an additional responsability: "please be ready to do a full reset, if the user changes\r\n             * the org".\r\n             * \r\n             * However, this is a no go when executing tests. Because the test is run within the window of this app which is just being reloaded.\r\n             * \r\n             * So we introduced this function. The process is the following:\r\n             * 1. `this.state.reloading = true`;\r\n             * 2. on next update/render the root component will onmount everything. So all components in the hiearachy are unmounted / die. Normally\r\n             * this would kill all kind of internal state\r\n             * 3. on next update: schedule that on next update (when the components are unmounted), a "store empty" action is issued\r\n             * 4. the components will render again normally, and the Redux state will begin naturally to be populated by the components that\r\n             * are just mounted\r\n             */\r\n            softReload() { \r\n                this.setState({ reloading: true });\r\n            }\r\n\r\n            async componentDidUpdate(prevProps: Readonly<any>, prevState: Readonly<{ reloading: boolean; }>): Promise<void> {\r\n                if (prevState.reloading !== this.state.reloading && this.state.reloading) {\r\n                    // needed because the components aren\'t yet unmounted; see ConnectedPageHelper.initHOCs() -> componentWillUnmount()\r\n                    await Utils.setTimeoutAsync();\r\n\r\n                    // Removing the items in session storage so that for an org switch => default org CC/CQ are used instead of what the user had in storage\r\n                    // TODO: this should be replaced with a subscription mechanism\r\n                    window.sessionStorage.removeItem(currentColumnConfigId);\r\n                    window.sessionStorage.removeItem(currentEditorColumnConfigId);\r\n                    window.sessionStorage.removeItem(currentCustomQueryId);\r\n                    window.sessionStorage.removeItem(sessionGlobalCurrentOrganizationToFilterBy);\r\n                    // reset the store\r\n                    that.store.dispatch({ type: ACTION_RESET_STORE });\r\n                    // rerender & reload data\r\n                    this.setState({ reloading: false });\r\n                    that.loadInitializationsForClient_fromConstructor();\r\n                }\r\n            }\r\n\r\n            render() {\r\n                return !this.state.reloading && <>\r\n                    <Provider store={that.store}>\r\n                        {that.renderRRCSingletons()}\r\n                        <ColorRegistryRRC id={RRC_SINGLETON} />\r\n                        <RootReducerForPages.Context.Provider value={that.newRootReducer}>\r\n                            <ZeroTrainingContext.Provider value={that.zeroTrainingArticlesRegistry}>\r\n                                <ConnectedRouter history={history}>\r\n                                    <that.helperAppContainer.componentClass onSoftReload={this.softReload} />\r\n                                </ConnectedRouter>\r\n                            </ZeroTrainingContext.Provider>\r\n                        </RootReducerForPages.Context.Provider>\r\n                    </Provider>\r\n                </>;\r\n            }\r\n        }\r\n    }\r\n\r\n    protected hasHomePageMenuEntry() {\r\n        return true;\r\n    }\r\n\r\n    protected createMenuEntries(data: FoundationInitializationsForClient, entityCrudMenus: any): any {\r\n        return [];\r\n    }\r\n\r\n    protected resetMenuEntries() {\r\n        this.menuEntries = [];\r\n    }\r\n\r\n    protected compareMenuEntries(a: any, b: any) {\r\n        return a.content.localeCompare(b.content);\r\n    }\r\n\r\n    getCurrentUser(): Optional<User> {\r\n        return this.helperAppContainer.dispatchers.getState().initializationsForClient.currentUser;\r\n    }\r\n\r\n    getCurrentOrganization(): Optional<Organization> {\r\n        return this.helperAppContainer.dispatchers.getState().initializationsForClient.currentOrganization;\r\n    }\r\n\r\n    getVisualStyleSettings(): Optional<VisualStyleSettings> {\r\n        return this.helperAppContainer.dispatchers.getState().initializationsForClient.visualStyleSettings;\r\n    }\r\n\r\n    enableModalRoutes() {\r\n        return true;\r\n    }\r\n\r\n    getColor(colorKey: any): string {\r\n        const colorFromRegistry = ColorRegistry.INSTANCE.get(colorKey);\r\n        if (colorFromRegistry !== -1 && colorFromRegistry !== 0) {\r\n            return Utils.convertColorToHex(colorFromRegistry);\r\n        }\r\n        if (typeof colorKey === \'number\') {\r\n            return Utils.convertColorToHex(colorKey);\r\n        }\r\n        if (typeof colorKey === \'string\' && !colorKey.trim().startsWith("#")) {\r\n            return Utils.DEFAULT_TEXT_COLOR;\r\n        }\r\n        return colorKey;\r\n    }\r\n\r\n    getOrganizationTreeIcon(itemId: string, object: any, currentOrg: Optional<Organization>) {\r\n        let icon = organizationEntityDescriptor.getIcon();\r\n        if (object.children?.length > 0 && (itemId !== SliceOrganizationTree.ORGANIZATION_TREE_ROOT_ID || currentOrg)) {\r\n            icon = <></>;\r\n        }\r\n        return icon;\r\n    }\r\n\r\n    getUserInfo(user: User): React.ReactNode {\r\n        return <div className="flex-container gap5 AppContainer_userInfo">\r\n            <span className="no-wrap-no-overflow-ellipsis"><Icon name=\'user\' className="AppContainer_menu_icon_without_label" /> {user?.username}</span>\r\n            {this.renderAdditionalUserInfo(user)}\r\n        </div>\r\n    }\r\n\r\n    getVersionInfo(version: string): React.ReactNode {\r\n        return <span>{version}</span>;\r\n    }\r\n\r\n    protected renderAdditionalUserInfo(user: User): React.ReactNode {\r\n        return <></>;\r\n    }\r\n}\r\n\r\nexport const sliceAppContainer = createSliceFoundation(class SliceAppContainer {\r\n    initialState = {\r\n        drawerOpen: false,\r\n        searchBarHasFocus: false,\r\n        initializationsForClientLoaded: false,\r\n        avoidDisplayingInitializationsLoadingSpinner: false,\r\n        /**\r\n         * Unfortunately we didn\'t find a way to reuse the type of the app (which extends this class).\r\n         * So when we access the state of this, we need to perform a cast beforehand.\r\n         */\r\n        initializationsForClient: undefined as any as FoundationInitializationsForClient,\r\n        globalAlertTitle: undefined as string | undefined,\r\n        globalAlertMessage: undefined as string | undefined,\r\n        globalAlertShownAsMessage: false,\r\n        menuEntries: {} as { [key: string]: Optional<MenuEntry[]> },\r\n        globalAlertSeverity: undefined as unknown as Severity | undefined,\r\n\r\n        // support for modal routes; if enabled, these are calculated by onLocationChanged(); and then these locations are used \r\n        // during render; i.e. from here/Redux state, instead of the current location of the browser\r\n        locationForMain: undefined as Location<any> | undefined,\r\n        locationForMainRouteEntityName: undefined as string | undefined,\r\n        locationForDrawer: undefined as Location<any> | undefined,\r\n        locationsForModals: [] as Location<any>[],\r\n        currentUserModalOpen: false,\r\n        showSpinner: false,\r\n        spinnerText: undefined as string | undefined,\r\n        showSpinnerCloseButton: true,\r\n        spinnerCloseConfirmationModalOpen: false\r\n    }\r\n\r\n    nestedSlices = {\r\n        notificationComponent: sliceNotificationComponent,\r\n        organizationsTree: sliceOrganizationsTree\r\n    }\r\n\r\n    reducers = {\r\n        ...getBaseReducers<SliceAppContainer>(this),\r\n\r\n        // message = undefined => closes the modal, everything else shows the modal with the message\r\n        // DON\'T use directly; use Utils.showGlobalAlert() instead\r\n        showGlobalAlert(state: StateFrom<SliceAppContainer>, params: ShowGlobalAlertParams) {\r\n            state.globalAlertTitle = params.title;\r\n            state.globalAlertShownAsMessage = false;\r\n            state.globalAlertMessage = params.message;\r\n            state.globalAlertSeverity = params.severity;\r\n            // EM: trebuie revizuit acest cod, in alta limba nu o sa fie acelasi text;\r\n            // nu ar trebui facuta parsare de text, ar trebui transmis un parametru\r\n            if (params.message?.includes("Permission needed but not granted:")) {\r\n                state.globalAlertShownAsMessage = true;\r\n                state.globalAlertTitle = _msg("error.insufficient.rights.title");\r\n                // it\'s ok to use ! in this case, since if the test contains "Permission .." then it should also contain the permission\r\n                const permission = /Permission needed but not granted: ([_A-Za-z0-9|, ]*)/.exec(params.message)![1];\r\n                state.globalAlertMessage = _msg("error.insufficient.rights.details", permission);\r\n            }\r\n        }\r\n    }\r\n\r\n    impures = {\r\n        ...getBaseImpures<SliceAppContainer>(this),\r\n\r\n        hasPermission(permission: string, permissions?: any): boolean {\r\n            return Utils.hasPermission(permission, permissions ? permissions : this.getState().initializationsForClient?.currentPermissions);\r\n        },\r\n\r\n        async loadMenuEntries(entityName: string) { // can be used only for Dashboard or Chart (note: Chart isn\'t in foundation yet)\r\n            const operationName = _.lowerFirst(entityName) + "Service_findByFilter";\r\n            const params = FindByFilterParams.create().filter(Filter.create("showInMenu", FilterOperators.forBoolean.equals, "TRUE")).sorts([{ field: "positionInMenu", direction: "ASC" }]);\r\n            const query = gql(`query q($params: FindByFilterParamsInput) { \r\n                ${operationName}(params: $params) {\r\n                    results {\r\n                        id, name, icon, color\r\n                    }\r\n                }\r\n            }`);\r\n            const menuEntries = (await apolloClient.query({ query: query, variables: params, context: { showSpinner: false } })).data[operationName].results;\r\n            this.getDispatchers().setInReduxState({ menuEntries: { ...this.getState().menuEntries, ...{ [entityName]: menuEntries } } });\r\n        }\r\n    }\r\n});\r\n\r\nexport type AppContainerProps = PropsFrom<typeof sliceAppContainer> & { onSoftReload: () => void; [key: string]: any };\r\n\r\nexport class AppContainer extends React.Component<AppContainerProps> {\r\n\r\n    protected refTreeMenu = React.createRef<TreeMenu>();\r\n    protected refTreeMenuSearchWrapper = React.createRef<WrapperWithRenderFunction>();\r\n    protected onLocationChangedUnregisterCallback: UnregisterCallback;\r\n\r\n    constructor(props: AppContainerProps) {\r\n        super(props);\r\n       \r\n        // commented because the FBA can get the option from settings and here it isn\'t yet loaded\r\n        // w/o the if some additional changes will be seen in state, but they aren\'t used because of the other if in render()\r\n        // if (AppMetaTempGlobals.appMetaInstance.enableModalRoutes()) {\r\n        this.onLocationChanged = this.onLocationChanged.bind(this);\r\n        // CS: I tried w/ props.location; I saw this field working in other places; but here not; for lack of time I turned to ...TempGlobals\r\n        if (AppMetaTempGlobals.appMetaInstance.canCallOnLocationChangedFromAppContainerConstructor()) {\r\n            this.onLocationChanged(AppMetaTempGlobals.history.location);\r\n        }\r\n        // we forgot this initially; and we had issues during test, because multiple instances would continue to listen\r\n        this.onLocationChangedUnregisterCallback = AppMetaTempGlobals.history.listen(this.onLocationChanged)\r\n        // }\r\n\r\n        this.renderOrganizationTreeItem = this.renderOrganizationTreeItem.bind(this);\r\n        this.renderOrganizationTree = this.renderOrganizationTree.bind(this);\r\n    }\r\n    \r\n    componentWillUnmount(): void {\r\n        this.onLocationChangedUnregisterCallback();\r\n    }\r\n\r\n    componentDidUpdate(prevProps: AppContainerProps) {\r\n        this.componentDidUpdateInternal(prevProps);\r\n    }\r\n\r\n    componentDidUpdateInternal(prevProps?: AppContainerProps) {\r\n        if (AppMetaTempGlobals.appMetaInstance.showSearchBarOnTitleBar && (!prevProps || prevProps.drawerOpen !== this.props.drawerOpen) && !this.props.drawerOpen) {\r\n            this.props.dispatchers.setInReduxState({ searchBarHasFocus: false });\r\n            this.refTreeMenu.current!.modifySearchExpression("");\r\n        }\r\n        if (!prevProps || prevProps.currentOrganizationToFilterBy !== this.props.currentOrganizationToFilterBy) {\r\n            // select in tree\r\n            var currentItem = this.props.currentOrganizationToFilterBy;\r\n            let itemID = currentItem ? undefined : SliceOrganizationTree.ORGANIZATION_TREE_ROOT_ID;\r\n            while (currentItem) {\r\n                itemID = currentItem.id + (itemID ? Utils.defaultIdSeparator + itemID : "");\r\n                currentItem = global.organizations?.find(p => p.id === currentItem?.parent?.id);\r\n            }\r\n            if (itemID !== undefined && this.props.dispatchers.organizationsTree.getState().selectedId !== itemID) {\r\n                this.props.dispatchers.organizationsTree.reveal({ ids: [itemID], collapseOthers: false, expandIds: true });\r\n                this.props.dispatchers.organizationsTree.selectItem(itemID);\r\n            }\r\n            // store in session\r\n            window.sessionStorage.setItem(sessionGlobalCurrentOrganizationToFilterBy, this.props.currentOrganizationToFilterBy?.id || "");\r\n        }\r\n        if (!this.props.currentOrganizationToFilterBy && this.props.currentOrganization && this.props.organizationsTree.root?.children?.length === 1) {\r\n            global.currentOrganizationToFilterBy = this.props.currentOrganization;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * In some cases there is no entityDescriptor for routeEntityName (e.g. CurrentUser).\r\n     * This method can be overwritten when necessary.\r\n     */\r\n    public createLocationFromRouteEntityName(routeEntityName: string) {\r\n        /**\r\n          * Suntem aici pt ca s-a cerut ruta de editor direct in browser. Deci a comandat si "pe fundal"\r\n          * tabelul. Noi tr sa transmitem in state-ul rutei treaba asta. Pentru ca tabelul cand isi face logica\r\n          * de redirect (atat redirectul imediat cat si cel in urma sosirii dashb) sa transmita la randul lui\r\n          * in acea "location" catre care se face redirect o info supl: dontCloseDrawer. Care o vom trata aici. In cazul de fata in \r\n          * background. Mai precis informatia e "ba, mergi pe ruta asta in slotul de tabel si LASA editorul ON"\r\n          */\r\n        return createLocation(entityDescriptors[routeEntityName].getEntityTableUrl(), { dontCloseDrawer: true });\r\n    }\r\n\r\n    protected onLocationChanged(location: Location<any>) {\r\n        const props = this.props;\r\n        let foundRoute: Optional<ReactElement> = undefined;\r\n        for (const child of React.Children.toArray(AppMetaTempGlobals.appMetaInstance.routes)) {\r\n            const route: ReactElement = child as any;\r\n            if (!route.props.path) {\r\n                throw new Error("Current element doesn\'t seem to be a <Route .../>: " + Utils.consoleLogJson(route));\r\n            }\r\n            if (matchPath(location.pathname, route.props)) {\r\n                foundRoute = route;\r\n                break;\r\n            }\r\n        }\r\n        if (foundRoute?.props["routeIsModal"]) {\r\n            if (foundRoute.props["routeEntityName"]\r\n                // e.g. A) displaying as main the table page for employees; and I want to display the editor for THAT entity type \r\n                && (foundRoute.props["routeEntityName"] === props.dispatchers.getState().locationForMainRouteEntityName\r\n                    // B) or the initial display of an editor\r\n                    || !props.dispatchers.getState().locationForMain)) {\r\n                // => show it as drawer\r\n                const newState: Partial<PropsFrom<typeof sliceAppContainer>> = { locationForDrawer: location, locationsForModals: [] /* cancel any other modals, if they exist */ };\r\n\r\n                if (!props.dispatchers.getState().locationForMain) {\r\n                    // B) locationForMain not def => entered on our site directly w/ an editor URL\r\n                    // in this case, let\'s also open "underneath" the corresponding table page\r\n                    const routeEntityName = foundRoute.props["routeEntityName"];\r\n                    newState.locationForMain = this.createLocationFromRouteEntityName(routeEntityName);\r\n                    newState.locationForMainRouteEntityName = routeEntityName;\r\n                }\r\n                props.dispatchers.setInReduxState(newState);\r\n            } else {\r\n                // a normal (non-editor) modal, or a editor modal and: 1) main is not a table page or 2) is a table page, but for another entity\r\n                // so add a new modal in the stack\r\n\r\n                // DISCUSSION: the feature was intended to allow a stack of modals; however w/o a lot of effort and checks, this is the case "better is the enemy of good"\r\n                // #1 Conceptually. Should we check to see if route.pathname of last modal == crt one? However, in practice, is difficult to reproduce. Should have a link from own editor in editor.\r\n                // #2 The above case has a more pragmatic side effect: 2 slices w/ same name. Possible solution: per route in stack, specify the entityName. BUT we may also\r\n                // have the case of normal modal; w/o entity, but w/ a connected component. In this case => same error\r\n                // SO for the moment, the stacking is disabled, and we allow only one modal\r\n                props.dispatchers.setInReduxState({ locationsForModals: [/*...props.dispatchers.getState().locationsForModals,*/ location] });\r\n            }\r\n        } else {\r\n            // dontCloseDrawer = true => entered on our site directly w/ an editor URL, \r\n            // we need to keep main open on background BUT also display the drawer + the route must point to the drawer location\r\n            const dontCloseDrower = location.state?.dontCloseDrawer && props.dispatchers.getState().locationForDrawer;\r\n            props.dispatchers.setInReduxState({\r\n                locationForMain: location,\r\n                locationForMainRouteEntityName: foundRoute?.props["routeEntityName"],\r\n                locationForDrawer: dontCloseDrower ? props.dispatchers.getState().locationForDrawer : undefined,\r\n                locationsForModals: []\r\n            });\r\n            if (dontCloseDrower) {\r\n                props.dispatchers.dispatch(push({ pathname: props.dispatchers.getState().locationForDrawer!.pathname, state: props.dispatchers.getState().locationForDrawer?.state }));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Meant to be overriden\r\n     */\r\n    renderAdditionalContent(): JSX.Element | null {\r\n        return null;\r\n    }\r\n\r\n    protected getHeaderClassName() {\r\n        return "";\r\n    }\r\n\r\n    renderLocationsModals(props: any) {\r\n        return <>{props.locationsForModals.map((location: any) => (<ModalExt open={true} closeOnDimmerClick={true} closeIcon={true}\r\n            onClose={() => { props.dispatchers.setInReduxState({ locationsForModals: props.locationsForModals.slice(0, -1) }) }}>\r\n            <Modal.Content className="AppModal_content">\r\n                <Switch location={location}>\r\n                    {AppMetaTempGlobals.appMetaInstance.routes}\r\n                </Switch>\r\n            </Modal.Content>\r\n        </ModalExt>))}</>\r\n    }\r\n\r\n    protected renderOrganizationTreeItem({ props, linearizedItem }: RenderItemParams) {\r\n        const currentOrg = this.props.initializationsForClient.currentOrganization;\r\n        const itemId = Utils.substringAfter(linearizedItem.itemId, Utils.defaultIdSeparator, true);\r\n        const object = itemId === SliceOrganizationTree.ORGANIZATION_TREE_ROOT_ID ? props.root : global.organizations?.find(o => "" + o.id === itemId) as Organization;\r\n        const label = itemId === SliceOrganizationTree.ORGANIZATION_TREE_ROOT_ID ? (currentOrg ? currentOrg.name : _msg("general.all")) : object?.name;\r\n        return <div className="flex-container flex-center">\r\n            {AppMetaTempGlobals.appMetaInstance.getOrganizationTreeIcon(itemId, object, currentOrg)}\r\n            <span className="OrganizationTreeLeftArea_text">\r\n                {label}\r\n            </span>\r\n\r\n        </div>;\r\n    }\r\n\r\n    private getOrganizationTreeItemStyleProps({ props, linearizedItem }: RenderItemParams) {\r\n        const ids = linearizedItem.itemId.split(Utils.defaultIdSeparator);\r\n        const style = {};\r\n        Object.assign(style, {\r\n            marginLeft: ids.length > 1 ? (ids.length - 1) * 10 + "px" : undefined,\r\n            backgroundColor: \'rgba(255, 255, 255, 0.25)\',\r\n            flexDirection: "column", borderRadius: \'2px 0px 0px 2px\',\r\n            marginBottom: "1px", padding: \'4px\', fontSize: \'7pt\'\r\n        });\r\n        if (linearizedItem.expanded === Expanded.EXPANDED) {\r\n            Object.assign(style, {\r\n                backgroundColor: \'rgba(255, 255, 255, 0.5)\'\r\n            });\r\n        }\r\n        return style;\r\n    }\r\n\r\n    protected renderOrganizationTree() {\r\n        const { props } = this;\r\n        return <div className="flex-container OrganizationTreeLeftArea" style={{ overflowX: "hidden" }}>\r\n            <Tree {...props.organizationsTree} dispatchers={props.dispatchers.organizationsTree}\r\n                renderItemFunction={this.renderOrganizationTreeItem}\r\n                styleItemWrapperFunction={this.getOrganizationTreeItemStyleProps}\r\n                onSelectItem={(params: OnSelectParams) => {\r\n                    const itemId = Utils.substringAfter(params.itemId, Utils.defaultIdSeparator, true);\r\n                    if (itemId === SliceOrganizationTree.ORGANIZATION_TREE_ROOT_ID) {\r\n                        global.currentOrganizationToFilterBy = null;\r\n                    } else {\r\n                        global.currentOrganizationToFilterBy = global.organizations!.filter(o => "" + o.id === itemId)?.[0];\r\n                    }\r\n\r\n                }} />\r\n        </div>\r\n    }\r\n\r\n    protected renderHeaderLogo(settings: VisualStyleSettings) {\r\n        let headerLogoStyle = settings.whiteBackgroundHeaderLogo ? " HomePage_headerLogo_whiteBackground HomePage_headerLogo_image" : "";\r\n        return AppMetaTempGlobals.appMetaInstance.showHeaderLogo\r\n            ? (settings.headerLogo ?\r\n                (<Menu.Item className={"AppHelper_menu less-padding" + headerLogoStyle} header as={Link} to="/"><img src={Utils.adjustUrlToServerContext(settings.headerLogo)} alt=\'headerLogo\' /></Menu.Item>) :\r\n                (<Menu.Item header as={Link} to="/"><Header as="h4">{AppMetaTempGlobals.appMetaInstance.getAppTitle(settings)}</Header></Menu.Item>))\r\n            : null;\r\n    }\r\n\r\n    protected renderHomeButton() {\r\n        return <Menu.Item icon="home" as={Link} to="/" />;\r\n    }\r\n\r\n    render() {\r\n        return <>\r\n            <Dimmer data-testid="AppMeta_dimmer" active={this.props.showSpinner} page={true}><Loader size=\'large\'>\r\n                <Header as="h3" inverted>{this.props.spinnerText ? this.props.spinnerText : _msg("general.loading")}</Header>\r\n                {this.props.showSpinnerCloseButton\r\n                    ? <>\r\n                        <Button data-testid={"spinner-close"} negative size="tiny" icon="delete" onClick={() => this.props.dispatchers.setInReduxState({ spinnerCloseConfirmationModalOpen: true })} />\r\n                        <ModalExt size="mini" open={this.props.spinnerCloseConfirmationModalOpen} closeIcon={true} onClose={() => this.props.dispatchers.setInReduxState({ spinnerCloseConfirmationModalOpen: false })}>\r\n                            <Modal.Content>{_msg("AppHelper.abortGraphQLConfirmation")}</Modal.Content>\r\n                            <Modal.Actions>\r\n                                <Button data-testid={"spinner-abort-yes"} onClick={() => this.props.dispatchers.setInReduxState({ spinnerCloseConfirmationModalOpen: false, showSpinner: false })}>{_msg("general.yes")}</Button>\r\n                                <Button data-testid={"spinner-abort-no"} onClick={() => this.props.dispatchers.setInReduxState({ spinnerCloseConfirmationModalOpen: false })}>{_msg("general.no")}</Button>\r\n                            </Modal.Actions>\r\n                        </ModalExt>\r\n                    </>\r\n                    : null}\r\n            </Loader></Dimmer>\r\n            {this.renderMain()}\r\n        </>\r\n    }\r\n\r\n    renderMain() {\r\n        const props = this.props;\r\n        let alert: Optional<ReactElement> = undefined;\r\n        if (props.globalAlertMessage) {\r\n            if (props.globalAlertShownAsMessage) {\r\n                alert = <Redirect to={{ pathname: \'/error\', state: { headerMessage: props.globalAlertTitle, errorMessage: props.globalAlertMessage } }} />\r\n            } else {\r\n                alert = <ModalExt severity={props.globalAlertSeverity}\r\n                    open={props.globalAlertMessage !== undefined}\r\n                    onClose={() => props.dispatchers.setInReduxState({ globalAlertMessage: undefined })}>\r\n                    <Modal.Header data-testid="AppMeta_globalAlertHeader"><Interweave content={props.globalAlertTitle ? props.globalAlertTitle : _msg("general.info")} /></Modal.Header>\r\n                    <Modal.Content>\r\n                        <Modal.Description data-testid="AppMeta_globalAlertContent">\r\n                            {/* {props.globalAlertMessage.split("\\n").map((item, i) => { return <p key={i}>{item}</p> })} */}\r\n                            <Interweave content={props.globalAlertMessage} />\r\n                        </Modal.Description>\r\n                    </Modal.Content>\r\n                    <Modal.Actions>\r\n                        <Button data-testid="AppMeta_globalAlertOk" onClick={() => props.dispatchers.showGlobalAlert({ message: undefined })} primary>{_msg("general.ok")}</Button>\r\n                    </Modal.Actions>\r\n                </ModalExt>\r\n            }\r\n        }\r\n        if (!props.initializationsForClientLoaded) {\r\n            return (<div className="HomePage" data-testid="AppMeta_spinner">\r\n                {props.avoidDisplayingInitializationsLoadingSpinner ? null :\r\n                    <Container>\r\n                        <Message floating>\r\n                            <Header as="h4" color="grey" textAlign="center" icon>\r\n                                <Icon name=\'spinner\' loading />\r\n                                <Header.Content>{_msg("AppHelper.loadingInitializationsForClient")}</Header.Content>\r\n                            </Header>\r\n                        </Message>\r\n                    </Container>}\r\n                {alert}\r\n                {this.renderAdditionalContent()}\r\n            </div>);\r\n        }\r\n\r\n        let left: ReactNode;\r\n        let right: ReactNode;\r\n\r\n        // TODO by CS: ? for prot, which doesn\'t have visualStyleSettings for the moment; remove when the case will be\r\n        const appTitle = props.initializationsForClient.visualStyleSettings?.appTitle;\r\n\r\n        const user = props.initializationsForClient.currentUser;\r\n        const specialPageWithoutHeader = AppMetaTempGlobals.appMetaInstance.getIsSpecialPageWithoutHeader();\r\n        if (user && !specialPageWithoutHeader) {\r\n            const organization = props.initializationsForClient.currentOrganization;\r\n            const allOrganizationsAccess = props.initializationsForClient.allOrganizationsAccess;\r\n            const settings = props.initializationsForClient.visualStyleSettings;\r\n            let headerLogo: string | undefined = undefined;\r\n            let headerLogoRight: boolean | undefined = undefined;\r\n            let clientHeaderLogo: string | undefined = undefined;\r\n            let clientHeaderLogoStyle: string | undefined = undefined;\r\n            if (settings) {\r\n                headerLogo = settings.headerLogo;\r\n                headerLogoRight = settings.headerLogoRight;\r\n                clientHeaderLogo = settings.clientHeaderLogo;\r\n                clientHeaderLogoStyle = settings.whiteBackgroundClientHeaderLogo ? " HomePage_headerLogo_whiteBackground HomePage_headerLogo_image" : "";\r\n            }\r\n            left = (<Menu key="left">\r\n                {AppMetaTempGlobals.appMetaInstance.showBackButton ? (<Menu.Item key="back" icon="arrow left" onClick={() => AppMetaTempGlobals.appMetaInstance.goBack()} />) : null}\r\n                {AppMetaTempGlobals.appMetaInstance.showReloadButton ? (<Menu.Item key="reload" icon="redo" onClick={() => { window.sessionStorage.setItem(sessionGlobalReload, "true"); window.location.reload()} } />) : null}\r\n                {!headerLogoRight ? this.renderHeaderLogo(settings) : null}\r\n                {AppMetaTempGlobals.appMetaInstance.showHeaderLogo && clientHeaderLogo ? (<Menu.Item key="clientHeaderLogo" className={"AppHelper_menu less-padding" + clientHeaderLogoStyle} header as={Link} to="/"><img className="margin-auto" src={Utils.adjustUrlToServerContext(clientHeaderLogo)} alt=\'clientHeaderLogo\' /></Menu.Item>) : null}\r\n                {/* If the logo is on the left, show home button first. Else, show menu button first.  */}\r\n                {AppMetaTempGlobals.appMetaInstance.showHomeButton && !headerLogoRight ? this.renderHomeButton() : null}\r\n                <Menu.Item key="menu" icon="grid layout" as="a" onClick={() => this.props.dispatchers.setInReduxState({ drawerOpen: true })} />\r\n                {AppMetaTempGlobals.appMetaInstance.showHomeButton && headerLogoRight ? this.renderHomeButton() : null}\r\n            </Menu>);\r\n\r\n            const myAccountMenuEntry: any[] = [];\r\n            if (AppMetaTempGlobals.appMetaInstance.showMyAccountMenuEntry) {\r\n                myAccountMenuEntry.push({ key: \'myAccount\', text: _msg("login.myAccount"), icon: \'user\', onClick: () => this.props.dispatchers.setInReduxState({ currentUserModalOpen: true }) });\r\n            }\r\n            right = (<Menu key="right">\r\n                {AppMetaTempGlobals.appMetaInstance.showClock ? <span className=\'item very-small-padding\'><Clock format={Utils.timeWithSecFormat} /></span> : null}\r\n                {AppMetaTempGlobals.appMetaInstance.showTimeZone ?\r\n                    <span data-tooltip={moment.tz.guess()} data-position="left center">\r\n                        <span className=\'item\'>{"GMT" + (Utils.LOCAL_TIMEZONE_OFFSET === 0 ? "" : (Utils.LOCAL_TIMEZONE_OFFSET > 0 ? "+" : "") + Utils.LOCAL_TIMEZONE_OFFSET.toString())}</span>\r\n                    </span>\r\n                    : null}\r\n                {AppMetaTempGlobals.appMetaInstance.showNotifications ?\r\n                    <NotificationComponent {...props.notificationComponent} dispatchers={props.dispatchers.notificationComponent} />\r\n                    : null}\r\n                {AppMetaTempGlobals.appMetaInstance.showOrganization ?\r\n                    <span data-tooltip={_msg("Organization.currentOrganization")} data-position="left center">\r\n                        <OrganizationManyToOneEditorStandalone value={organization} userId={user ? user.id : undefined} allOrganizationsAccess={allOrganizationsAccess} onChange={async (o: any) => {\r\n                            const mutation = gql(`mutation q ($organization: String) {\r\n                                authService_setOrganization(organization: $organization)\r\n                            }`);\r\n                            await apolloClient.mutate({ mutation: mutation, variables: { organization: o ? o.qualifiedName : null } });\r\n                            \r\n                            this.props.onSoftReload();\r\n                        }} />\r\n                    </span>\r\n                    : null}\r\n                <Dropdown pointing="top right" className=\'link item less-padding\' trigger={AppMetaTempGlobals.appMetaInstance.getUserInfo(user)} options={[\r\n                    {\r\n                        key: \'user\',\r\n                        text: (\r\n                            <span>\r\n                                {_msg("login.signedInAs", user?.firstName || user?.lastName ? user?.lastName + " " + user?.firstName : user?.username)}\r\n                            </span>\r\n                        ),\r\n                        disabled: true,\r\n                    },\r\n                    ...AppMetaTempGlobals.appMetaInstance.getAdditionalUserHeaderEntries(),\r\n                    ...myAccountMenuEntry,\r\n                    ...AppMetaTempGlobals.appMetaInstance.getAdditionalUserMenuEntries(),\r\n                    { key: \'log-out\', text: _msg("login.logout"), icon: \'log out\', onClick: e => AppMetaTempGlobals.appMetaInstance.logout() }\r\n                ]}\r\n                />\r\n                {AppMetaTempGlobals.appMetaInstance.getAdditionalItemsForRightMenu()}\r\n                {headerLogoRight ? this.renderHeaderLogo(settings) : null}\r\n            </Menu>);\r\n        }\r\n        const headerClassName = this.getHeaderClassName();\r\n        return (<>\r\n            <ContainerWithHeader childTitleAreaLeft={left} childTitleAreaRight={right} titleAreaClassName={AppMetaTempGlobals.appMetaInstance.showSearchBarOnTitleBar ? "flex-justify-content-center" : undefined}\r\n                displayChildrenInRow={props.initializationsForClient.currentUser !== undefined && props.initializationsForClient.organizationSettings?.globalOrganizationFilter === OrganizationFilter.LEFT_SIDE}\r\n                headerClassName={headerClassName}>\r\n                {AppMetaTempGlobals.appMetaInstance.showHorizontalMenu && user && !specialPageWithoutHeader ?\r\n                    <ContainerWithHeaderContext.Consumer>\r\n                        {value => {\r\n                            if (value.titleAreaDiv) {\r\n                                value.titleAreaDivAlreadyFilledIn = true;\r\n                                return ReactDOM.createPortal(React.createElement(HorizontalMenu, {\r\n                                    menuEntries: AppMetaTempGlobals.appMetaInstance.menuEntries\r\n                                }), value.titleAreaDiv);\r\n                            }\r\n                            else { return null; }\r\n                        }}\r\n                    </ContainerWithHeaderContext.Consumer> : null}\r\n                {AppMetaTempGlobals.appMetaInstance.showSearchBarOnTitleBar && user && !specialPageWithoutHeader ?\r\n                    <ContainerWithHeaderContext.Consumer>\r\n                        {value => {\r\n                            if (value.titleAreaDiv) {\r\n                                value.titleAreaDivAlreadyFilledIn = true;\r\n                                return ReactDOM.createPortal(<WrapperWithRenderFunction ref={this.refTreeMenuSearchWrapper} render={() =>\r\n                                    <TreeMenuSearch value={this.refTreeMenu.current?.getSearchExpression()}\r\n                                        style={{ maxWidth: \'350px\', width: \'100%\' }} focus={this.props.searchBarHasFocus}\r\n                                        onChange={(value: any) => this.refTreeMenu.current?.modifySearchExpression(value)}\r\n                                        onFocus={(value: any) => this.props.dispatchers.setInReduxState({ searchBarHasFocus: value, drawerOpen: value })}\r\n                                    />} />, value.titleAreaDiv);\r\n                            }\r\n                            else { return null; }\r\n                        }}\r\n                    </ContainerWithHeaderContext.Consumer> : null}\r\n                <Drawer destroyOnClose className="AppDrawer"\r\n                    title={<div className="flex-container">{appTitle}{AppMetaTempGlobals.appMetaInstance.getVersionInfo(this.props.initializationsForClient.version)}</div>} placement="left" visible={this.props.drawerOpen} mask={!this.props.searchBarHasFocus}\r\n                    onClose={() => this.props.dispatchers.setInReduxState({ drawerOpen: false })}\r\n                    afterVisibleChange={visible => !visible}>\r\n                    <TreeMenuRRC id="treeMenu" ref={this.refTreeMenu} root={AppMetaTempGlobals.appMetaInstance.menuEntries}\r\n                        showSearchBar={!this.props.searchBarHasFocus} multiSearch={true}\r\n                        onMenuItemClick={(isComposed: any) => !isComposed && this.props.dispatchers.setInReduxState({ drawerOpen: false })}\r\n                        onSearchExpressionModified={() => this.refTreeMenuSearchWrapper.current?.forceUpdate()} initialExpandedIds={AppMetaTempGlobals.appMetaInstance.menuInitialExpandedIds} />\r\n                </Drawer>\r\n                {props.initializationsForClient.currentUser && props.initializationsForClient.organizationSettings?.globalOrganizationFilter === OrganizationFilter.LEFT_SIDE\r\n                    && props.organizationsTree.root && !(props.organizationsTree.root.children?.length == 1 && Utils.isNullOrEmpty(props.organizationsTree.root.children[0].children)) ? this.renderOrganizationTree() : null}\r\n                <Suspense fallback={<div>Loading...</div>} >\r\n                    {AppMetaTempGlobals.appMetaInstance.enableModalRoutes()\r\n                        ? <>\r\n                            {props.locationForMain && <Switch location={props.locationForMain}>\r\n                                {AppMetaTempGlobals.appMetaInstance.routes}\r\n                            </Switch>}\r\n                            {props.locationForDrawer && <Drawer className="RouteDrawer" visible width={"80%"} closeIcon={<Button data-testid="Drawer_closeBtn" className="less-padding" icon="close" circular />}\r\n                                onClose={() => {\r\n                                    props.dispatchers.setInReduxState({ locationForDrawer: undefined });\r\n                                    props.locationForMain && props.dispatchers.dispatch(push(props.locationForMain?.pathname));\r\n                                }}>\r\n                                <Switch location={props.locationForDrawer}>\r\n                                    {AppMetaTempGlobals.appMetaInstance.routes}\r\n                                </Switch>\r\n                            </Drawer>}\r\n                            {this.renderLocationsModals(props)}\r\n                        </>\r\n                        : <Switch>\r\n                            {AppMetaTempGlobals.appMetaInstance.routes}\r\n                        </Switch>\r\n                    }\r\n                </Suspense>\r\n                {alert}\r\n                {this.renderAdditionalContent()}\r\n            </ContainerWithHeader>\r\n            <ModalExt open={props.currentUserModalOpen} onClose={() => props.dispatchers.setInReduxState({ currentUserModalOpen: false })}>\r\n                <Modal.Header>{_msg("login.myAccount")}</Modal.Header>\r\n                <Modal.Content><ConnectedComponentInSimpleComponent info={infoCurrentUserEditorPage} closeModal={() => props.dispatchers.setInReduxState({ currentUserModalOpen: false })} /></Modal.Content>\r\n            </ModalExt>\r\n        </>);\r\n    }\r\n}\r\n\r\nexport const APP_CONTAINER = "AppContainer";\r\nexport const infoAppContainer = new ConnectedPageInfo(sliceAppContainer, AppContainer, APP_CONTAINER);',path:"foundation-react/src/foundation-react/AppMeta.tsx"},s={},l=void 0,p={id:"foundation-react/ClientErrorLogger/Instructions for devs",title:"Instructions for devs",description:'The "client error logger" feature is enabled by default. In order to disable it, one should override this function:',source:"@site/docs/foundation-react/ClientErrorLogger/Instructions for devs.md",sourceDirName:"foundation-react/ClientErrorLogger",slug:"/foundation-react/ClientErrorLogger/Instructions for devs",permalink:"/docusaurus/docs/foundation-react/ClientErrorLogger/Instructions for devs",draft:!1,unlisted:!1,editUrl:"https://gitlab.xops-online.com/foundation/foundation-jhipster-gwt/-/blob/master/docusaurus/docs/foundation-react/ClientErrorLogger/Instructions for devs.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"ClientErrorLogger",permalink:"/docusaurus/docs/foundation-react/ClientErrorLogger/"},next:{title:"Featurebook",permalink:"/docusaurus/docs/foundation-react/DatePicker _not finished_/Featurebook"}},d={},c=[];function u(e){const n={p:"p",...(0,o.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:'The "client error logger" feature is enabled by default. In order to disable it, one should override this function:'}),"\n",(0,t.jsx)(i.M_,{src:a,region:"client-error-logger-start"})]})}function m(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},93598:(e,n,r)=>{"use strict";r.d(n,{sS:()=>c,Tm:()=>u,M_:()=>m,Fb:()=>g,JR:()=>h,lj:()=>p,h8:()=>d});r(67294);class t{static now(){return new Date}static consoleLogJson(e,n){void 0===n&&(n=!0);const r=JSON.stringify(e,(()=>{const e=new WeakSet;return(n,r)=>{if(!n.startsWith("__react")){if("object"==typeof r&&null!==r){if(e.has(r))return;e.add(r)}return r}}})(),2);return n&&console.log(r),r}static substringAfter(e,n,r){const t=r?e.lastIndexOf(n):e.indexOf(n);return t<0?e:e.substring(t+n.length)}static setTimeoutPromise(e,n){return new Promise((r=>setTimeout((()=>{const n=e?.();r(n)}),n)))}}var o=r(9286),i=r(25142),a=r(28014),s=r(91262),l=r(85893);const p=e=>{return(0,l.jsx)(l.Fragment,{children:(0,l.jsxs)("a",{target:"_blank",href:(n=e.children,(n.startsWith("foundation/")?"https://gitlab.xops-online.com/foundation/foundation/-/tree/main/"+t.substringAfter(n,"foundation/"):"https://gitlab.xops-online.com/foundation/foundation-jhipster-gwt/-/tree/master/"+n)+(e.lineNumbers?.[0]?`#L${e.lineNumbers[0]}`:"")+(e.lineNumbers?.[1]?`-L${e.lineNumbers[1]}`:"")),children:[t.substringAfter(e.children,"/",!0),e.region&&(0,l.jsxs)("small",{children:["\xa0",(0,l.jsxs)("i",{children:["(region ",e.region,",\xa0",e.lineNumbers[0]===e.lineNumbers[1]?(0,l.jsxs)(l.Fragment,{children:["at line ",e.lineNumbers[0]]}):(0,l.jsxs)(l.Fragment,{children:["between lines [",e.lineNumbers[0],", ",e.lineNumbers[1],"])"]})]})]})]})});var n},d=e=>(0,l.jsx)(i.Z,{circular:!0,color:"blue",children:e.s}),c=e=>{let{src:{text:n,path:r},region:t,...i}=e;const a=new RegExp(`#region\\s*${t}[^\\r\\n]*\\r?\\n(.*?)#endregion`,"s").exec(n);if(!a)throw new Error(`In file = ${r}, cannot find region = ${t}, i.e. a portion like:\n\n#region ${t}\n...\n#endregion`);let s,d=1,c=-1;for(s=0;s<a.index+a[0].length;s++)"\n"===n[s]&&d++,-1===c&&s>=a.index&&(c=d);c++,d--;let u=a[1];u=/(.*)(\r?\n.*?$)/gs.exec(u)[1],u="\n"+u;const m=u.match(/\n(\s)*\S/);let g;if(m&&(g=m[1])){const e=new RegExp(`\\n(${g}*)\\S`,"g");let n,r=-1;for(;null!==(n=e.exec(u));)(r<0||r>n[1].length)&&(r=n[1].length);const t=g.repeat(r);u=u.replace(new RegExp("\\n"+t,"g"),"\n")}return u=u.substring(1),(0,l.jsx)(l.Fragment,{children:(0,l.jsx)(o.Z,{title:(0,l.jsxs)(l.Fragment,{children:["Snippet extracted from ",(0,l.jsx)(p,{region:t,lineNumbers:[c,d],children:r})]}),...i,children:u})})},u=e=>(0,l.jsx)(c,{language:"java",...e}),m=e=>(0,l.jsx)(c,{language:"ts",...e}),g=e=>(0,l.jsx)(s.Z,{children:()=>(0,l.jsx)(a.J6,{recordedTestsUrl:"https://gitlab.xops-online.com/foundation/foundation-jhipster-gwt/-/raw/master/leave-management/leave-management-react/public/recordedTests/recordedTest.json",includeCredentialsInJsonRequestRegex:/https:\/\/gitlab\.xops-online\.com\/*/,...e})}),h=e=>(0,l.jsx)(s.Z,{children:()=>(0,l.jsx)(a.J6,{recordedTestsUrl:"https://gitlab.xops-online.com/foundation/foundation-jhipster-gwt/-/raw/master/leave-management/leave-management-react/public/recordedTestsServer/recordedTest.json",includeCredentialsInJsonRequestRegex:/https:\/\/gitlab\.xops-online\.com\/*/,...e})})},13411:e=>{function n(e){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}n.keys=()=>[],n.resolve=n,n.id=13411,e.exports=n},24654:()=>{},62183:()=>{},13024:()=>{},62715:()=>{},13611:()=>{},28353:()=>{},1210:()=>{},43454:()=>{}}]);