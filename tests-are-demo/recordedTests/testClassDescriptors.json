[{"name":"EmployeeDashboardTestsAreDemo","functions":[{"functionName":"render","scenario":"RENDERER for an overview of the employees","comments":["\n This is a typedoc **comment** w/ `Markdown` formatting.\n \n ```js\n // some code\n console.log(\"something\");\n ```\n     "]},{"functionName":"whenClickNewHoliday","scenario":"WHEN click on 'New holiday', THEN the Holiday form opens, AND some data is prefilled based on the current logged in user","comments":["\n        This is a comment that has multiple lines. Each line from the code\n        is rendered as a new line in the UI. The goal is to try to have a similar/familiar\n        layout between the file/code and what's rendered in the browser.\n\n        Empty new lines are also permitted. But not the trailing ones (start or end), like the one below.\n\n    ","Here we have multiple comments. This is the first.","Second.","Third and last."]}],"hooks":[],"comments":["This is a fictional test, used to demonstrate various details of the existing annotations","@Comment is a decorator meant for TestAreDemo classes and its functions (scenarios).\nWe also call these decorators: annotations, like in Java. And they exist also in Java. We tried\nto make them as similar as possible (the TypeScript variants vs the Java variants)."]},{"name":"EmployeeDashboardNoDecoratorsTestsAreDemo","functions":[{"functionName":"whenClickBroadcastNotification","scenario":"WHEN click on 'Brodcast message', THEN a popup with textbox opens, AND WHEN message is written and 'Send' is clicked, THEN an email is sent to all employees","comments":[]},{"functionName":"whenSomething","scenario":"WHEN something, THEN something else","comments":["Multiple comments are supported as well.","The suffix after 'annotation' is not important. Probably the simplest solution is to name them 'annotation1', 'annotation2', etc."]}],"hooks":[],"comments":["\n            If your project doesn't support TypeScript decorators, we offer a fallback solution, which we name \"pseudo\" annotations.\n\n            Add functions that named \"annotation...\". If the name is just \"annotation\", then we consider it as being associated to the class.\n            Otherwise, e.g. \"annotation1\", we consider it as being associated with the next function.\n\n            Within such a \"pseudo\" annotation function, we expect you to invoke directly the annotation functions / decorators. We built them\n            in such a way to support this dual working mode.\n        "]},{"name":"StackTraceLogTestsAreDemo","functions":[{"functionName":"whenDecodeStackTrace","scenario":"","comments":[]}],"hooks":[]},{"name":"TodosTestsAreDemo","functions":[{"functionName":"screenTodos","scenario":"SCREEN Todos","comments":["Todos (func comp)"]},{"functionName":"whenCheckbox","scenario":"WHEN click on checkbox or label, THEN toggle 'done'","comments":["TodoItem (func comp)"]},{"functionName":"whenDoubleClick","scenario":"WHEN double click on a Todo, THEN the form opens","comments":[]},{"functionName":"whenDelete","scenario":"WHEN click on DELETE, THEN confirm, AND WHEN 'yes', THEN the Todo is removed","comments":["TodoItem again"]},{"functionName":"uiApiSampleScript","scenario":"","comments":[]}],"hooks":["before"]},{"name":"TodosTestsAreDemo.Group1","functions":[{"functionName":"whenAddThenForm","scenario":"WHEN click on Add, THEN the form opens","comments":[]},{"functionName":"formTodo1","scenario":"FORM for a Todo; test #1","comments":[]}],"hooks":[]},{"name":"TodosTestsAreDemo.Group2","functions":[{"functionName":"whenUp","scenario":"WHEN click on UP, THEN the Todo slides up","comments":[]},{"functionName":"whenDown","scenario":"WHEN click on DOWN, THEN the Todo slides down","comments":[]}],"hooks":[]},{"name":"TodosTestsAreDemo.Group3","functions":[{"functionName":"whenEditThenForm","scenario":"WHEN click on Edit, THEN the form opens","comments":[]},{"functionName":"formTodo2","scenario":"FORM for a Todo; test #2","comments":["TodoForm (func comp)"]}],"hooks":[]},{"name":"ReporterFromSlaveToMasterTestsAreDemo","functions":[{"functionName":"whenErrorCaught","scenario":"WHEN an error is caught by the reporter (containing a stack trace relative to the minified source being seen by the browser), THEN it is decoded (using source map) and printed to console, showing function names and line numbers relative to the original source code","comments":[]}],"hooks":["before","after"]},{"name":"SourceCodeTestsAreDemo","functions":[{"functionName":"whenSpotlightThenHighlight","scenario":"WHEN execution is halted (i.e. spotlight shown and waiting to press 'Next step', THEN the source code is shown, AND current line is highlighted","comments":[]},{"functionName":"whenSpotlightThenHighlight2","scenario":"WHEN clicked on 'Next step', AND the next line is pretty NEAR to the previous one, AND halted, THEN the new line is highlighted, AND no scroll is performed","comments":[]},{"functionName":"whenFarLineThenScrollAndHighlight","scenario":"WHEN clicked on 'Next step', AND next line is FAR from the previous one, AND halted, THEN highlight, AND scroll is performed so that the next line is visible","comments":[]},{"functionName":"whenOtherFile","scenario":"WHEN 'Next step', AND the new line is in a different file, AND halted, THEN a new source code is shown, AND highlight","comments":[]}],"hooks":["before","after"]}]