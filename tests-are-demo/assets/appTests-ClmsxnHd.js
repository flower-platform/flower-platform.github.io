var H=Object.defineProperty;var k=(o,t,i)=>t in o?H(o,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):o[t]=i;var c=(o,t)=>H(o,"name",{value:t,configurable:!0});var m=(o,t,i)=>(k(o,typeof t!="symbol"?t+"":t,i),i);import{T as N,t as a,e as b,f as y,c as v,d as D,s as f,g as _}from"./Todos-amZycUGP.js";import{O as u,S as r,P as I,j as w,C as q,Q as j,t as e,a as F,V as R}from"./semantic.min-DXYXs3Tn.js";const W=class W{annotation(){u(`
            If your project doesn't support TypeScript decorators, we offer a fallback solution, which we name "pseudo" annotations.

            Add functions that named "annotation...". If the name is just "annotation", then we consider it as being associated to the class.
            Otherwise, e.g. "annotation1", we consider it as being associated with the next function.

            Within such a "pseudo" annotation function, we expect you to invoke directly the annotation functions / decorators. We built them
            in such a way to support this dual working mode.
        `)}annotation1(){r("WHEN click on 'Brodcast message', THEN a popup with textbox opens, AND WHEN message is written and 'Send' is clicked, THEN an email is sent to all employees")}whenClickBroadcastNotification(){}annotation2(){u("The suffix after 'annotation' is not important. Probably the simplest solution is to name them 'annotation1', 'annotation2', etc."),u("Multiple comments are supported as well."),r("WHEN something, THEN something else")}whenSomething(){}};c(W,"EmployeeDashboardNoDecoratorsTestsAreDemo");let E=W;var U=Object.defineProperty,S=Object.getOwnPropertyDescriptor,C=c((o,t,i,s)=>{for(var n=s>1?void 0:s?S(t,i):t,h=o.length-1,p;h>=0;h--)(p=o[h])&&(n=(s?p(t,i,n):p(n))||n);return s&&n&&U(t,i,n),n},"__decorateClass$1");const B=c(o=>w.jsxs(q,{children:[w.jsx("p",{}),w.jsx(j,{info:!0,children:o.children})]}),"MessageInContainer");var T;let g=(T=class{constructor(){m(this,"demo",c(()=>()=>w.jsx(B,{children:"This test: 1/ is not applied on a particular component and 2/ it doesn't contain testing logic. It's used as a showcase for the annotation capabilities."}),"demo"));m(this,"demo1",c(()=>()=>w.jsx(B,{children:"Another demo component, with a name."}),"demo1"))}render(){}whenClickNewHoliday(){}},c(T,"EmployeeDashboardTestsAreDemo"),T);C([I()],g.prototype,"demo",2);C([I("Another demo component")],g.prototype,"demo1",2);C([r("RENDERER for an overview of the employees")],g.prototype,"render",1);C([u(`
        This is a comment that has multiple lines. Each line from the code
        is rendered as a new line in the UI. The goal is to try to have a similar/familiar
        layout between the file/code and what's rendered in the browser.

        Empty new lines are also permitted. But not the trailing ones (start or end), like the one below.

    `),u("Here we have multiple comments. This is the first."),u("Second."),u("Third and last."),r("WHEN click on 'New holiday', THEN the Holiday form opens, AND some data is prefilled based on the current logged in user")],g.prototype,"whenClickNewHoliday",1);g=C([u("This is a fictional test, used to demonstrate various details of the existing annotations"),u(`@Comment is a decorator meant for TestAreDemo classes and its functions (scenarios).
We also call these decorators: annotations, like in Java. And they exist also in Java. We tried
to make them as similar as possible (the TypeScript variants vs the Java variants).`)],g);var L=Object.defineProperty,P=Object.getOwnPropertyDescriptor,d=c((o,t,i,s)=>{for(var n=s>1?void 0:s?P(t,i):t,h=o.length-1,p;h>=0;h--)(p=o[h])&&(n=(s?p(t,i,n):p(n))||n);return s&&n&&L(t,i,n),n},"__decorateClass");const x=class x{constructor(){m(this,"demo",c(()=>()=>w.jsx(N,{}),"demo"));m(this,"whenUpItem")}_quickInstructions(){}async before(){await e.miniDb.clear().populate("Todo",1,3),F(w.jsx(N,{})),await e.waitForCommunicationFinished()}async whenScreenTodosShows(){let t=e.screenCapturing.getByTestId(a.todoItem+"_0");e.ref("THEN1"),await e.assertWaitable.include(t.className,e.miniDb.getDerived(b.Todo,1,y.Todo.priority,v)),e.ref("THEN2");let i=e.withinCapturing(t).getByTestId(a.todoItemCheckboxLabel);await e.assertWaitable.equal(i.textContent,e.miniDb.get(b.Todo,1,y.Todo.text)),e.ref("THEN3"),await e.assertWaitable.equal(i.style.textDecoration,e.miniDb.getDerived(b.Todo,1,y.Todo.done,"line-through")),e.ref("THEN4"),await e.assertWaitable.equal(e.withinCapturing(t).getByRole("checkbox").checked,e.miniDb.getDerived(b.Todo,1,y.Todo.done,!0)),e.demoForEndUserHide(),t=e.screenCapturing.getByTestId(a.todoItem+"_2"),e.ref("THEN5"),await e.assertWaitable.include(t.className,D),e.ref("THEN6"),i=e.withinCapturing(t).getByTestId(a.todoItemCheckboxLabel),await e.assertWaitable.equal(i.textContent,e.miniDb.get(b.Todo,3,y.Todo.text)),e.ref("THEN7"),await e.assertWaitable.notEqual(i.style.textDecoration,"line-through"),e.ref("THEN8"),await e.assertWaitable.isFalse(e.withinCapturing(t).getByRole("checkbox").checked),e.demoForEndUserShow(),e.ref("THEN9"),await e.assertWaitable.equal(e.screenCapturing.getByTestId(a.total).textContent,"6"),e.ref("THEN10"),await e.assertWaitable.equal(e.screenCapturing.getByTestId(a.totalLow).textContent,"1"),e.ref("THEN11"),await e.assertWaitable.equal(e.screenCapturing.getByTestId(a.totalNormal).textContent,"3"),e.ref("THEN12"),await e.assertWaitable.equal(e.screenCapturing.getByTestId(a.totalHigh).textContent,"2")}async andWhenButtonAddClicked(){e.ref("WHEN"),await e.userEventWaitable.click(e.screenCapturing.getByTestId(a.add)),e.ref("THEN"),await this.createNewTodo(),e.ref("THEN2");let t=e.screenCapturing.getByTestId(a.todoItem+"_6"),i=e.withinCapturing(t).getByTestId(a.todoItemCheckboxLabel);await e.assertWaitable.equal(i.textContent,"My task")}async createNewTodo(){const t=e.withinCapturing(e.screenCapturing.getByTestId(a.inputText)).getByRole("textbox");e.demoForEndUserHideNext(),e.ref("THEN1"),await e.assertWaitable.equal(document.activeElement,t),await this.anotherDummyHelperFunction(),await this.anotherDummyHelperFunction(),e.ref("WHEN2"),await e.userEventWaitable.type(t,"My task"),await e.userEventWaitable.click(e.screenCapturing.getByTestId(a.save))}async anotherDummyHelperFunction(){e.withinCapturing(e.screenCapturing.getByTestId(a.inputText)).getByRole("textbox"),await e.assertWaitable.isTrue(!0)}async andWhenCheckboxClicked(){let t=e.screenCapturing.getByTestId(a.todoItem+"_1"),i=e.withinCapturing(t).getByTestId(a.todoItemCheckboxLabel);e.ref("WHEN"),await e.userEventWaitable.click(i),e.ref("THEN1"),await e.assertWaitable.isTrue(e.withinCapturing(t).getByRole("checkbox").checked),e.demoForEndUserHide(),e.ref("WHEN2"),await e.userEventWaitable.click(i),e.ref("THEN2"),await e.assertWaitable.isFalse(e.withinCapturing(t).getByRole("checkbox").checked)}async whenButtonUpClicked(){e.ref("WHEN");let t=e.screenCapturing.getByTestId(a.todoItem+"_1");await e.userEventWaitable.click(e.withinCapturing(t).getByTestId(a.up)),t=e.screenCapturing.getByTestId(a.todoItem+"_0"),e.ref("THEN"),await e.assertWaitable.equal(e.withinCapturing(t).getByTestId(a.todoItemCheckboxLabel).textContent,"Repair the bike"),this.whenUpItem=t}async whenButtonDownClicked(){let t=this.whenUpItem;e.ref("WHEN"),await e.userEventWaitable.click(e.withinCapturing(t).getByTestId(a.down)),t=e.screenCapturing.getByTestId(a.todoItem+"_0"),e.ref("THEN"),await e.assertWaitable.equal(e.withinCapturing(t).getByTestId(a.todoItemCheckboxLabel).textContent,"Buy groceries for next week")}async whenDoubleClick(){e.demoForEndUserHide(),e.ref("WHEN"),await e.userEventWaitable.dblClick(e.screenCapturing.getByTestId(a.todoItem+"_1")),e.ref("THEN"),e.ref("WHEN2"),await e.userEventWaitable.click(e.screenCapturing.getByTestId(a.cancel)),e.ref("THEN2"),await e.assertWaitable.notExists(e.screenCapturing.queryByTestId(a.form))}async whenButtonEditClick(){e.ref("WHEN");let t=e.screenCapturing.getByTestId(a.todoItem+"_1");await e.userEventWaitable.click(e.withinCapturing(t).getByTestId(a.edit)),e.ref("THEN"),e.ref("WHEN1");const i=e.withinCapturing(e.screenCapturing.getByTestId(a.inputText)).getByRole("textbox");await e.userEventWaitable.type(i,"; some updates"),e.ref("WHEN2"),await e.userEventWaitable.click(e.screenCapturing.getByTestId(a.formCheckbox)),e.ref("WHEN3");const s=e.screenCapturing.getByTestId(a.formPriority);await e.userEventWaitable.click(e.withinCapturing(s).getByRole("button",{name:/low/i})),e.ref("WHEN4"),await e.userEventWaitable.click(e.screenCapturing.getByTestId(a.save)),t=e.screenCapturing.getByTestId(a.todoItem+"_1"),e.ref("THEN1");const n=e.withinCapturing(t).getByTestId(a.todoItemCheckboxLabel);await e.assertWaitable.equal(n.textContent,f[1].text+"; some updates"),e.demoForEndUserHide(),e.ref("THEN2A"),await e.assertWaitable.equal(n.style.textDecoration,"line-through"),e.ref("THEN2B"),await e.assertWaitable.isTrue(e.withinCapturing(t).getByRole("checkbox").checked),e.ref("THEN3"),await e.assertWaitable.include(t.className,_)}async whenButtonDeleteClicked(){e.demoForEndUserHide(),e.ref("WHEN");let t=e.screenCapturing.getByTestId(a.todoItem+"_0");await e.userEventWaitable.click(e.withinCapturing(t).getByTestId(a.delete)),e.ref("WHEN1"),await e.userEventWaitable.click(e.screenCapturing.getByTestId(a.deleteNo)),e.ref("THEN1"),await e.assertWaitable.equal(e.withinCapturing(t).getByTestId(a.todoItemCheckboxLabel).textContent,f[0].text),e.demoForEndUserShow(),e.ref("WHEN2"),await e.userEventWaitable.click(e.withinCapturing(t).getByTestId(a.delete)),e.ref("WHEN3"),await e.userEventWaitable.click(e.screenCapturing.getByTestId(a.deleteYes)),e.ref("THEN3"),t=e.screenCapturing.getByTestId(a.todoItem+"_0"),await e.assertWaitable.include(e.withinCapturing(t).getByTestId(a.todoItemCheckboxLabel).textContent,f[1].text)}};c(x,"TodosTestsAreDemo");let l=x;d([r()],l.prototype,"_quickInstructions",1);d([I()],l.prototype,"demo",2);d([r()],l.prototype,"whenScreenTodosShows",1);d([r()],l.prototype,"andWhenButtonAddClicked",1);d([r()],l.prototype,"andWhenCheckboxClicked",1);d([r()],l.prototype,"whenButtonUpClicked",1);d([r()],l.prototype,"whenButtonDownClicked",1);d([r()],l.prototype,"whenDoubleClick",1);d([r()],l.prototype,"whenButtonEditClick",1);d([r()],l.prototype,"whenButtonDeleteClicked",1);e.miniDb=new class extends R{async populate(o,...t){for(let i of t){const s=await fetch("https://my.server.com/getTodosForUser/1234/"+i).then(n=>n.json());this.addRow(o,i,s)}return this}};e.addTests(g,E,l);
//# sourceMappingURL=appTests-ClmsxnHd.js.map
