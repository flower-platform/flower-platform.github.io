var b=Object.defineProperty;var y=(r,t,a)=>t in r?b(r,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):r[t]=a;var T=(r,t,a)=>(y(r,typeof t!="symbol"?t+"":t,a),a);import{R as C,T as x,t as o,c as f,s as p,a as k,b as E}from"./index.be008788.js";import{C as c,S as s,a as w,c as I,t as e}from"./TestsAreDemoFunctions.4e5b6b89.js";class W{annotation(){c(`
            If your project doesn't support TypeScript decorators, we offer a fallback solution, which we name "pseudo" annotations.

            Add functions that named "annotation...". If the name is just "annotation", then we consider it as being associated to the class.
            Otherwise, e.g. "annotation1", we consider it as being associated with the next function.

            Within such a "pseudo" annotation function, we expect you to invoke directly the annotation functions / decorators. We built them
            in such a way to support this dual working mode.
        `)}annotation1(){s("WHEN click on 'Brodcast message', THEN a popup with textbox opens, AND WHEN message is written and 'Send' is clicked, THEN an email is sent to all employees")}whenClickBroadcastNotification(){}annotation2(){c("The suffix after 'annotation' is not important. Probably the simplest solution is to name them 'annotation1', 'annotation2', etc."),c("Multiple comments are supported as well."),s("WHEN something, THEN something else")}whenSomething(){}}var B=Object.defineProperty,v=Object.getOwnPropertyDescriptor,g=(r,t,a,n)=>{for(var i=n>1?void 0:n?v(t,a):t,h=r.length-1,u;h>=0;h--)(u=r[h])&&(i=(n?u(t,a,i):u(i))||i);return n&&i&&B(t,a,i),i};let m=class{render(){}whenClickNewHoliday(){}};g([c(`
        This is a comment that has multiple lines. Each line from the code
        is rendered as a new line in the UI. The goal is to try to have a similar/familiar
        layout between the file/code and what's rendered in the browser.

        Empty new lines are also permitted. But not the trailing ones (start or end), like the one below.

    `),s("RENDERER for an overview of the employees")],m.prototype,"render",1);g([c("Here we have multiple comments. This is the first."),c("Second."),c("Third and last."),s("WHEN click on 'New holiday', THEN the Holiday form opens, AND some data is prefilled based on the current logged in user")],m.prototype,"whenClickNewHoliday",1);m=g([c("This is a fictional test, used to demonstrate various details of the existing annotations"),c(`@Comment is a decorator meant for TestAreDemo classes and its functions (scenarios).
We also call these decorators: annotations, like in Java. And they exist also in Java. We tried
to make them as similar as possible (the TypeScript variants vs the Java variants).`)],m);var N=Object.defineProperty,H=Object.getOwnPropertyDescriptor,d=(r,t,a,n)=>{for(var i=n>1?void 0:n?H(t,a):t,h=r.length-1,u;h>=0;h--)(u=r[h])&&(i=(n?u(t,a,i):u(i))||i);return n&&i&&N(t,a,i),i};class l{constructor(){T(this,"whenUpItem")}async before(){I(C.createElement(x,null)),await e.waitForCommunicationFinished()}async screenTodos(){let t=e.screenCapturing.getByTestId(o.todoItem+"_0");e.cc("`Todo.priority` -> color of the top border"),await e.assertWaitable.include(t.className,f),e.cc("`Todo.text`");let a=e.withinCapturing(t).getByTestId(o.todoItemCheckboxLabel);await e.assertWaitable.equal(a.textContent,p[0].text),e.cc("`Todo.done`: when `true`, we 'line through' the text"),await e.assertWaitable.equal(a.style.textDecoration,"line-through"),e.cc("`Todo.done`: when `true` we check the checkbox"),await e.assertWaitable.isTrue(e.withinCapturing(t).getByRole("checkbox").checked),e.demoForEndUserHide(),t=e.screenCapturing.getByTestId(o.todoItem+"_2"),e.cc("`Todo.priority` -> color of the top border"),await e.assertWaitable.include(t.className,k),e.cc("`Todo.text`"),a=e.withinCapturing(t).getByTestId(o.todoItemCheckboxLabel),await e.assertWaitable.equal(a.textContent,p[2].text),e.cc("`Todo.done`: when `false`, we don't 'line through' the text"),await e.assertWaitable.notEqual(a.style.textDecoration,"line-through"),e.cc("`Todo.done`: and we uncheck the checkbox"),await e.assertWaitable.isFalse(e.withinCapturing(t).getByRole("checkbox").checked),e.demoForEndUserShow(),e.cc("Total number of Todos"),await e.assertWaitable.equal(e.screenCapturing.getByTestId(o.total).textContent,"6"),e.cc("Number of Todos w/ priority = Low"),await e.assertWaitable.equal(e.screenCapturing.getByTestId(o.totalLow).textContent,"1"),e.cc("Number of Todos w/ priority = Normal"),await e.assertWaitable.equal(e.screenCapturing.getByTestId(o.totalNormal).textContent,"3"),e.cc("Number of Todos w/ priority = High"),await e.assertWaitable.equal(e.screenCapturing.getByTestId(o.totalHigh).textContent,"2")}async whenAddThenForm(){e.cc("Let's add a new Todo"),await e.userEventWaitable.click(e.screenCapturing.getByTestId(o.add))}async formTodo1(){e.cc("Please observe that this text field is already focused. So you can directly start typing, w/o needing to click here first");const t=e.withinCapturing(e.screenCapturing.getByTestId(o.inputText)).getByRole("textbox");e.demoForEndUserHideNext(),await e.assertWaitable.equal(document.activeElement,t),await e.userEventWaitable.type(t,"My task"),await e.userEventWaitable.click(e.screenCapturing.getByTestId(o.save)),e.cc("The newly added Todo appears at the bottom of the list");let a=e.screenCapturing.getByTestId(o.todoItem+"_6"),n=e.withinCapturing(a).getByTestId(o.todoItemCheckboxLabel);await e.assertWaitable.equal(n.textContent,"My task")}async whenCheckbox(){let t=e.screenCapturing.getByTestId(o.todoItem+"_1"),a=e.withinCapturing(t).getByTestId(o.todoItemCheckboxLabel);e.cc("When we solve the Todo, we click on the text or checkbox"),await e.userEventWaitable.click(a),e.cc("The checkbox becomes checked, and the text is 'line-through'"),await e.assertWaitable.isTrue(e.withinCapturing(t).getByRole("checkbox").checked),e.demoForEndUserHide(),await e.userEventWaitable.click(a),e.cc("Toggled back from done -> not done"),await e.assertWaitable.isFalse(e.withinCapturing(t).getByRole("checkbox").checked)}async whenUp(){e.cc("We may move the Todo up. Now 'Repair the bike' is the second");let t=e.screenCapturing.getByTestId(o.todoItem+"_1");await e.userEventWaitable.click(e.withinCapturing(t).getByTestId(o.up)),t=e.screenCapturing.getByTestId(o.todoItem+"_0"),e.cc("And after clicking, it moved up, so 'Repair the bike' is the first"),await e.assertWaitable.equal(e.withinCapturing(t).getByTestId(o.todoItemCheckboxLabel).textContent,"Repair the bike"),this.whenUpItem=t}async whenDown(){let t=this.whenUpItem;await e.userEventWaitable.click(e.withinCapturing(t).getByTestId(o.down)),t=e.screenCapturing.getByTestId(o.todoItem+"_0"),e.cc("Element [0] moved down and is now element [1], as in the initial setup"),await e.assertWaitable.equal(e.withinCapturing(t).getByTestId(o.todoItemCheckboxLabel).textContent,"Buy groceries for next week")}async whenDoubleClick(){e.demoForEndUserHide(),await e.userEventWaitable.dblClick(e.screenCapturing.getByTestId(o.todoItem+"_1")),await e.userEventWaitable.click(e.screenCapturing.getByTestId(o.cancel)),await e.assertWaitable.notExists(e.screenCapturing.queryByTestId(o.form))}async whenEditThenForm(){e.cc("A Todo may be edited");let t=e.screenCapturing.getByTestId(o.todoItem+"_1");await e.userEventWaitable.click(e.withinCapturing(t).getByTestId(o.edit))}async formTodo2(){const t=e.withinCapturing(e.screenCapturing.getByTestId(o.inputText)).getByRole("textbox");await e.userEventWaitable.type(t,"; some updates"),e.cc("We may check/uncheck for the editor as well"),await e.userEventWaitable.click(e.screenCapturing.getByTestId(o.formCheckbox)),e.cc("We also have the notion of priority");const a=e.screenCapturing.getByTestId(o.formPriority);await e.userEventWaitable.click(e.withinCapturing(a).getByRole("button",{name:/low/i})),await e.userEventWaitable.click(e.screenCapturing.getByTestId(o.save));let n=e.screenCapturing.getByTestId(o.todoItem+"_1");e.cc("The Todo was updated");const i=e.withinCapturing(n).getByTestId(o.todoItemCheckboxLabel);await e.assertWaitable.equal(i.textContent,p[1].text+"; some updates"),e.demoForEndUserHide(),await e.assertWaitable.include(n.className,E),await e.assertWaitable.equal(i.style.textDecoration,"line-through"),await e.assertWaitable.isTrue(e.withinCapturing(n).getByRole("checkbox").checked)}async whenDelete(){e.cc("A Todo may be deleted"),e.demoForEndUserHide();let t=e.screenCapturing.getByTestId(o.todoItem+"_0");await e.userEventWaitable.click(e.withinCapturing(t).getByTestId(o.delete)),await e.userEventWaitable.click(e.screenCapturing.getByTestId(o.deleteNo)),e.cc("The Todo wasn't deleted"),await e.assertWaitable.equal(e.withinCapturing(t).getByTestId(o.todoItemCheckboxLabel).textContent,p[0].text),e.demoForEndUserShow(),await e.userEventWaitable.click(e.withinCapturing(t).getByTestId(o.delete)),await e.userEventWaitable.click(e.screenCapturing.getByTestId(o.deleteYes)),e.cc("The Todo was deleted. So the second element (index 1) became element the first element (index 0)"),t=e.screenCapturing.getByTestId(o.todoItem+"_0"),await e.assertWaitable.include(e.withinCapturing(t).getByTestId(o.todoItemCheckboxLabel).textContent,p[1].text)}}d([c("Todos (func comp)"),s("SCREEN Todos")],l.prototype,"screenTodos",1);d([s("WHEN click on Add, THEN the form opens"),w({linkWithNextScenario:!0})],l.prototype,"whenAddThenForm",1);d([s("FORM for a Todo; test #1")],l.prototype,"formTodo1",1);d([c("TodoItem (func comp)"),s("WHEN click on checkbox or label, THEN toggle 'done'")],l.prototype,"whenCheckbox",1);d([s("WHEN click on UP, THEN the Todo slides up"),w({linkWithNextScenario:!0})],l.prototype,"whenUp",1);d([s("WHEN click on DOWN, THEN the Todo slides down")],l.prototype,"whenDown",1);d([s("WHEN double click on a Todo, THEN the form opens")],l.prototype,"whenDoubleClick",1);d([s("WHEN click on Edit, THEN the form opens"),w({linkWithNextScenario:!0})],l.prototype,"whenEditThenForm",1);d([c("TodoForm (func comp)"),s("FORM for a Todo; test #2")],l.prototype,"formTodo2",1);d([c("TodoItem again"),s("WHEN click on DELETE, THEN confirm, AND WHEN 'yes', THEN the Todo is removed")],l.prototype,"whenDelete",1);e.addTests(m,W,l);
